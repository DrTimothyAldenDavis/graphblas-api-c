\section{Example: Betweenness Centrality}
\label{sec:example}

Betweenness centrality (BC) is a popular metric to assess the centrality of 
vertices in a graph. It is based on shortest paths where the BC score of a
vertex $v$ is the normalized ratio of the number of shortest paths between 
any pair of vertices that go through $v$ to the total number of shortest paths 
in the graph.  Equation~\ref{eqn:bc} formally defines BC where $\sigma_{st}$ 
denotes the number of shortest paths from vertex $s$ to vertex $t$, and 
$\sigma_{st}(v)$ is the number of such paths passing through vertex $v$:
\begin{equation}
	BC(v) = \sum_{s \neq v \neq t \in V} \frac{\sigma_{st}(v)}{\sigma_{st}}
\label{eqn:bc}
\end{equation}
The BC score is efficiently computed using Brandes' 
algorithm~\cite{brandes2001faster}, 
which runs in $O(mn)$ time on unweighted graphs and avoids the expensive 
explicit all-pairs shortest paths computation.  For each starting vertex $s$, 
Brandes' algorithm computes the BC contributions from the shortest paths starting
at $s$ that pass through every other vertex.

We implemented a batched version of Brandes' 
algorithm~\cite{combblas,bader2006designing,robinson2011complex} using 
the GraphBLAS C API where BC contributions from multiple 
source vertices are computed simultaneously. 
Figure~\ref{Fig:BClisting} shows the subroutine, {\tt BC\_update}, that computes
BC contributions from a subset of source vertices. Compared to previous work, the 
flexibility offered by the GraphBLAS API (i.e., the masks, accumulators, 
and descriptors) reduces  the number of function calls in the main loops and the
number of intermediate objects.

At a high level, the {\tt BC\_update} function performs two sweeps over the 
graph. The forward sweep performs multiple simultaneous
breadth-first search traversals (one for each source vertex) and keeps track 
of the number of independent shortest paths that reach every vertex from 
the source.  This is performed by the do-while loop starting at 
line~\ref{line:dowhile}. The backward sweep rolls back and tallies the BC 
contributions to every vertex. This is performed by the for loop starting 
at line~\ref{line:forloop}.  

The remainder of this section describes the 
GraphBLAS implementation in detail.  
For the sake of brevity and clarity, the examination of 
{\tt GrB\_Info} return codes and handling of any errors are omitted.


\begin{figure*}[h]
\caption{C function using GraphBLAS primitives that computes the BC-metric
updates ${\it delta}$, given Boolean $n \times n$ adjacency matrix $A$, a
set of source vertices $s$, and the number of source vertices (i.e., the 
length of s) ${\it nsver}$.}
\label{Fig:BClisting}
{\scriptsize
\lstinputlisting[language=C,escapechar=|,numbers=left]{GabbBC4M.c}
}
\end{figure*}

\subsection{Signature}

In line~\ref{line:include}, a single header file, {\tt GraphBLAS.h}  
 defines all GraphBLAS collections, algebraic objects, and method signatures.  
 The {\tt BC\_update} expects the following parameters (line~\ref{line:sig}):

\begin{itemize} [leftmargin=0.6in]
\item[\tt delta] an uninitialized vector that will hold the computed BC contributions to each
                 vertex on return.  It is initialized to $n$ 32-bit floating
                 point elements (line~\ref{line:init_output}).
\item[\tt A]     an $n\times n$ integer adjacency matrix representing an
                 unweighted, directed graph where the presence of an edge
                 is indicated by a stored 1.
\item[\tt s]     an array of source vertex indices (the batch).
\item[\tt nsver] the number of source vertices in {\tt s}
\end{itemize}
\noindent
Although not required, this function returns the same type of status code as
found in all GraphBLAS methods.

\subsection{BFS Phase Objects}
 
During the forward sweep, the algorithm performs {\tt nsver} simultaneous BFS traversals.  In this
implementation it uses 32-bit integer ({\tt GrB\_INT32} domain) arithmetic and
relies on GraphBLAS's predefined binary operators, {\tt GrB\_PLUS\_INT32} and 
{\tt GrB\_TIMES\_INT32}, to declare an addition monoid ({\tt Int32Add} on line~\ref{line:int_add})
and the arithmetic semiring ({\tt Int32AddMul} on line~\ref{line:int_arithmetic}). If the application needs to process
 larger graphs, this code should be modified to use 64-bit integer arithmetic and 64-bit indices.
%Note that these objects have been proposed as
%extensions to the API specification, and if adopted, these declarations will not
%be necessary.  
A descriptor is used for this phase (starting on line~\ref{line:bfs_desc})
to transpose the first input matrix, structurally complement the mask (if provided),
and ``replace'' the values in the output vector.

The columns of the {\tt numsp} matrix keep track of the number of independent 
shortest paths that reach every other vertex from the corresponding source 
vertices.  The dimensions are {\tt n}$\times${\tt nsver} where each column corresponds
to a different source vertex.  This matrix is initialized so a single
element in each column, corresponding to its source vertex, 
is set to one.  Mathematically,
\begin{equation}
	{\tt numsp}({{\tt s}_i},i) = 1, \text{ for }  0 \leq i < {\tt nsver}.
\end{equation}
This is accomplished in lines~\ref{line:numsp_begin}--\ref{line:numsp_end}
using the {\tt GrB\_Matrix\_build} operation.  The row index array for this operation comes from 
the {\tt s} parameter while the column indices are created in the {\tt i\_nsver}
array -- one for each source vertex.  An array of size {\tt nsver} is filled 
with ones in {\tt ones}.  The call to {\tt GrB\_Matrix\_build} 
%does  not require an accumulation operator, mask, or descriptor.  It 
specifies the integer addition operator, {\tt GrB\_PLUS\_INT32}, in case there are any
duplicate entries.
%, but there are none.

The columns of the {\tt frontier} matrix contain the current frontiers for the
traversals from each source vertex.  Integers are stored that correspond to how
many shortest paths reached a given vertex during that step. 
In lines~\ref{line:frontier_begin}--\ref{line:frontier_end}, this
{\tt n}$\times${\tt nsver} matrix is initialized.  Each column of this 
matrix is initialized to the out vertices of the corresponding source
vertex.  This 
%could be accomplished by performing a single BFS step (using the 
%the {\tt mxm} operation) with the {\tt numsp} matrix as the input frontier.
%An alternate approach is shown here using the 
is done using the GraphBLAS {\tt extract}
operation on the graph matrix {\tt A}.  The descriptor transposes {\tt A}, such that
the use of the {\tt s} array specified for the column indices selects
each row of {\tt A} corresponding to the source vertices.
The use of {\tt GrB\_ALL} specified for all {\tt n} row indices 
ensures that all out neighbors of the selected source vertices are included.  
The {\tt numsp} matrix
is specified as the mask, which is complemented by the descriptor, and has the
effect of removing the source vertices themselves from 
each frontier (it will remove these elements only if source vertices have edges that point
to themselves).  Since the {\tt frontier} matrix is already empty, the 
descriptor's {\tt GrB\_REPLACE} parameter has no effect.

The final data structures needed for the BFS phase are a set of matrices that
store the current frontier at each step of the BFS phase.  This is stored in
an array of  matrices called {\tt sigmas}.  A set of {\tt n} 
of these matrices is dynamically allocated at line~\ref{line:sigma_init}.  Note that the 
number of these matrices is bounded by the diameter of the graph whose
upper bound is the number of vertices in the graph.


\subsection{BFS Phase (Forward Sweep)}

The BFS phase of the computation begins with the do-loop on line~\ref{line:dowhile}. 
The first step initializes the {\tt n}$\times${\tt nsver} {\tt sigmas[d]} matrix 
(line~\ref{line:sigma_new}) and sets it to the current frontier 
(line~\ref{line:sigma_set}).  The {\tt apply} operation
is used for the assignment and by using the unary operator, {\tt GrB\_IDENTITY\_BOOL},
casts the integers in the frontier to booleans.
On line~\ref{line:add_paths}, the path counts for the current frontier are
accumulated using the {\tt eWiseAdd} operation to perform an element-wise addition of
the {\tt numsp} and {\tt frontier} matrices.  The result is stored in {\tt numsp}. 

The {\tt GrB\_mxm} call on line~\ref{line:mxm1} forms the next frontier in one step 
by both expanding the current frontier (i.e., discovering the 1-hop neighbors 
of the set of vertices in the current frontier) and pruning the vertices 
that have already been discovered. The former is achieved by setting the
descriptor, {\tt desc\_tsr}, to use the transpose of the adjacency matrix. The 
latter is achieved by setting the descriptor to use the structural complement of the mask 
and by passing the {\tt numsp} matrix as the mask parameter. The 
implicit cast of {\tt numsp} to Boolean allows {\tt GrB\_mxm} to interpret 
{\tt numsp} as the set of previously discovered vertices.  Note that the descriptor is 
also set to {\tt GrB\_REPLACE} to ensure that the frontier is overwritten with new
values.

The loop ends by computing the number of values in the new frontier using the
matrix method, {\tt GrB\_Matrix\_nvals}.  If the result (stored in {\tt nvals}) 
is zero, there are no vertices in the frontier and the forward sweep is completed.

\subsection{Tally Phase Objects}

The BC contributions are calculated during the tallying phase that 
performs a backwards sweep using the previously stored BFS trees.  An 
arithmetic semiring with a floating-point
domain is used for this computation.  In this example, we choose 32-bit float-point types and declare
the necessary monoids and semiring (starting at line~\ref{line:fp_arithmetic})
based on GraphBLAS's predefined binary operators.

Starting on line~\ref{line:nspinv}, the element-wise inverse of {\tt numsp} is 
computed using the {\tt apply} operation along with the predefined multiplicative inverse
unary function defined for 32-bit floating point, {\tt GrB\_MINV\_FP32}.
Then, the {\tt bcu} variable that holds the per-source BC contributions is initialized
to all ones in order to avoid issues with the treatment of implied zeros (starting at 
line~\ref{line:bcu_init}). This fill is accomplished with a variant of the {\tt assign} 
operation that allows the same value to be assigned to a subgraph, and that specifies 
{\tt GrB\_ALL} for both row and column indices.
Last, a descriptor object, {\tt desc\_r}, needed by the Tally Phase is 
initialized starting on line~\ref{line:desc}.  The only parameter needed in this
phase is ``replace'' semantics when using a mask. 


\subsection{Tally Phase (Backward Sweep)}

After the initialization of a temporary workspace matrix {\tt w}, the Tally
Phase begins on line~\ref{line:forloop}.  
On line~\ref{line:tallyewm1}, the contributions of each ``end'' vertex to its 
predecessors are divided by the number of shortest paths that reach them. This is accomplished
with an {\tt eWiseMult} operation where the {\tt sigma[i]} matrix is
used to ensure that only paths identified in the BFS phase are assigned to
the result.
The {\tt GrB\_mxm} call on line~\ref{line:mxm2} discovers \emph{predecessors} (as opposed to 
successors in the forward sweep) by its use of the descriptor {\tt desc\_r} 
(defined in line~\ref{line:desc}) that uses the 
adjacency matrix (as opposed to its transpose). The algorithm assures that the BC contributions are 
transferred only to direct parents on the BFS tree by passing the previous 
level of BFS tree ({\tt sigma[i-1]}) as a mask to {\tt GrB\_mxm}. 
Last, the elements of the {\tt w} matrix are scaled by the number of shortest
paths with the {\tt eWiseMult} operation on line~\ref{line:accum_bcu}, and this result
is accumulated into the BC update matrix, {\tt bcu}.
This loop terminates when the original source vertices are reached and the columns
of {\tt bcu} contain the BC updates for each source vertex, respectively.

\subsection{Computing BC Updates}

To compute the BC updates for all vertices in this batch, 
the elements in each row of {\tt bcu} are accumulated using the {\tt reduce} 
operation on line~\ref{line:bcu_reduce}.  This result is biased because 
{\tt bcu} began the loop filled with ones; hence all entries in this matrix are
greater than the actual update by one.  As a result, all elements of the reduction 
need to be adjusted by the number of source vertices.  This is accomplished by
accumulating the reduction result (in line~\ref{line:bcu_reduce}) with the output
vector, {\tt delta}, that was filled with {\tt -nsver} on line~\ref{line:compensate}).

The remainder of the subroutine frees resources allocated
in this computation.  Note that {\tt GrB\_free\_all} is a convenience macro (not part of GraphBLAS C API) that 
expands to {\tt GrB\_free} for each of its parameters.
