\section{The GraphBLAS C API}
\label{sec:Capi}

A complete definition of all the elements that make up the GraphBLAS C API
is clearly beyond the scope of this paper.  Instead, we focus on those
elements of the API needed to understand the betweenness centrality
example in section~\ref{sec:example}. 

We begin with set of data types used for the objects in the example.
These are listed in table~\ref{Tab:GrBdataTypes}.  Other than the types that map directly onto
C language basic types ({\sf GrB\_Info}, {\sf GrB\_Index}, and {\sf GrB\_Type}) these data types
are used to define handles to opaque objects manipulated by GraphBLAS methods.
\begin{table}[h]
\hrule
\begin{center}
\caption{GraphBLAS data types.}
\label{Tab:GrBdataTypes}
\begin{tabular}{lp{5.25cm}}
Data type                     & Description  \\
\hline
	{\sf GrB\_Info}           & Return value from any GraphBLAS method \\
	{\sf GrB\_Index}          & Vector and matrix indices \\
	{\sf GrB\_Type}		      & Type identifier \vspace{.1cm} \\ 
	{\sf GrB\_Descriptor}     & Opaque GraphBLAS descriptor object \\
	{\sf GrB\_Monoid}         & Opaque GraphBLAS monoid object  \\
	{\sf GrB\_Semiring}       & Opaque GraphBLAS semiring object  \\
	{\sf GrB\_Matrix}         & Opaque GraphBLAS matrix object \\
	{\sf GrB\_Vector}         & Opaque GraphBLAS vector object \\
\end{tabular}
\end{center}
\hrule
\end{table}
Objects corresponding to algebraic structures ({\sf GrB\_Monoid} and {\sf GrB\_Semiring}) are constructed from lower level
operators. The GraphBLAS C API specification provides a mechanism for creating user-defined operators, but for the 
sake of this paper we focus on the operators predefined in the specification.  The ones used by the example are summarized
in table~\ref{Tab:GrBops}. 
\begin{table}[h]
\hrule
\begin{center}
\caption{Some predefined GraphBLAS operators.}
\label{Tab:GrBops}
\begin{tabular}{lp{5.25cm}}
Operator                       & Description  \\
\hline
	{\sf GrB\_TIMES\_INT32}    & Binary operation that returns the product of two 32-bit integer values \\
	{\sf GrB\_PLUS\_INT32}     & Binary operation that returns the sum of two 32-bit integer values \\
	{\sf GrB\_PLUS\_FP32}      & Binary operation that returns the sum of two 32-bit floating-point values \\
	{\sf GrB\_TIMES\_FP32}     & Binary operation that returns the product of two 32-bit floating-point values \\
	{\sf GrB\_MINV\_FP32}      & Unary operation that returns the multiplicative inverse of the input 32-bit floating-point value \\
	{\sf GrB\_IDENTITY\_BOOL}  & Unary operation that returns the input boolean value \\
\end{tabular}
\end{center}
\hrule
\end{table}
A number of constant literal values are used in the GraphBLAS methods.  These are used to 
choose among options for each of the methods or to define return values from the functions.
The most commonly used literals in the GraphBLAS, including those used in the example in 
section~\ref{sec:example}, are listed in table~\ref{Tab:GrBliterals}.
\begin{table}[h]
\hrule
\begin{center}
\caption{Some GraphBLAS literals.}
\label{Tab:GrBliterals}
\begin{tabular}{lp{5.9cm}}
Literal                 & Description  \\
\hline
	{\sf GrB\_OUTP}      & Descriptor field for the output argument. \\
	{\sf GrB\_MASK}      & Descriptor field for the mask. \\
	{\sf GrB\_INP0}      & Descriptor field for the first input argument. \\
	{\sf GrB\_INP1}      & Descriptor field for the second input argument. \\ 
	{\sf GrB\_SCMP}      & Descriptor value to indicate use of the structural complement of the mask. \\
	{\sf GrB\_TRAN}      & Descriptor value to indicate use of the transpose of the corresponding input matrix. \\
	{\sf GrB\_REPLACE}   & Descriptor value to indicate that the output object should be replaced by the result of the method. \\ 
	{\sf GrB\_ALL}       & Used with methods that work with subsets of indices to indicate that all indices in an object are to be selected. \\
	{\sf GrB\_NULL}      & A \emph{null} value used to indicate when a parameter is not provided and a default behavior should be used. \\
	{\sf GrB\_SUCCESS}   & A return value indicating that a method has returned without encountering an error condition. \\
	{\sf GrB\_BOOL}		   & Identifier for boolean type. \\
	{\sf GrB\_INT32}	   & Identifier for 32-bit integer type. \\
	{\sf GrB\_FP32}		   & Identifier for 32-bit floating point type. \\
\end{tabular}
\end{center}
\hrule
\end{table}

To illustrate the principles of the GraphBLAS C API, we
will consider in detail a single method: the {\sf GrB\_mxm()} operation, shown in Figure~\ref{Fig:mxm}.
The GraphBLAS method {\sf GrB\_mxm()} takes three input matrices $\matrix{A}$, $\matrix{B}$, and $\matrix{C}$, 
computes a matrix product of $\matrix{A}$ and $\matrix{B}$ and either copies the result into the matrix $\matrix{C}$
or optionally accumulates the product into the matrix $\matrix{C}$.  Based on the provided arguments 
and the descriptor used with the method, the semantics of {\sf GrB\_mxm()} can vary considerably.
The function of the descriptor is consistent across all methods such that understanding it for
{\sf GrB\_mxm()} helps one understand it for all methods.

\begin{figure*}[h]
\hrule
	\caption{The {\sf GrB\_mxm()} function signature and basic argument definitions.}
\label{Fig:mxm}
\paragraph{Signature}
\footnotesize
\begin{verbatim}
        GrB_Info GrB_mxm(GrB_Matrix              *C,
                         const GrB_Matrix         Mask,
                         const GrB_BinaryOp       accum,
                         const GrB_Semiring       op,
                         const GrB_Matrix         A, 
                         const GrB_Matrix         B,
                         const GrB_Descriptor     desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS matrix. On
    input, the matrix provides values that may be accumulated with the
    result of the matrix product.   On output, the matrix holds the
    results of this operation.

    \item[{\sf Mask}] ({\sf IN}) A ``write'' mask that controls which
    results from this operation are stored into the output matrix
    ${\sf C}$ (optional).  If no mask is desired,  {\sf GrB\_NULL}
    should be specified. The Mask dimensions must match those of the
    matrix {\sf C} and the domain of the {\sf Mask} matrix must be
    of type {\sf bool} or any of the predefined GraphBLAS ``built-in'' types.

    \item[{\sf accum}] ({\sf IN}) A binary operator used for accumulating entries
    into existing \matrix{\sf C} entries. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}] ({\sf IN}) Semiring used in the matrix-matrix
    multiply: ${\sf op}=\langle D_1,D_2,D_3,\oplus,\otimes,0 \rangle$.

    \item[{\sf A}] ({\sf IN}) The GraphBLAS matrix holding the values
    for the left-hand matrix in the multiplication.

    \item[{\sf B}] ({\sf IN}) The GraphBLAS matrix holding the values
    for the right-hand matrix in the multiplication.

    \item[{\sf desc}] ({\sf IN}) Operation descriptor (optional). If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    used. Valid fields are as follows: 

    \begin{tabular}{lllp{2.75in}}
    Argument   & Field           & Value               & Description \\ \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE}  & Output matrix {\sf C} is cleared (all elements removed) before result is stored in it. \\
    {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}     & Use the structural complement of {\sf Mask}. \\
    {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}     & Use transpose of {\sf A} for operation. \\
    {\sf B}    & {\sf GrB\_INP1} & {\sf GrB\_TRAN}     & Use transpose of {\sf B} for operation. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]

	\item[{\sf GrB\_SUCCESS}]	      In blocking mode, operation
	completed successfully. In non-blocking mode, this indicates
	that the consistency tests on dimensions and domains for the
	input arguments passed successfully.  

	\item[{\sf GrB\_PANIC}]		      Unknown internal error

	\item[{\sf GrB\_OUTOFMEM}]	      Not enough memory available
	for operation

	\item[{\sf GrB\_DIMENSION\_MISMATCH}] Matrix dimensions are
	incompatible.

	\item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various
	matrices are incompatible with the corresponding domains of the
	accumulating operation, semiring, or mask.

\end{itemize}

\hrule
\end{figure*}
The semantics of GraphBLAS methods associated with the operations from table~\ref{Tab:GraphBLASOps} follow a similar pattern
in each case:
\begin{enumerate}
\item The internal matrices and mask used in the computation are formed from the input parameters.  Their domains/dimensions are tested for consistency.
\item The indicated computations are carried out using the interinal matrices and producing an internal result.
\item The internal result is written into the output matrix, possibly under control of a mask.
\end{enumerate}
In the case of the {\sf GrB\_mxm} operation, internal matrices $\matrix{A}$, $\matrix{B}$, $\matrix{C}$, and mask $\matrix{Mask}$ are formed from
the corresponding arguments according to the descriptor.  Depending on
the values in the descriptor fields {\sf GrB\_INP0} and {\sf GrB\_INP1},  $\matrix{A}$ and/or $\matrix{B}$ may be the transpose of the corresponding argument.
The descriptor field {\sf GrB\_MASK} may also indicate that the structural complement of the mask 
should be used.  If the domains and sizes of the objects are mathematically consistent, the indicated operation is carried out.
This produces an internal matrix $\matrix{T}$ with the result of the product matrices $\matrix{A}$ and $\matrix{B}$.
(We emphasize that an implementation
of the GraphBLAS is not required to, and in fact probably would not, materialize the matrix $\matrix{T}$).

If an optional binary accumulator function {\sf accum} is provided, it is applied to combine the elements of 
matrix $\matrix{C}$ and the internal matrix $\matrix{T}$.  This forms a new internal matrix $\matrix{Z}$ (which also does not have to be materialized by an implementation). 

At this point the elements of $\matrix{Mask}$ are used as a \emph{write mask} to select which elements of $\matrix{Z}$ are 
used to form the final output result.  Basically, the elements of the boolean write mask that exist and are true 
correspond to the elements of the output matrix that might be replaced by the corresponding elements of $\matrix{Z}$.
Two options are supported: 
\begin{itemize}
	\item \emph{Replace mode}: If the descriptor field {\sf GrB\_OUTP} is set to {\sf GrB\_REPLACE}, the 
		values in the $\matrix{C}$ matrix are deleted before masked elements of $\matrix{Z}$ are stored 
		in $\matrix{C}$.  In essence the computed matrix $\matrix{Z}$ \emph{replaces} the original matrix $\matrix{C}$.
	\item \emph{Merge mode}: Otherwise, the elements from the computation selected by the 
		write mask are written into the output $\matrix{C}$ matrix without changing elements
		that do not overlap with the mask.
\end{itemize}
This discussion has been largely qualitative and there are many low level details an implementor
of {\sf GrB\_mxm()} would need to address.  The high level description of this operation, however, should
give a basic idea of matrix multiplication in GraphBLAS.

The basic pattern used in {\sf GrB\_mxm()} is mapped onto all the GraphBLAS mathematical operations.  
Consider the methods used in the example from section~\ref{sec:example}.  These are listed in 
table~\ref{Tab:GrBmethods}.   The methods associated with the mathematical operations in 
Table~\ref{Tab:GraphBLASOps} (from {\sf GrB\_mxm} to {\sf GrB\_reduce})
all have descriptor driven options to modify input matrices or vectors, optional accumulator 
functions and write masks.   Low level details may vary but the basic pattern used
in {\sf GrB\_mxm} holds.
 
\begin{table*}[h]
\hrule
\begin{center}
\caption{The following methods are used in the Betweenness Centrality example in section~\ref{sec:example}.  The third 
column in this table refers to the section in the GraphBLAS C specification 1.0 where the method is more fully defined.}
\label{Tab:GrBmethods}
\begin{tabular}{lll}
Method Name                     & Description  & Section \\
\hline
	{\sf GrB\_Monoid\_new}      & Creates a new monoid with specified domain, operator, and identity element.       & 4.2.1.4 \\
	{\sf GrB\_Semiring\_new}    & Creates a new semiring with specified domain, monoid and operators.               & 4.2.1.5 \\
	{\sf GrB\_Vector\_new}      & Creates a new vector with specified domain and size.                              & 4.2.2.1 \\
	{\sf GrB\_Matrix\_new}      & Creates a new matrix with specified domain and dimensions.                        & 4.2.3.1 \\
	{\sf GrB\_Matrix\_nrows}    & Retrieve the number of rows in a matrix.                                          & 4.2.3.3 \\
	{\sf GrB\_Matrix\_nvals}    & Retrieve the number of stored elements (tuples) in a matrix.                      & 4.2.3.5 \\
	{\sf GrB\_Descriptor\_new}  & Creates a new (empty) descriptor.                                                 & 4.2.4.1 \\
	{\sf GrB\_Descriptor\_set}  & Sets the content (details of an operation) for a field of an existing descriptor. & 4.2.4.2 \\
	{\sf GrB\_Matrix\_build}    & Copies elements from tuples into a matrix                                         & 4.3.1 \\
	{\sf GrB\_mxm}              & Multiplies a matrix with another matrix on a semiring.                            & 4.3.5 \\
	{\sf GrB\_eWiseMult}        & Performs an element-wise multiplication on the elements of two matrices           & 4.3.8.2, standard matrix variant  \\
	{\sf GrB\_eWiseAdd}         & Performs an element-wise addition on the elements of two matrices                 & 4.3.9.2, standard matrix variant \\
	{\sf GrB\_extract}          & Extract a subgraph from an input matrix and copy them into an output matrix.      & 4.3.10.2, standard matrix variant \\
	{\sf GrB\_assign}           & Assign an input scalar value to each element of a specified subgraph.             & 4.3.11.6, vector constant variant \\
	{\sf GrB\_assign}           & Assign an input scalar value to each element of a specified subgraph.             & 4.3.11.7, matrix constant variant \\
	{\sf GrB\_apply}            & Apply a unary operator to the elements of a matrix.                               & 4.3.12.2, standard matrix variant \\
	{\sf GrB\_reduce}           & Reduce elements across each row of a matrix to produce a vector.                  & 4.3.13.1, matrix to vector variant \\
\end{tabular}
\end{center}
\hrule
\end{table*}
