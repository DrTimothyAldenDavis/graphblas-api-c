\section{GraphBLAS Math}
\label{sec:math}

Consider a graph represented in terms of an adjacency matrix and a second
matrix representing a subset of the vertices in the graph.  The traditional
matrix product over real arithmetic of these two matrices returns the
cost based on the accumulated edge weights of reaching the 
set of vertices connected to the initial vertices.   This fundamental
operation can be used to construct a wide range of graph algorithms.

We can extend the range of graph algorithms by keeping the basic
memory access pattern of a matrix-matrix multiplication, but varying
the operators and the interpretation of the values in the matrices (the \emph{domain}).
By carefully choosing operators and the domain, we maintain the
relations between matrix objects familiar in linear algebra thereby enabling
composable graph algorithms.

We do this using the concept of an algebraic semiring.   A semiring is an algebraic
structure over a domain $D$ with two binary operations $\oplus$ and $\otimes$.
The addition operator, $\oplus$, is a commutative monoid with an identity element $0$
while the multiplication operator, $\otimes$, is a commutative monoid with an 
identity element $1$.  This additive identity is also an annhilator for the multiplication 
operator, $\otimes$ and multiplication distributes with addition.  The most 
common semirings used in the Graph Algorithms community are 
shown in table~\ref{Tab:semirings}.

  
\begin{table}[h]
\hrule
\begin{center}
\caption{Common Semirings used with Graph Algorithms.}
\label{Tab:semirings}
\begin{tabular}{llll}
{\sf Semiring} & \multicolumn{2}{c}{operators} & Domain \\
\hline
Standard Arithmetic         & $\oplus   \equiv + $ & $\otimes \equiv   \times $  & $ \mathbb{R} $\\
max-plus Algebras           & $\oplus   \equiv max $ & $\otimes \equiv  + $  & $  \{-\infty \cup  \mathbb{R} \}$\\
max-min Algebras           & $\oplus   \equiv max $ & $\otimes \equiv  \times $  & $  \infty \cup  \mathbb{R}_{\leq 0}\} $\\
Finite (Galois) Fields (e.g. GF2)      & $\oplus   \equiv xor $ & $\otimes \equiv  and $  & $  \{0, 1\}$\\
Power set Algebras         & $\oplus   \equiv \cup $ & $\otimes \equiv  \cap $  & $  \mathbb{Z} $\\
\end{tabular}
\end{center}
\hrule
\end{table}

It is often convenient to change the semiring applied
to a given matrix.  This means we must represent the matrix and the semiring with distinct objects 
in the GraphBLAS C specification.  Mathematically, the ability to change semirings 
when moving from one GraphBLAS operation to the next impacts the meaning of 
the \emph{implied zero} in a sparse representation of a matrix.
This element in real arithmetic is zero which is the 
identity of the \emph{addition} operator and the annihilator of
\emph{multiplication} operator.   As the semiring changes, this 
\emph{implied} or \emph{structural zero} changes to the identity of 
the \emph{addition} operator and the annihilator of the \emph{multiplication} 
operator for the new semiring.   Nothing changes in the
stored matrix, but the implied values within the sparse matrix change
with respect to a particular operation.  

This greatly complicates the definitions of the operations in the GraphBLAS.   
Consider matrix multiplication over the domain $\mathbb{S}$ where to signify 
flexibility to change to different semirings, we use $\oplus$ and $\otimes$.
 $$
   \mathbf{C} = \mathbf{A} {\oplus}.{\otimes} \mathbf{B} = \mathbf{A} \mathbf{B}
$$
Using index notation familiar in linear algebra
  $$
   {\bf C}_(i,j) = \bigoplus_{k=1}^l {\bf A}_(i,k) \otimes {\bf B}_(k,j)
  $$
for matrices with dimensions
$$
  {\bf A} : \mathbb{S}^{m \times l} ~~~~~
  {\bf B} : \mathbb{S}^{l \times m} ~~~~~
  {\bf C} : \mathbb{S}^{m \times n}
$$
The summation notation only works, however, if we redefine the implied zero of the 
sparse matrices as we change the semiring.   Depending on the domains associated with the
matrix elements and the operations, this can lead to awkward definitions of the
operations involving the structural zeros.  A cleaner approach based on set notation
avoids this problem.  For example, we can define the previous matrix multiplication
as:   
$$
C_{ij}
= \bigoplus_{k \in \bold{ind}(\matrix{\widetilde{A}}(i,:)) \cap
\bold{ind}(\matrix{\widetilde{B}}(:,j))} (\matrix{\widetilde{A}}(i,k)
\otimes \matrix{\widetilde{B}}(k,j)),
$$ 
In other words, the binary operation $\otimes$ is applied to the intersection of the 
two sets $A$ and $B$ the results of which are accumulated using the $\oplus$ operator.
These notations are equivalent but by defining the pairwise operations over
the set intersections, we never have to define how the additive identity defined by one
semiring interacts with the structural zeros defined by a different semiring.

In addition to matrix multiplication, the GraphBLAS math specification defines
a range of additional operations.  These are summarized in table~\ref{Tab:GraphBLASOps}.

\begin{table}[h]
\hrule
\begin{center}
\caption{A Mathematical overview of the fundamental GraphBLAS operations supported
in this specification. $\matrix{A}$, $\matrix{B}$, and $\matrix{C}$ are GraphBLAS matrices, 
$\vector{u}$ and $\vector{v}$ are GraphBLAS vectors, $i$ and $j$ are indices, and $v$ is a scalar 
indicating the value of an element of a GraphBLAS object.  $f()$ is a function.
% and $m$ and $n$ are integers indicating the size of GraphBLAS object dimensions.  
While not shown here, the input 
matrices $\matrix{A}$ and $\matrix{B}$ may be selected for transposition prior to 
the operation and masks can be used to control which values are written to the output GraphBLAS object.}
\label{Tab:GraphBLASOps}
\begin{tabular}{l|rrl}
{\sf Operation Name} & \multicolumn{3}{c}{Mathematical Description}  \\
\hline
{\sf mxm}          & $\matrix{C}$ & $\oplus=$ & $\matrix{A} \oplus.\otimes \matrix{B}$  \\
{\sf mxv}          & $\vector{u}$ & $\oplus=$ & $\matrix{A} \oplus.\otimes \vector{v}$  \\
{\sf vxm}          & $\vector{u}$ & $\oplus=$ & $\vector{v} \oplus.\otimes \matrix{A}$  \\
{\sf eWiseMult}    & $\matrix{C}$ & $\oplus=$ & $\matrix{A} \otimes \matrix{B}$  \\
{\sf eWiseAdd}     & $\matrix{C}$ & $\oplus=$ & $\matrix{A} \oplus  \matrix{B}$  \\
{\sf reduce} (row) & $\vector{u}$ & $\oplus=$ & $\oplus_j\matrix{A}(:,j)$  \\
{\sf apply}        & $\matrix{C}$ & $\oplus=$ & $f(\matrix{A})$ \\
{\sf transpose}    & $\matrix{C}$ & $\oplus=$ & $\matrix{A}$ \\
{\sf extract}      & $\matrix{C}$ & $\oplus=$ & $\matrix{A}(\vector{i},\vector{j})$ \\
{\sf assign}       & $\matrix{C}(\vector{i},\vector{j})$ & $\oplus=$ & $\matrix{A}$ \\
%{\sf buildMatrix}  & $\matrix{C}$ & $\oplus=$ & $\mathbb{S}^{m\times n}(\vector{i},\vector{j},\vector{v},\oplus_{dup})$ \\
%{\sf buildVector}  & $\vector{u}$ & $\oplus=$ & $\mathbb{S}^{n}(\vector{i},\vector{v})$ \\
{\sf extractTuples}& $(\vector{i},\vector{j},\vector{v})$ & $=$ & $\matrix{A}$ \\
\end{tabular}
\end{center}
\hrule
\end{table}

