%-----------------------------------------------------------------------------
%-----------------------------------------------------------------------------

\subsection*{4.3.7 {\sf assign}: Modifying subgraphs}

Assign the contents of a subset of a matrix or vector.

%-----------------------------------------------------------------------------

\subsubsection*{4.3.7.5 {\sf assign}: Constant vector variant}

Assign the same value to a specified subset of vector elements.  With the use of
{\sf GrB\_ALL}, the entire destination vector can be filled with the constant.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Vector            w,
                            const GrB_Vector      mask,
                            const GrB_BinaryOp    accum,
                            <type>                val,
                            const GrB_Index      *indices,
                            GrB_Index             nindices,
                            const GrB_Descriptor  desc);
\end{verbatim}

{\color{red}
\begin{verbatim}
        GrB_Info GrB_assign(GrB_Vector            w,
                            const GrB_Vector      mask,
                            const GrB_BinaryOp    accum,
                            const GrB_Scalar      s,
                            const GrB_Index      *indices,
                            GrB_Index             nindices,
                            const GrB_Descriptor  desc);
\end{verbatim}
}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    assign operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector {\sf w}. The 
    mask dimensions must match those of the vector {\sf w}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the
    {\sf mask} vector must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf w}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf w} entries. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf val}]    ({\sf IN}) Scalar value to assign to (a subset of) {\sf w}.

{\color{red}
    \item[{\sf s}]    ({\sf IN}) Scalar value to assign to (a subset of) {\sf w}.
}

    \item[{\sf indices}]  ({\sf IN}) Pointer to the ordered set (array) of 
    indices corresponding to the locations in {\sf w} that are to be assigned.  
    If all elements of {\sf w} are to be assigned in order from $0$ to 
    ${\sf nindices} - 1$, then {\sf GrB\_ALL} should be specified.  Regardless of 
    execution mode and return value, this array may be manipulated by the caller
    after this operation returns without affecting any deferred computations for 
    this operation.  
    In this variant, the specific order of the values in the
    array has no effect on the result.  Unlike other variants, if there are 
    duplicated values in this array the result is still defined.
    
    \item[{\sf nindices}] ({\sf IN}) The number of values in {\sf indices} array.
    Must be in the range: $[0, \bold{size}({\sf w})]$.  If {\sf nindices}
    is zero, the operation becomes a NO-OP.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf mask} vector. The stored values are not examined.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the 
        complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf indices} is greater
    than or equal to $\bold{size}({\sf w})$.  In non-blocking mode, this can be
    reported as an execution error.

    \item[{\sf GrB\_DIMENSION\_MISMATCH}] {\sf mask} and {\sf w} dimensions are
    incompatible, or {\sf nindices} is not less than $\bold{size}({\sf w})$. 

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the vector and scalar are
    incompatible with each other or the corresponding domains of the
    accumulation operator, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).

    \item[{\sf GrB\_NULL\_POINTER}] Argument {\sf indices} is a {\sf NULL} pointer.
\end{itemize}

\paragraph{Description}

{\color{red}
This variant of {\sf GrB\_assign} computes the result of assigning a constant
scalar value -- either {\sf val} or {\sf s} -- to locations in a destination GraphBLAS vector.
Either 
${\sf w}({\sf indices}) = {\sf val}$ or ${\sf w}({\sf indices}) = {\sf s}$ is performed.
If an optional binary accumulation 
operator ($\odot$) is provided, then either
${\sf w}({\sf indices}) = {\sf w}({\sf indices}) \odot {\sf val}$ or
${\sf w}({\sf indices}) = {\sf w}({\sf indices}) \odot {\sf s}$ is performed.  
More explicitly, if a non-opaque value {\sf val} is provided:
\[
\begin{aligned}
    {\sf w}({\sf indices}[i]) = &\ {\sf val}, \ 
    \forall \  i : 0 \leq i < {\sf nindices}, \mbox{~~or~~}
    \\
    {\sf w}({\sf indices}[i]) = &\ {\sf w}({\sf indices}[i]) \odot {\sf val}, \ 
    \forall \  i : 0 \leq i < {\sf nindices}.
\end{aligned}
\]
Correspondingly, if a {\sf GrB\_Scalar} {\sf s} is provided:
\[
\begin{aligned}
    {\sf w}({\sf indices}[i]) = &\ {\sf s}, \ 
    \forall \  i : 0 \leq i < {\sf nindices}, \mbox{~~or~~}
    \\
    {\sf w}({\sf indices}[i]) = &\ {\sf w}({\sf indices}[i]) \odot {\sf s}, \ 
    \forall \  i : 0 \leq i < {\sf nindices}.
\end{aligned}
\]
}
Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[\bf Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to two argument vectors are used in the {\sf GrB\_assign} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),
    \bold{L}({\sf w}) = \{(i,w_i) \} \rangle$

	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),
    \bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)
\end{enumerate}

The argument scalar, vectors, and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
	\item If {\sf mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

{\color{red}
	\item $\bold{D}({\sf w})$ must be 
    compatible with either $\bold{D}({\sf val})$ or $\bold{D}({\sf val})$, depending
	on the signature of the method.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator.
	
\item If {\sf accum} is not {\sf GrB\_NULL}, then  
    either $\bold{D}({\sf val})$ or $\bold{D}({\sf s})$, depending on the signature of the method, must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.
}
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends
and the domain mismatch error listed above is returned.

From the arguments, the internal vectors, mask and index array used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \ \forall \ i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item If {\sf mask} $\ne$ {\sf GrB\_NULL},  
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then
            $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \} \rangle$,
            \item Otherwise, $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \wedge
            ({\sf bool}){\sf mask}(i) = \true \} \rangle$.
        \end{enumerate}

		\item	If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

    \item The internal index array, $\grbarray{\widetilde{I}}$, is computed from 
    argument {\sf indices} as follows:
	\begin{enumerate}
		\item	If ${\sf indices} = {\sf GrB\_ALL}$, then 
        $\grbarray{\widetilde{I}}[i] = i, \ \forall \ i : 0 \leq i < {\sf nindices}$.

		\item	Otherwise, $\grbarray{\widetilde{I}}[i] = {\sf indices}[i], 
        \ \forall \ i : 0 \leq i < {\sf nindices}$.
    \end{enumerate}
\end{enumerate}

The internal vector and mask are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
    \item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$
    \item $0 \leq {\sf nindices} \leq \bold{size}(\vector{\widetilde{w}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the assign and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
{\color{red}
    \item $\vector{\widetilde{t}}$: The vector holding the copies of the scalar, either 
	{\sf val} or {\sf s}, in their destination locations relative to 
    $\vector{\widetilde{w}}$.
}

    \item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

{\color{red}
The intermediate vector, $\vector{\widetilde{t}}$, is created as follows. If a non-opaque value {\sf val} is provided:
\[
\vector{\widetilde{t}} = \langle
\bold{D}({\sf val}), \bold{size}(\vector{\widetilde{w}}),
%\bold{L}(\vector{\widetilde{t}}) =
\{(\grbarray{\widetilde{I}}[i],{\sf val})\ \forall \ i,\ 0 \leq i < {\sf nindices} \} \rangle. 
\]
Correspondingly, if a non-empty {\sf GrB\_Scalar} {\sf s} is provided ($\mathbf{size}({\sf s}) = 1$):
\[
\vector{\widetilde{t}} = \langle
\bold{D}({\sf s}), \bold{size}(\vector{\widetilde{w}}),
%\bold{L}(\vector{\widetilde{t}}) =
\{(\grbarray{\widetilde{I}}[i],\mathbf{val}({\sf s}))\ \forall \ i,\ 0 \leq i < {\sf nindices} \} \rangle. 
\]
Finally, if an empty {\sf GrB\_Scalar} {\sf s} is provided ($\mathbf{size}({\sf s}) = 0$):
\[
\vector{\widetilde{t}} = \langle
\bold{D}({\sf s}), \bold{size}(\vector{\widetilde{w}}),
%\bold{L}(\vector{\widetilde{t}}) =
\emptyset \rangle. 
\]
}
If $\grbarray{\widetilde{I}}$ is empty, this operation results in an empty 
vector, $\vector{\widetilde{t}}$.  Otherwise, if any value in the 
$\grbarray{\widetilde{I}}$ array is not in the range 
$[0,\ \bold{size}(\vector{\widetilde{w}}) )$, the execution of {\sf GrB\_assign} 
ends and the index out-of-bounds error listed above is generated. In 
{\sf GrB\_NONBLOCKING} mode, the error can be deferred until a 
sequence-terminating {\sf GrB\_wait()} is called.  Regardless, the result 
vector, {\sf w}, is invalid from this point forward in the 
sequence.

The intermediate vector $\vector{\widetilde{z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\vector{\widetilde{z}}$ is defined as 
    \[ 
        \vector{\widetilde{z}} =
		\langle \bold{D}({\sf w}), \bold{size}(\vector{\widetilde{w}}), 
		\{(i,z_{i}), \forall i \in (\bold{ind}(\vector{\widetilde{w}})-(\{\grbarray{\widetilde{I}}[k],\forall k\} \cap \bold{ind}(\vector{\widetilde{w}}))) \cup 
        \bold{ind}(\vector{\widetilde{t}}) \} \rangle.
    \]
    The above expression defines the structure of vector $\vector{\widetilde{z}}$ as follows:
    We start with the structure of $\vector{\widetilde{w}}$ ($\bold{ind}(\vector{\widetilde{w}})$) and remove from 
    it all the indices of $\vector{\widetilde{w}}$ that are
    in the set of indices being assigned ($\{\grbarray{\widetilde{I}}[k],\forall k\} \cap \bold{ind}(\vector{\widetilde{w}})$). Finally, we
    add the structure of $\vector{\widetilde{t}}$ ($\bold{ind}(\vector{\widetilde{t}})$).

    The values of the elements of $\vector{\widetilde{z}}$ are computed based on the 
    relationships between the sets of indices in $\vector{\widetilde{w}}$ 
    and $\vector{\widetilde{t}}$.
    \[
        z_{i} = \vector{\widetilde{w}}(i), \ \mbox{if}\  i \in  
        (\bold{ind}(\vector{\widetilde{w}}) - (\{\grbarray{\widetilde{I}}[k],\forall k\}
        \cap \bold{ind}(\vector{\widetilde{w}}))),
    \]
    \[
        z_{i} = \vector{\widetilde{t}}(i), \ \mbox{if}\  i \in  
        \bold{ind}(\vector{\widetilde{t}}),
    \]
    where the difference operator refers to set difference.
    We note that in this case of assigning a constant, 
    $\{\grbarray{\widetilde{I}}[k],\forall k\}$ 
    and $\bold{ind}(\vector{\widetilde{t}})$ are identical.

    \item If ${\sf accum}$ is a binary operator, then $\vector{\widetilde{z}}$ is defined as
        \[ \langle \bDout({\sf accum}), \bold{size}(\vector{\widetilde{w}}),
        %\bold{L}(\vector{\widetilde{z}}) =
        \{(i,z_{i}) \ \forall \ i \in \bold{ind}(\vector{\widetilde{w}}) \cup 
        \bold{ind}(\vector{\widetilde{t}}) \} \rangle.\]

    The values of the elements of $\vector{\widetilde{z}}$ are computed based on the 
    relationships between the sets of indices in $\vector{\widetilde{w}}$ and 
    $\vector{\widetilde{t}}$.
\[
    z_{i} = \vector{\widetilde{w}}(i) \odot \vector{\widetilde{t}}(i), \ \mbox{if}\  
    i \in  (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}})),
\]
\[
    z_{i} = \vector{\widetilde{w}}(i), \ \mbox{if}\  
    i \in (\bold{ind}(\vector{\widetilde{w}}) - (\bold{ind}(\vector{\widetilde{t}})
    \cap \bold{ind}(\vector{\widetilde{w}}))),
\]
\[
    z_{i} = \vector{\widetilde{t}}(i), \ \mbox{if}\  i \in  
    (\bold{ind}(\vector{\widetilde{t}}) - (\bold{ind}(\vector{\widetilde{t}})
    \cap \bold{ind}(\vector{\widetilde{w}}))),
\]
where $\odot  = \bigodot({\sf accum})$, and the difference operator refers to set difference.
\end{itemize}

\input{ops_mask_replace_vector}


%-----------------------------------------------------------------------------

\subsubsection*{4.3.7.6 {\sf assign}: Constant matrix variant}

Assign the same value to a specified subset of matrix elements.  With the use of 
{\sf GrB\_ALL}, the entire destination matrix can be filled with the constant.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Matrix            C,
                            const GrB_Matrix      Mask,
                            const GrB_BinaryOp    accum,
                            <type>                val,
                            const GrB_Index      *row_indices,
                            GrB_Index             nrows,
                            const GrB_Index      *col_indices,
                            GrB_Index             ncols,
                            const GrB_Descriptor  desc);
\end{verbatim}

{\color{red}
\begin{verbatim}
        GrB_Info GrB_assign(GrB_Matrix            C,
                            const GrB_Matrix      Mask,
                            const GrB_BinaryOp    accum,
                            const GrB_Scalar      s,
                            const GrB_Index      *row_indices,
                            GrB_Index             nrows,
                            const GrB_Index      *col_indices,
                            GrB_Index             ncols,
                            const GrB_Descriptor  desc);
\end{verbatim}
}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS matrix. On input,
    the matrix provides values that may be accumulated with the result of the
    assign operation.  On output, the matrix holds the results of the
    operation.

    \item[{\sf Mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix {\sf C}. The 
    mask dimensions must match those of the matrix {\sf C}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the 
    {\sf Mask} matrix must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf C}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf C} entries.
    If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf val}]    ({\sf IN}) Scalar value to assign to (a subset of) {\sf C}.
    
{\color{red}
    \item[{\sf s}]    ({\sf IN}) Scalar value to assign to (a subset of) {\sf C}.
}

    \item[{\sf row\_indices}] ({\sf IN}) Pointer to the ordered set (array) of 
    indices corresponding to the rows of {\sf C} that are assigned.  If all rows
    of {\sf C} are to be assigned in order from $0$ to ${\sf nrows} - 1$, then 
    {\sf GrB\_ALL} can be specified.  Regardless of execution mode and return 
    value, this array may be manipulated by the caller after this operation 
    returns without affecting any deferred computations for this operation.  
    Unlike other variants, if there are duplicated values in this array the 
    result is still defined.

    \item[{\sf nrows}] ({\sf IN}) The number of values in {\sf row\_indices}
    array. Must be in the range: $[0, \bold{nrows}({\sf C})]$.  If
    {\sf nrows} is zero, the operation becomes a NO-OP.

    \item[{\sf col\_indices}] ({\sf IN}) Pointer to the ordered set (array) of 
    indices corresponding to the columns of {\sf C} that are assigned.  If all 
    columns of {\sf C} are to be assigned in order from $0$ to ${\sf ncols} - 1$, 
    then {\sf GrB\_ALL} should be specified.  Regardless of execution mode and return
    value, this array may be manipulated by the caller after this operation 
    returns without affecting any deferred computations for this operation.
    Unlike other variants, if there are duplicated values in this array the 
    result is still defined.

    \item[{\sf ncols}] ({\sf IN}) The number of values in {\sf col\_indices}
    array. Must be in the range: $[0, \bold{ncols}({\sf C})]$.  If
    {\sf ncols} is zero, the operation becomes a NO-OP.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf Mask} matrix. The stored values are not examined.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the 
        complement of {\sf Mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output matrix {\sf C} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for the operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf row\_indices} 
    is greater than or equal to $\bold{nrows}({\sf C})$, or a value in 
    {\sf col\_indices} is greater than or equal to $\bold{ncols}({\sf C})$.  In 
    non-blocking mode, this can be reported as an execution error.

    \item[{\sf GrB\_DIMENSION\_MISMATCH}] {\sf Mask} and {\sf C}
    dimensions are incompatible, {\sf nrows} is not less than $\bold{nrows}({\sf C})$, or
    {\sf ncols} is not less than $\bold{ncols}({\sf C})$. 

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the matrix and scalar are
    incompatible with each other or the corresponding domains of the 
    accumulation operator, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).

    \item[{\sf GrB\_NULL\_POINTER}] Either argument {\sf row\_indices} is a {\sf NULL} pointer,
	argument {\sf col\_indices} is a {\sf NULL} pointer, or both.
\end{itemize}

\paragraph{Description}

{\color{red}
This variant of {\sf GrB\_assign} computes the result of assigning a constant
scalar value -- either {\sf val} or {\sf s} -- to locations in a destination GraphBLAS matrix: 
Either
${\sf C}({\sf row\_indices, col\_indices}) = {\sf val}$ or ${\sf C}({\sf row\_indices, col\_indices}) = {\sf s}$ is performed.
If an optional binary accumulation operator ($\odot$) is provided, then either
${\sf C}({\sf row\_indices, col\_indices}) = {\sf C}({\sf row\_indices, col\_indices}) \odot {\sf val}$ or
${\sf C}({\sf row\_indices, col\_indices}) = {\sf C}({\sf row\_indices, col\_indices}) \odot {\sf s}$ is performed.
More explicitly, if a non-opaque value {\sf val} is provided:
\[
\begin{aligned}
	{\sf C}({\sf row\_indices}[i],{\sf col\_indices}[j]) =\ & {\sf val} \mbox{,~or~} \\
    {\sf C}({\sf row\_indices}[i],{\sf col\_indices}[j]) =\ & 
    {\sf C}({\sf row\_indices}[i],{\sf col\_indices}[j]) \odot {\sf val} \\
    & \ \forall \ (i,j) \ : \ 0 \leq i < {\sf nrows},\ 0 \leq j < {\sf ncols}
\end{aligned}
\]  
Correspondingly, if a {\sf GrB\_Scalar} {\sf s} is provided:
\[
\begin{aligned}
	{\sf C}({\sf row\_indices}[i],{\sf col\_indices}[j]) =\ & {\sf s} \mbox{,~or~} \\
    {\sf C}({\sf row\_indices}[i],{\sf col\_indices}[j]) =\ & 
    {\sf C}({\sf row\_indices}[i],{\sf col\_indices}[j]) \odot {\sf s} \\
    & \ \forall \ (i,j) \ : \ 0 \leq i < {\sf nrows},\ 0 \leq j < {\sf ncols}
\end{aligned}
\]
}
Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.85in]
\item[Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[Compute] The indicated computations are carried out.
\item[Output] The result is written into the output matrix, possibly under 
control of a mask.
\end{enumerate}

Up to two argument matrices are used in the {\sf GrB\_assign} operation:
\begin{enumerate}
	\item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),
    \bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$

	\item ${\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}({\sf Mask}),
    \bold{ncols}({\sf Mask}),\bold{L}({\sf Mask}) = \{(i,j,M_{ij}) \} \rangle$ (optional)
\end{enumerate}

The argument scalar, matrices, and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
	\item If {\sf Mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf Mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

{\color{red}
	\item $\bold{D}({\sf C})$ must be 
    compatible with either $\bold{D}({\sf val})$ or $\bold{D}({\sf val})$, depending
	on the signature of the method.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator.
	
\item If {\sf accum} is not {\sf GrB\_NULL}, then  
    either $\bold{D}({\sf val})$ or $\bold{D}({\sf s})$, depending on the signature of the method, must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.
}
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends
and the domain mismatch error listed above is returned.

From the arguments, the internal matrices, index arrays, and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

	\item Two-dimensional mask $\matrix{\widetilde{M}}$ is computed from
    argument {\sf Mask} as follows:
	\begin{enumerate}
		\item If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{M}} = 
        \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), 
        \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < 
        \bold{ncols}({\sf C}) \} \rangle$.

		\item If {\sf Mask} $\ne$ {\sf GrB\_NULL},
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then 
            $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
            \bold{ncols}({\sf Mask}), \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \} \rangle$,
            \item Otherwise, $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
            \bold{ncols}({\sf Mask}), \\ \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \wedge 
            ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.
        \end{enumerate}

		\item	If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\matrix{\widetilde{M}} \leftarrow \neg \matrix{\widetilde{M}}$.
	\end{enumerate}

    \item The internal row index array, $\grbarray{\widetilde{I}}$, is computed from 
    argument {\sf row\_indices} as follows:
	\begin{enumerate}
		\item	If ${\sf row\_indices} = {\sf GrB\_ALL}$, then 
        $\grbarray{\widetilde{I}}[i] = i, \forall i : 0 \leq i < {\sf nrows}$.

		\item	Otherwise, $\grbarray{\widetilde{I}}[i] = {\sf row\_indices}[i], 
        \forall i : 0 \leq i < {\sf nrows}$.
    \end{enumerate}
    
    \item The internal column index array, $\grbarray{\widetilde{J}}$, is computed from 
    argument {\sf col\_indices} as follows:
	\begin{enumerate}
		\item	If ${\sf col\_indices} = {\sf GrB\_ALL}$, then 
        $\grbarray{\widetilde{J}}[j] = j, \forall j : 0 \leq j < {\sf ncols}$.

		\item	Otherwise, $\grbarray{\widetilde{J}}[j] = {\sf col\_indices}[j], 
        \forall j : 0 \leq j < {\sf ncols}$.
    \end{enumerate}
\end{enumerate}

The internal matrix and mask are checked for dimension compatibility. The following
conditions must hold:
\begin{enumerate}
    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{M}})$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{M}})$.

    \item $0 \leq {\sf nrows} \leq \bold{nrows}(\matrix{\widetilde{C}})$.

    \item $0 \leq {\sf ncols} \leq \bold{ncols}(\matrix{\widetilde{C}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the assign and any additional 
associated operations.  We describe this in terms of two intermediate matrices:
\begin{itemize}
{\color{red}
    \item $\matrix{\widetilde{T}}$: The matrix holding the copies of the scalar, either 
	{\sf val} or {\sf s}, in their destination locations relative to 
    $\matrix{\widetilde{C}}$.
}

    \item $\matrix{\widetilde{Z}}$: The matrix holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

{\color{red}
The intermediate matrix, $\matrix{\widetilde{T}}$, is created as follows. If a non-opaque value {\sf val} is provided:
\[
\begin{aligned}
\matrix{\widetilde{T}} = \langle & \bold{D}({\sf val}),
                           \bold{nrows}(\matrix{\widetilde{C}}), 
                           \bold{ncols}(\matrix{\widetilde{C}}), \\
 & \{ (\grbarray{\widetilde{I}}[i],\grbarray{\widetilde{J}}[j], {\sf val})
\ \forall \ (i,j), \ 0 \leq i < {\sf nrows}, \ 0 \leq j < {\sf ncols} \} \rangle. 
\end{aligned}
\]
Correspondingly, if a non-empty {\sf GrB\_Scalar} {\sf s} is provided ($\mathbf{size}({\sf s}) = 1$):
\[
\begin{aligned}
\matrix{\widetilde{T}} = \langle & \bold{D}({\sf s}),
                           \bold{nrows}(\matrix{\widetilde{C}}), 
                           \bold{ncols}(\matrix{\widetilde{C}}), \\
    & \{ (\grbarray{\widetilde{I}}[i],\grbarray{\widetilde{J}}[j], \mathbf{val}({\sf s}))
\ \forall \ (i,j), \ 0 \leq i < {\sf nrows}, \ 0 \leq j < {\sf ncols} \} \rangle. 
\end{aligned}
\]
Finally, if an empty {\sf GrB\_Scalar} {\sf s} is provided ($\mathbf{size}({\sf s}) = 0$):
\[
\begin{aligned}
\matrix{\widetilde{T}} = \langle & \bold{D}({\sf s}),
                           \bold{nrows}(\matrix{\widetilde{C}}), 
                           \bold{ncols}(\matrix{\widetilde{C}}), \emptyset \rangle. 
\end{aligned}
\]
}
If either $\grbarray{\widetilde{I}}$ or $\grbarray{\widetilde{J}}$ is empty, this 
operation results in an empty matrix, $\matrix{\widetilde{T}}$.  Otherwise, if 
any value in the $\grbarray{\widetilde{I}}$ array is not in
the range $[0,\ \bold{nrows}(\matrix{\widetilde{C}}) )$ or any value in the 
$\grbarray{\widetilde{J}}$ array is not in the range 
$[0,\ \bold{ncols}(\matrix{\widetilde{C}}))$, the execution of {\sf GrB\_assign} 
ends and the index out-of-bounds error listed above is generated.  In 
{\sf GrB\_NONBLOCKING} mode, the error can be deferred until a 
sequence-terminating {\sf GrB\_wait()} is called.  Regardless, the result 
matrix {\sf C} is invalid from this point forward in the sequence.

The intermediate matrix $\matrix{\widetilde{Z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{Z}}$ is defined as 
    \begin{eqnarray}
        \matrix{\widetilde{Z}} & = &
		\langle \bold{D}({\sf C}),\bold{nrows}(\matrix{\widetilde{C}}),
        \bold{ncols}(\matrix{\widetilde{C}}), \nonumber \\
    & & \{(i,j,Z_{ij})  \forall (i,j) \in
        (\bold{ind}(\matrix{\widetilde{C}}) - (\{
            (\grbarray{\widetilde{I}}[k],\grbarray{\widetilde{J}}[l]),
            \forall k,l\} \cap \bold{ind}(\matrix{\widetilde{C}}))) \cup
        \bold{ind}(\matrix{\widetilde{T}}) \} \rangle. \nonumber
    \end{eqnarray}
    The above expression defines the structure of matrix $\matrix{\widetilde{Z}}$ as follows:
    We start with the structure of $\matrix{\widetilde{C}}$ ($\bold{ind}(\matrix{\widetilde{C}})$) and remove from 
    it all the indices of $\matrix{\widetilde{C}}$ that are
    in the set of indices being assigned ($\{(\grbarray{\widetilde{I}}[k],\grbarray{\widetilde{J}}[l]),\forall k,l\} \cap \bold{ind}(\matrix{\widetilde{C}})$). Finally, we
    add the structure of $\matrix{\widetilde{T}}$ ($\bold{ind}(\matrix{\widetilde{T}})$).

    The values of the elements of $\matrix{\widetilde{Z}}$ are computed based on the 
    relationships between the sets of indices in $\matrix{\widetilde{C}}$ and 
    $\matrix{\widetilde{T}}$.
\[
    Z_{ij} = \matrix{\widetilde{C}}(i,j), \mbox{~if~}  (i,j) \in  
    (\bold{ind}(\matrix{\widetilde{C}}) - (\{ (\grbarray{\widetilde{I}}[k],\grbarray{\widetilde{J}}[l]), \forall k, l\}
    \cap \bold{ind}(\matrix{\widetilde{C}}))),
\]
\[
    Z_{ij} = \matrix{\widetilde{T}}(i,j), \ \mbox{if}\ (i,j) \in  
    \bold{ind}(\matrix{\widetilde{T}}),
\]
where the difference operator refers to set difference.
We note that, in this particular case of assigning a constant to a matrix, the sets
$\{ (\grbarray{\widetilde{I}}[k],\grbarray{\widetilde{J}}[l]), \forall k, l\}$ and
$\bold{ind}(\matrix{\widetilde{T}})$ are identical.

    \item If ${\sf accum}$ is a binary operator, then $\matrix{\widetilde{Z}}$ is defined as
        \[ \langle \bDout({\sf accum}), \bold{nrows}(\matrix{\widetilde{C}}), \bold{ncols}(\matrix{\widetilde{C}}),
        %\bold{L}(\matrix{\widetilde{Z}}) =
        \{(i,j,Z_{ij})  \forall (i,j) \in \bold{ind}(\matrix{\widetilde{C}}) \cup 
        \bold{ind}(\matrix{\widetilde{T}}) \} \rangle.\]

    The values of the elements of $\matrix{\widetilde{Z}}$ are computed based on the
    relationships between the sets of indices in $\matrix{\widetilde{C}}$ and 
    $\matrix{\widetilde{T}}$.
\[
    Z_{ij} = \matrix{\widetilde{C}}(i,j) \odot \matrix{\widetilde{T}}(i,j), \ \mbox{if}\  
    (i,j) \in  (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}})),
\]
\[
    Z_{ij} = \matrix{\widetilde{C}}(i,j), \ \mbox{if}\  
    (i,j) \in (\bold{ind}(\matrix{\widetilde{C}}) - (\bold{ind}(\matrix{\widetilde{T}})
    \cap \bold{ind}(\matrix{\widetilde{C}}))),
\]
\[
    Z_{ij} = \matrix{\widetilde{T}}(i,j), \ \mbox{if}\  (i,j) \in  
    (\bold{ind}(\matrix{\widetilde{T}}) - (\bold{ind}(\matrix{\widetilde{T}})
    \cap \bold{ind}(\matrix{\widetilde{C}}))),
\]
where $\odot  = \bigodot({\sf accum})$, and the difference operator refers to set difference.
\end{itemize}

\input{ops_mask_replace_matrix}
