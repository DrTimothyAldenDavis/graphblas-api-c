\chapter*{2. Basic Concepts}

\section*{2.1 Glossary}

\subsection*{2.1.3 Algebraic structures used in the GraphBLAS}

\glossBegin
\glossItem{GraphBLAS operators} \scott{Add something about \emph{index unary operators} here.}
\glossEnd

\section*{2.6 Operators and Associated Functions}

GraphBLAS operators act on elements of GraphBLAS objects. A \emph{binary
operator} is a function that maps two input values to one output value. A
\emph{unary operator} is a function that maps one input value to one
output value. The value of the output is determined by the value of
the input(s).  Binary operators are defined over two input domains
and produce an output from a (possibly different) third domain. Unary
operators are specified over one input domain and produce an output from a
(possibly different) second domain.

{\color{red}
In addition, to the operators above that operate on stored values, GraphBLAS
also supports an \emph{index unary operator} that maps one
stored value and the indices of its position in the matrix or vect to an output value.
That output value can be used in the index unary operator variants of apply to compute a
new stored value, or be used in the select operation to determine if the
stored input value should be kept or annihilated.
}


\begin{landscape}
\begin{table}[h]
\hspace{-1.5em}\begin{threeparttable}
\hrule
\vspace{1\baselineskip}
\caption*{Table 2.x: Predefined index unary operators for GraphBLAS in C.  The $T$ can 
be any suffix from Table~\ref{Tab:PredefinedDomains}, $\mathbb{I}$ refers to the unsigned 
{\sf GrB\_Index} type, $\mathbb{Z}$ refers to any integer type (signed or unsigned).  
The parameters, $u_i$ or $A_{ij}$, are the stored values from the containers; $i$ 
and $j$ are the row and column indices corresponding to the location of the store value;
and $s$ is an additional scalar value used in the operator. Some operators can be used with both
{\sf GrB\_Vector} and {\sf GrB\_Matrix} (marked with *), but those requiring access to the second index
only work with {\sf GrB\_Matrix} and will result in undefined behavior if used with
{\sf GrB\_Vector}.}
\vspace{1\baselineskip}

\begin{tabular}{l|l|l|rcll}
Operator & GraphBLAS             &                                                              & \\
type     & identifier            & Domains                                              & Description \\ \hline
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_ROWINDEX\_$T$}*  & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow T$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(i + s)$, & replace with its row index (plus s) \\
                     &                            & $T \times \mathbb{I}^1 \times \mathbb{Z} \rightarrow T$ & $f(u_{i},[i],1,s)$ & $=$ & $(i + s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_COLINDEX\_$T$}   & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow T$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j + s)$, & replace with its column index (plus s) \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_DIAGINDEX\_$T$}  & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow T$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(i - j + s)$, & replace with its diagonal index (plus s) \\ \hline
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_TRIL\_$T$}       & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j < i + s)$, & lower triangle below diagonal s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_TRIU\_$T$}       & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j > i + s)$, & upper triangle above diagonal s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_DIAG\_$T$}       & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j == i + s)$, & diagonal s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_OFFDIAG\_$T$}    & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j \neq i + s)$, & all but diagonal s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_COLLE\_$T$}      & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j \leq s)$, & columns less or equal to s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_COLGT\_$T$}      & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j > s)$, & columns greater than s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_ROWLT\_$T$}*     & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(i < s)$, & rows less or equal to s \\
                     &                            & $T \times \mathbb{I}^1 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(u_{i},[i],1,s)$ & $=$ & $(i < s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_ROWGE\_$T$}*     & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(i \geq s)$, & rows greater than s \\
                     &                            & $T \times \mathbb{I}^1 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(u_{i},[i],1,s)$ & $=$ & $(i \geq s)$ \\ \hline
                     
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_SELECTEQ\_$T$}*  & $T \times \mathbb{I}^2 \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} == s)$, & elements with value s \\
                     &                            & $T \times \mathbb{I}^1 \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} == s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_SELECTNE\_$T$}*  & $T \times \mathbb{I}^2 \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} \neq s)$, & elements without value s \\
                     &                            & $T \times \mathbb{I}^1 \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} \neq s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_SELECTLT\_$T$}*  & $T \times \mathbb{I}^2 \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} < s)$, & elements less than value s \\
                     &                            & $T \times \mathbb{I}^1 \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} < s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_SELECTLE\_$T$}*  & $T \times \mathbb{I}^2 \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} \leq s)$, & elements less or equal to value s \\
                     &                            & $T \times \mathbb{I}^1 \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} \leq s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_SELECTGT\_$T$}*  & $T \times \mathbb{I}^2 \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} > s)$, & elements greater than value s \\
                     &                            & $T \times \mathbb{I}^1 \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} > s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_SELECTGE\_$T$}*  & $T \times \mathbb{I}^2 \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} \geq s)$, & elements greater or equal to value s \\
                     &                            & $T \times \mathbb{I}^1 \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} \geq s)$ \\
\end{tabular}
\hrule
\end{threeparttable}
\end{table}

\end{landscape}

%-----------------------------------------------------------------------------

\chapter*{4. Methods}
\section*{4.2 Object Methods}
\subsection*{4.2.1 Algebra Methods}
%-----------------------------------------------------------------------------

\subsubsection*{4.2.1.6 {\sf IndexUnaryOp\_new}: Create a new GraphBLAS index unary operator}

Initializes a new GraphBLAS index unary operator with a specified user-defined 
function and its types (domains).

\paragraph{\syntax}

\begin{verbatim}
    GrB_Info GrB_IndexUnaryOp_new(GrB_IndexUnaryOp   *index_unary_op,
                                  void (*index_unary_func)(void*,
                                                           const void*,
                                                           GrB_Index*,
                                                           GrB_Index,
                                                           const void*),
                                  GrB_Type            d_out,
                                  GrB_Type            d_in1,
                                  GrB_Type            d_in2);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.2in]
    \item[{\sf index\_unary\_op}] ({\sf INOUT}) On successful return, contains a 
          handle to the newly created GraphBLAS index unary operator object.
    \item[{\sf index\_unary\_func}] ({\sf IN}) A pointer to a user-defined 
          function that takes input parameters of types {\sf d\_in1}, 
          {\sf GrB\_Index} pointer, {\sf GrB\_Index} and {\sf d\_in2}
          and returns a value of type {\sf d\_out}.  Except for the {\sf GrB\_Index}
          parameters, all are passed as {\sf void} pointers.
          Specifically the signature of the function is expected to 
          be of the form:
      \begin{verbatim}
      void func(void *out,
                const void *in1, GrB_index* indices, GrB_Index n, 
                const void *in2);
      \end{verbatim}
    \item[{\sf d\_out}]  ({\sf IN}) The {\sf GrB\_Type} of the return
          value of the index unary operator being created. Should be one of the
          predefined GraphBLAS types in Table~\ref{Tab:PredefinedTypes}, or a 
          user-defined GraphBLAS type.
    \item[{\sf d\_in1}]  ({\sf IN}) The {\sf GrB\_Type} of the first input 
          argument of the index unary operator being created and corresponds to
          the stored values of the {\sf GrB\_Vector} or {\sf GrB\_Matrix} being
          operated on. Should be one of the predefined GraphBLAS types in
          Table~\ref{Tab:PredefinedTypes}, or a user-defined GraphBLAS type.
    \item[{\sf d\_in2}]  ({\sf IN}) The {\sf GrB\_Type} of the last input
          argument of the index unary operator being created and corresponds to
          a scalar provided by the GraphBLAS operation that uses this operator.
          Should be one of the predefined GraphBLAS types in 
          Table~\ref{Tab:PredefinedTypes}, or a user-defined GraphBLAS type.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]           operation completed successfully.
\item[{\sf GrB\_PANIC}]             unknown internal error.
\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          the {\sf GrB\_Type} (for user-defined types)
                                    has not been initialized by a call to {\sf GrB\_Type\_new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf index\_unary\_op} or {\sf index\_unary\_func} pointer is {\sf NULL}.

\jose{Domain mistmatch not possible.}
%\item[{\sf GrB\_DOMAIN\_MISMATCH}]  the types in the function pointer signature are not   
%                                    compatible with the {\sf GrB\_Type} parameters specified.
\end{itemize}

\paragraph{Description}

The {\sf IndexUnaryOp\_new} methods creates a new GraphBLAS index unary operator
\begin{quote}
$f_{iu} = \langle \mathbf{D}({\sf d\_out}), \mathbf{D}({\sf d\_in1}), \mathbf{D}({\sf GrB\_Index}^n), \mathbf{D}({\sf GrB\_Index}), \mathbf{D}({\sf d\_in2}), {\sf index\_unary\_func} \rangle$
\end{quote}
and returns a handle to it in {\sf index\_unary\_op}.

The implementation of {\sf index\_unary\_func} must be such that it works
even if any of the {\sf d\_out}, {\sf d\_in1}, and {\sf d\_in2} arguments are aliased to each other.
In other words, for all invocations of the function:
\begin{quote}
\begin{verbatim}
index_unary_func(out,in1,&indices,n,in2);
\end{verbatim}
\end{quote}
the value of {\sf out} must be the same as if the following code
was executed:

\begin{quote}
\begin{code}
    $\mathbf{D}({\sf d\_in1})$ tmp1 = malloc(sizeof($\mathbf{D}({\sf d\_in1}$))); \\
    $\mathbf{D}({\sf d\_in2})$ tmp2 = malloc(sizeof($\mathbf{D}({\sf d\_in2}$))); \\
    memcpy(tmp1,in1,sizeof($\mathbf{D}({\sf d\_in1}$))); \\
    memcpy(tmp2,in2,sizeof($\mathbf{D}({\sf d\_in2}$))); \\
    index\_unary\_func(out,tmp1,\&indices,n,tmp2); \\
    free(tmp2); \\
    free(tmp1);
\end{code}
\end{quote}

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created object will be overwritten. 

%-----------------------------------------------------------------------------

\section*{4.3 GraphBLAS Operations}

\begin{table}[h]
\caption{Potential additions to Table~4.1.}
\hrule
\begin{center}
\newcommand{\odotsp}{\hspace{-0.2cm}\odot\hspace{-0.18cm}}
\begin{tabular}{l|rcrcl}
{\sf Operation Name} & \multicolumn{5}{c}{Mathematical Notation}  \\
\hline
{\sf apply(indexop)}     & $\matrix{C}\langle\matrix{M},z\rangle$ & $=$ & $\matrix{C}$ & $\odotsp$ & $f_{iu}(\matrix{A},\mathbf{ind}(\matrix{A}),s)$ \\
                   & $\vector{w}\langle\matrix{m},z\rangle$ & $=$ & $\vector{w}$ & $\odotsp$ & $f_{iu}(\vector{u},\mathbf{ind}(\vector{u}),s)$  \\
{\sf select  }     & $\matrix{C}\langle\matrix{M},z\rangle$ & $=$ & $\matrix{C}$ & $\odotsp$ & $\matrix{A}\langle f_{iu}(\matrix{A},\mathbf{ind}(\matrix{A}),s)\rangle$ \\
                   & $\vector{w}\langle\matrix{m},z\rangle$ & $=$ & $\vector{w}$ & $\odotsp$ & $\vector{u}\langle f_{iu}(\vector{u},\mathbf{ind}(\vector{u}),s)\rangle$  \\
\end{tabular}
\end{center}
\hrule
\end{table}

%-----------------------------------------------------------------------------

\subsection*{4.3.8 {\sf apply}: Apply a function to the elements of an object}

%-----------------------------------------------------------------------------

\subsubsection*{4.3.8.5 {\sf apply}: Vector index unary operator variant}

Computes the transformation of the values of the stored elements of a vector
using an index unary operator that is a function of the stored value, its location 
indices, and an user provided scalar value.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Vector              w,
                           const GrB_Vector        mask,
                           const GrB_BinaryOp      accum,
                           const GrB_IndexUnaryOp  op,
                           const GrB_Vector        u,
                           <type>                  val,
                           const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    apply operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector {\sf w}. The 
    mask dimensions must match those of the vector {\sf w}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the
    {\sf mask} vector must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf w}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf w} entries. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

{\color{red}
    \item[{\sf op}] ({\sf IN}) An index unary operator applied to each element of input 
    vector, {\sf u}, which is also a function of the element's row index, 
    and the scalar value, {\sf val}.
}

    \item[{\sf u}] ({\sf IN}) The GraphBLAS vector whose elements are passed 
    to the index unary operator.

    \item[{\sf val}] ({\sf IN}) An additional scalar value that is passed to the 
    index unary operator.
    
    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf mask} vector. The stored values are not examined.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the 
        complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.2in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).

    \item[{\sf GrB\_DIMENSION\_MISMATCH}]  {\sf mask}, {\sf w} and/or {\sf u}
    dimensions are incompatible.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various vectors are
    incompatible with the corresponding domains of the accumulation operator
    or index unary operator, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).

{\color{red}
    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}] The {\sf GrB\_IndexUnaryOp} expects a
    pair of indices but this operation only provides one index. \scott{Can we even
    detect if an IndexUnaryOp is expecting two indices, or is it undefined?}
}
\end{itemize}

\paragraph{Description}

{\color{red}
This variant of {\sf GrB\_apply} computes the result of applying an index unary operator
to the elements of a GraphBLAS vector each composed with the element's index and 
a scalar constant, {\sf val}:
\begin{itemize}[leftmargin=2.1in]
\item[~] ${\sf w} = f_{iu}({\sf u}, \bold{ind}({\sf u}), 1, {\sf val}),$
\end{itemize}
or if an optional binary accumulation operator ($\odot$) is provided:
\begin{itemize}[leftmargin=2.1in]
\item[~] ${\sf w} = {\sf w} \odot f_{iu}({\sf u}, \bold{ind}({\sf u}), 1, {\sf val})$.  
\end{itemize}
}

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[\bf Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to three argument vectors are used in this {\sf GrB\_apply} operation:
\begin{enumerate}
    \item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),
    \bold{L}({\sf w}) = \{(i,w_i) \} \rangle$

    \item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),
    \bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)

    \item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),
    \bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

{\color{red}
The argument scalar, vectors, index unary operator and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
    \item If {\sf mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

    \item $\bold{D}({\sf w})$ must be compatible with $\bDout({\sf op})$ of the index unary operator.

    \item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator and 
    $\bDout({\sf op})$ of the index unary operator must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.

    \item $\bold{D}({\sf u})$ must be compatible with $\bDin1({\sf op})$ of the index unary operator.
    
    \item $\bold{D}({\sf val})$ must be compatible with $\bDin2({\sf op})$ of the index unary operator.
\end{enumerate}
}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends
and the domain mismatch error listed above is returned.

From the argument vectors, the internal vectors and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
    \item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

    \item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
    \begin{enumerate}
        \item If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \ \forall \ i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

        \item If {\sf mask} $\ne$ {\sf GrB\_NULL},  
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then
            $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \} \rangle$,
            \item Otherwise, $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \wedge
            ({\sf bool}){\sf mask}(i) = \true \} \rangle$.
        \end{enumerate}

        \item    If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
    \end{enumerate}

    \item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
\end{enumerate}

The internal vectors and masks are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
    \item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$
    \item $\bold{size}(\vector{\widetilde{u}}) = \bold{size}(\vector{\widetilde{w}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the apply and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
    \item $\vector{\widetilde{t}}$: The vector holding the result from applying the index unary operator to the input vector
    $\vector{\widetilde{u}}$.
    \item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

{\color{red}
The intermediate vector, $\vector{\widetilde{t}}$, is created as follows:
\[
\vector{\widetilde{t}} = \langle
\bDout({\sf op}), \bold{size}(\vector{\widetilde{u}}),
\bold{L}(\vector{\widetilde{t}}) =
\{(i,f_{iu}(\vector{\widetilde{u}}(i),[i],1,{\sf val})) \forall i \in \bold{ind}(\vector{\widetilde{u}}) \} \rangle,
\]
where $f_{iu} = \mathbf{f}({\sf op})$.
}

\input{ops_accum_z_vector}

\input{ops_mask_replace_vector}

%-----------------------------------------------------------------------------

\subsubsection*{4.3.8.6 {\sf apply}: Matrix index unary operator variant}

Computes the transformation of the values of the stored elements of a matrix
using an index unary operator that is a function of the stored value, its location 
indices, and an user provided scalar value.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Matrix              C,
                           const GrB_Matrix        Mask,
                           const GrB_BinaryOp      accum,
                           const GrB_IndexUnaryOp  op,
                           const GrB_Matrix        A,
                           <type>                  val,
                           const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS matrix. On input,
    the matrix provides values that may be accumulated with the result of the
    apply operation.  On output, the matrix holds the results of the
    operation.

    \item[{\sf Mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix {\sf C}. The 
    mask dimensions must match those of the matrix {\sf C}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the 
    {\sf Mask} matrix must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf C}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf C} entries. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

{\color{red}
    \item[{\sf op}] ({\sf IN}) An index unary operator applied to each element of input 
    matrix, {\sf A}, which is also a function of the element's row and column indices,
    and the scalar value, {\sf val}.
}
    \item[{\sf A}] ({\sf IN}) The GraphBLAS matrix whose elements are passed 
    to the index unary operator.

    \item[{\sf val}] ({\sf IN}) An additional scalar value that is passed to the 
    index unary operator.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf Mask} matrix. The stored values are not examined.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the 
        complement of {\sf Mask}. \\

        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A}
        for the operation. \\
    \end{tabular}
\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output matrix {\sf C} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or {\sf dup} for matrix
    parameters).

    \item[{\sf GrB\_DIMENSION\_MISMATCH}]  {\sf mask}, {\sf w} and/or {\sf u}
    dimensions are incompatible.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various matrices are
    incompatible with the corresponding domains of the accumulation operator
    or index unary operator, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).
\end{itemize}

\paragraph{Description}

{\color{red}
This variant of {\sf GrB\_apply} computes the result of applying a index unary operator
to the elements of a GraphBLAS matrix each composed with the elements row and column
indices, and a scalar constant, {\sf val}:   
\begin{itemize}[leftmargin=2.1in]
\item[~] ${\sf C} = f_{iu}({\sf A}, \bold{ind}({\sf A}), 2, {\sf val})$;
\end{itemize}
or if an optional binary accumulation operator ($\odot$) is provided:  
\begin{itemize}[leftmargin=2.1in]
\item[~] ${\sf C} = {\sf C} \odot f_{iu}({\sf A}, \bold{ind}({\sf A}), 2, {\sf val})$.  
\end{itemize}
}

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.85in]
\item[\bf Setup] The internal matrices and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output matrix, possibly under 
control of a mask.
\end{enumerate}

Up to three argument matrices are used in the {\sf GrB\_apply} operation:
\begin{enumerate}
    \item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),
    \bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$

    \item ${\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}({\sf Mask}),
    \bold{ncols}({\sf Mask}),\bold{L}({\sf Mask}) = \{(i,j,M_{ij}) \} \rangle$ (optional)

    \item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}),
    \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
\end{enumerate}

{\color{red}
The argument scalar, matrices, index unary operator and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
    \item If {\sf Mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf Mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

    \item $\bold{D}({\sf C})$ must be
    compatible with $\bDout({\sf op})$ of the index unary operator. \scott{SHOULD THIS BE QUALIFIED: if {\sf accum} is {\sf GrB\_NULL}? Here and globally?}

    \item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator and 
    $\bDout({\sf op})$ of the index unary operator must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.

    \item $\bold{D}({\sf A})$ must be compatible with $\bDin1({\sf op})$ of the index unary operator.
    
    \item $\bold{D}({\sf val})$ must be compatible with $\bDin2({\sf op})$ of the index unary operator.
\end{enumerate}
}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends and 
the domain mismatch error listed above is returned.

From the argument matrices, the internal matrices, mask, and index arrays used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
    \item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

    \item Two-dimensional mask, $\matrix{\widetilde{M}}$, is computed from 
    argument {\sf Mask} as follows:
    \begin{enumerate}
        \item If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{M}} = 
        \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), 
        \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < 
        \bold{ncols}({\sf C}) \} \rangle$.

        \item If {\sf Mask} $\ne$ {\sf GrB\_NULL},
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then 
            $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
            \bold{ncols}({\sf Mask}), \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \} \rangle$,
            \item Otherwise, $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
            \bold{ncols}({\sf Mask}), \\ \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \wedge 
            ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.
        \end{enumerate}

        \item    If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\matrix{\widetilde{M}} \leftarrow \neg \matrix{\widetilde{M}}$.
    \end{enumerate}

    \item Matrix $\matrix{\widetilde{A}}$ is computed from argument {\sf A} as 
    follows: 
    \begin{itemize}[leftmargin=1.2in]
    \item[bind-first:~~~~]  $\matrix{\widetilde{A}}\leftarrow
        {\sf desc[GrB\_INP1].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$
    \item[bind-second:~~~~] $\matrix{\widetilde{A}}\leftarrow
        {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$
    \end{itemize}
\end{enumerate}

The internal matrices and mask are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{M}})$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{M}})$.

    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{A}})$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{A}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_apply} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can optionally exit
with {\sf GrB\_SUCCESS} return code and defer any computation and/or execution error codes.

We are now ready to carry out the apply and any additional 
associated operations.  We describe this in terms of two intermediate matrices:
\begin{itemize}
    \item $\matrix{\widetilde{T}}$: The matrix holding the result from applying the index unary operator to the input matrix
    $\matrix{\widetilde{A}}$.

    \item $\matrix{\widetilde{Z}}$: The matrix holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

{\color{red}
The intermediate matrix, $\matrix{\widetilde{T}}$, is created as follows:
\[
\begin{aligned}
\matrix{\widetilde{T}} = & \langle \bDout({\sf op}),
                           \bold{nrows}(\matrix{\widetilde{C}}), 
                           \bold{ncols}(\matrix{\widetilde{C}}),  \bold{L}(\matrix{\widetilde{T}}) =
    \{(i,j,f_{iu}(\matrix{\widetilde{A}}(i,j),[i,j],2,{\sf val})) 
\ \forall \ (i,j) \in 
\bold{ind}(\matrix{\widetilde{A}}) \} \rangle,
\end{aligned}
\]
where $f_{i,j} = \mathbf{f}({\sf op})$.
}

\input{ops_accum_z_matrix}

\input{ops_mask_replace_matrix}

%-----------------------------------------------------------------------------

\subsection*{4.3.12 {\sf select}:} Apply a select operator to the stored elements of an 
object to determine whether or not to keep them.

%-----------------------------------------------------------------------------

\subsubsection*{4.3.12.1 {\sf select}: Vector variant} 

Apply a select operator (an index unary operator) to the elements of a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_select(GrB_Vector              w,
                            const GrB_Vector        mask,
                            const GrB_BinaryOp      accum,
                            const GrB_IndexUnaryOp  op,
                            const GrB_Vector        u,
                            <type>                  val,
                            const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    select operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector {\sf w}. The 
    mask dimensions must match those of the vector {\sf w}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the
    {\sf mask} vector must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf w}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf w} entries. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

{\color{red}
    \item[{\sf op}] ({\sf IN}) An index unary operator applied to each element of input 
    vector, {\sf u}, which is also a function of the element's row index, 
    and the scalar value, {\sf val}.
}
    \item[{\sf u}] ({\sf IN}) The GraphBLAS vector whose elements are passed 
    to the index unary operator.

    \item[{\sf val}] ({\sf IN}) An additional scalar value that is passed to the 
    index unary operator.
    
    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf mask} vector. The stored values are not examined.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the 
        complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.2in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).

    \item[{\sf GrB\_DIMENSION\_MISMATCH}]  {\sf mask}, {\sf w} and/or {\sf u}
    dimensions are incompatible.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various vectors are
    incompatible with the corresponding domains of the accumulation operator
    or index unary operator, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).

{\color{red}
    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}] The {\sf GrB\_IndexUnaryOp} expects a
    pair of indices but this operation only provides one index. \scott{Can we even
    detect if an IndexUnaryOp is expecting two indices, or is it undefined?}
}
\end{itemize}

\paragraph{Description}

{\color{red}
This variant of {\sf GrB\_select} computes the result of applying a index unary operator
to select the elements of the input GraphBLAS vector.  The operator takes, as input,
the value of each stored element, along with the element's index and a scalar 
constant, {\sf val}.  The corresponding element of the input vector is selected (kept)
if the function evaluates to {\sf true} when cast to {\sf bool}.  This acts like a
functional mask on the input vector as follows:
\begin{itemize}[leftmargin=2.1in]
\item[~] ${\sf w} = {\sf u}\langle f_i({\sf u}, \bold{ind}({\sf u}), 1, {\sf val})\rangle$,
\end{itemize}
or if an optional binary accumulation operator ($\odot$) is provided:
\begin{itemize}[leftmargin=2.1in]
\item[~] ${\sf w} = {\sf w} \odot {\sf u}\langle f_i({\sf u}, \bold{ind}({\sf u}), 1, {\sf val})\rangle$.  
\end{itemize}
}

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[\bf Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to three argument vectors are used in this {\sf GrB\_select} operation:
\begin{enumerate}
    \item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),
    \bold{L}({\sf w}) = \{(i,w_i) \} \rangle$

    \item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),
    \bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)

    \item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),
    \bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

{\color{red}
The argument scalar, vectors, index unary operator and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
    \item If {\sf mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

    \item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be 
	compatible with $\bold{D}({\sf u})$.

    \item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator and 
    $\bold{D}({\sf u})$ must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.

	\item $\bDout({\sf op})$ of the index unary operator must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}; i.e., castable to {\sf bool}.

    \item $\bold{D}({\sf u})$ must be compatible with $\bDin1({\sf op})$ of the index unary operator.
    
    \item $\bold{D}({\sf val})$ must be compatible with $\bDin2({\sf op})$ of the index unary operator.
\end{enumerate}
}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_select} ends
and the domain mismatch error listed above is returned.

From the argument vectors, the internal vectors and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
    \item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

    \item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
    \begin{enumerate}
        \item If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \ \forall \ i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

        \item If {\sf mask} $\ne$ {\sf GrB\_NULL},  
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then
            $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \} \rangle$,
            \item Otherwise, $\vector{\widetilde{m}} = 
            \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \wedge
            ({\sf bool}){\sf mask}(i) = \true \} \rangle$.
        \end{enumerate}

        \item    If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
    \end{enumerate}

    \item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
\end{enumerate}

The internal vectors and masks are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
    \item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$
    \item $\bold{size}(\vector{\widetilde{u}}) = \bold{size}(\vector{\widetilde{w}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_select} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the {\sf select} and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
    \item $\vector{\widetilde{t}}$: The vector holding the result from applying the index unary operator to the input vector
    $\vector{\widetilde{u}}$.
    \item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

{\color{red}
The intermediate vector, $\vector{\widetilde{t}}$, is created as follows:
\[
\vector{\widetilde{t}} = \langle
\bold{D}({\sf u}), \bold{size}(\vector{\widetilde{u}}),
\bold{L}(\vector{\widetilde{t}}) =
\{(i,\vector{\widetilde{u}}(i), : i \in \bold{ind}(\vector{\widetilde{u}}) \wedge ({\sf bool})f_i(\vector{\widetilde{u}}(i),i,{\sf val}) = \true \} \rangle,
\]
where $f_{i} = \mathbf{f}({\sf op})$. \scott{add another zero index argument for j above?}
}

\input{ops_accum_z_vector}

\input{ops_mask_replace_vector}

%-----------------------------------------------------------------------------

\subsubsection*{4.3.12.2 {\sf select}: Matrix variant}

Apply a select operator to the elements of a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_select(GrB_Matrix              C,
                            const GrB_Matrix        Mask,
                            const GrB_BinaryOp      accum,
                            const GrB_IndexUnaryOp  op,
                            const GrB_Matrix        A,
                            <type>                  val,
                            const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS matrix. On input,
    the matrix provides values that may be accumulated with the result of the
    select operation.  On output, the matrix holds the results of the
    operation.

    \item[{\sf Mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix {\sf C}. The 
    mask dimensions must match those of the matrix {\sf C}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the 
    {\sf Mask} matrix must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf C}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf C} entries. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.
{\color{red}
    \item[{\sf op}] ({\sf IN}) An index unary operator applied to each element of input 
    matrix, {\sf A}, which is also a function of the element's row and column indices,
    and the scalar value, {\sf val}.
}
    \item[{\sf A}] ({\sf IN}) The GraphBLAS matrix whose elements are passed 
    to the index unary operator.

    \item[{\sf val}] ({\sf IN}) An additional scalar value that is passed to the 
    index unary operator.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf Mask} matrix. The stored values are not examined.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the 
        complement of {\sf Mask}. \\

        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A}
        for the operation. \\
    \end{tabular}
\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output mattrix {\sf C} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or {\sf dup} for matrix
    parameters).

    \item[{\sf GrB\_DIMENSION\_MISMATCH}]  {\sf mask}, {\sf w} and/or {\sf u}
    dimensions are incompatible.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various matrices are
    incompatible with the corresponding domains of the accumulation operator
    or index unary operator, or the mask's domain is not compatible with {\sf bool}
    (in the case where {\sf desc[GrB\_MASK].GrB\_STRUCTURE} is not set).
\end{itemize}

\paragraph{Description}

{\color{red}
This variant of {\sf GrB\_select} computes the result of applying a index unary operator
to select the elements of the input GraphBLAS matrix.  The operator takes, as input,
the value of each stored element, along with the element's row and column indices and a scalar 
constant, {\sf val}.  The corresponding element of the input matrix is selected (kept)
if the function evaluates to {\sf true} when cast to {\sf bool}.  This acts like a
functional mask on the input matrix as follows:
\begin{itemize}[leftmargin=2.1in]
\item[~] ${\sf C} = {\sf A}\langle f_{i,j}({\sf A}, \bold{ind}({\sf A}), {\sf val})\rangle$;
\end{itemize}
or if an optional binary accumulation operator ($\odot$) is provided:  
\begin{itemize}[leftmargin=2.1in]
\item[~] ${\sf C} = {\sf C} \odot {\sf A}\langle f_{i,j}({\sf A}, \bold{ind}({\sf A}), {\sf val})\rangle$.  
\end{itemize}
}

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.85in]
\item[\bf Setup] The internal matrices and mask used in the computation are formed 
and their domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output matrix, possibly under 
control of a mask.
\end{enumerate}

Up to three argument matrices are used in the {\sf GrB\_select} operation:
\begin{enumerate}
    \item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),
    \bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$

    \item ${\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}({\sf Mask}),
    \bold{ncols}({\sf Mask}),\bold{L}({\sf Mask}) = \{(i,j,M_{ij}) \} \rangle$ (optional)

    \item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}),
    \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
\end{enumerate}

{\color{red}
The argument scalar, matrices, index unary operator and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
    \item If {\sf Mask} is not {\sf GrB\_NULL}, and ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$
    is not set, then $\bold{D}({\sf Mask})$ must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}.

    \item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be 
	compatible with $\bold{D}({\sf A})$.

    \item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator and 
    $\bold{D}({\sf A})$ must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.

	\item $\bDout({\sf op})$ of the index unary operator must be from one of the pre-defined types of 
    Table~\ref{Tab:PredefinedTypes}; i.e., castable to {\sf bool}.

    \item $\bold{D}({\sf A})$ must be compatible with $\bDin1({\sf op})$ of the index unary operator.
    
    \item $\bold{D}({\sf val})$ must be compatible with $\bDin2({\sf op})$ of the index unary operator.
\end{enumerate}
}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_select} ends and 
the domain mismatch error listed above is returned.

From the argument matrices, the internal matrices, mask, and index arrays used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
    \item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

    \item Two-dimensional mask, $\matrix{\widetilde{M}}$, is computed from 
    argument {\sf Mask} as follows:
    \begin{enumerate}
        \item If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{M}} = 
        \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), 
        \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < 
        \bold{ncols}({\sf C}) \} \rangle$.

        \item If {\sf Mask} $\ne$ {\sf GrB\_NULL},
        \begin{enumerate}
            \item If ${\sf desc[GrB\_MASK].GrB\_STRUCTURE}$ is set, then 
            $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
            \bold{ncols}({\sf Mask}), \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \} \rangle$,
            \item Otherwise, $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
            \bold{ncols}({\sf Mask}), \\ \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \wedge 
            ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.
        \end{enumerate}

        \item    If ${\sf desc[GrB\_MASK].GrB\_COMP}$ is set, then 
        $\matrix{\widetilde{M}} \leftarrow \neg \matrix{\widetilde{M}}$.
    \end{enumerate}

    \item Matrix $\matrix{\widetilde{A}}$ is computed from argument {\sf A} as 
    follows: 
    \begin{itemize}[leftmargin=1.2in]
    \item[bind-first:~~~~]  $\matrix{\widetilde{A}}\leftarrow
        {\sf desc[GrB\_INP1].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$
    \item[bind-second:~~~~] $\matrix{\widetilde{A}}\leftarrow
        {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$
    \end{itemize}
\end{enumerate}

The internal matrices and mask are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{M}})$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{M}})$.

    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{A}})$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{A}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_select} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can optionally exit
with {\sf GrB\_SUCCESS} return code and defer any computation and/or execution error codes.

We are now ready to carry out the select and any additional 
associated operations.  We describe this in terms of two intermediate matrices:
\begin{itemize}
    \item $\matrix{\widetilde{T}}$: The matrix holding the result from applying the index unary operator to the input matrix
    $\matrix{\widetilde{A}}$.

    \item $\matrix{\widetilde{Z}}$: The matrix holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

{\color{red}
The intermediate matrix, $\matrix{\widetilde{T}}$, is created as follows:
\[
\begin{aligned}
\matrix{\widetilde{T}} = \langle & \bDout({\sf op}),
                           \bold{nrows}(\matrix{\widetilde{C}}), 
                           \bold{ncols}(\matrix{\widetilde{C}}), \\
						  & \bold{L}(\matrix{\widetilde{T}}) =
    \{(i,j,\matrix{\widetilde{A}}(i,j) : {i,j} \in \bold{ind}(\matrix{\widetilde{A}}) 
	\wedge
({\sf bool})f_{i,j}(\matrix{\widetilde{A}}(i,j),i,j,{\sf val}) = \true \} \rangle,
\end{aligned}
\]
where $f_{i,j} = \mathbf{f}({\sf op})$.
}

\input{ops_accum_z_matrix}

\input{ops_mask_replace_matrix}

%-----------------------------------------------------------------------------

\begin{landscape}

\chapter*{5. Nonpolymorphic Interface}


\begin{table}[htb]
\caption{Long-name, nonpolymorphic form of GraphBLAS methods (continued).}
{\footnotesize
\hspace*{-7em}\begin{tabular}{l|l}
Polymorphic signature	& Nonpolymorphic signature  \\ \hline
{\sf GrB\_apply(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,bool,\ldots)}		    & {\sf GrB\_Vector\_apply\_IndexOp\_BOOL(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,bool,\ldots)} \\
{\sf GrB\_apply(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int8\_t,\ldots)}	    & {\sf GrB\_Vector\_apply\_IndexOp\_INT8(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int8\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint8\_t,\ldots)}	    & {\sf GrB\_Vector\_apply\_IndexOp\_UINT8(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint8\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int16\_t,\ldots)}	    & {\sf GrB\_Vector\_apply\_IndexOp\_INT16(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int16\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint16\_t,\ldots)}	& {\sf GrB\_Vector\_apply\_IndexOp\_UINT16(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint16\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int32\_t,\ldots)}	    & {\sf GrB\_Vector\_apply\_IndexOp\_INT32(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int32\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint32\_t,\ldots)}	& {\sf GrB\_Vector\_apply\_IndexOp\_UINT32(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint32\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int64\_t,\ldots)}	    & {\sf GrB\_Vector\_apply\_IndexOp\_INT64(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int64\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint64\_t,\ldots)}	& {\sf GrB\_Vector\_apply\_IndexOp\_UINT64(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint64\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,float,\ldots)}		& {\sf GrB\_Vector\_apply\_IndexOp\_FP32(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,float,\ldots)} \\
{\sf GrB\_apply(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,double,\ldots)}	    & {\sf GrB\_Vector\_apply\_IndexOp\_FP64(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,double,\ldots)} \\
{\sf GrB\_apply(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,\emph{other},\ldots)}	& {\sf GrB\_Vector\_apply\_IndexOp\_UDT(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,const void*,\ldots)} \\
\hline

{\sf GrB\_apply(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,bool,\ldots)}		    & {\sf GrB\_Matrix\_apply\_IndexOp\_BOOL(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,bool,\ldots)} \\
{\sf GrB\_apply(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int8\_t,\ldots)}	    & {\sf GrB\_Matrix\_apply\_IndexOp\_INT8(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int8\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint8\_t,\ldots)}	    & {\sf GrB\_Matrix\_apply\_IndexOp\_UINT8(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint8\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int16\_t,\ldots)}	    & {\sf GrB\_Matrix\_apply\_IndexOp\_INT16(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int16\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint16\_t,\ldots)}	& {\sf GrB\_Matrix\_apply\_IndexOp\_UINT16(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint16\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int32\_t,\ldots)}	    & {\sf GrB\_Matrix\_apply\_IndexOp\_INT32(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int32\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint32\_t,\ldots)}	& {\sf GrB\_Matrix\_apply\_IndexOp\_UINT32(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint32\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int64\_t,\ldots)}	    & {\sf GrB\_Matrix\_apply\_IndexOp\_INT64(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int64\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint64\_t,\ldots)}	& {\sf GrB\_Matrix\_apply\_IndexOp\_UINT64(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint64\_t,\ldots)} \\
{\sf GrB\_apply(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,float,\ldots)}		& {\sf GrB\_Matrix\_apply\_IndexOp\_FP32(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,float,\ldots)} \\
{\sf GrB\_apply(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,double,\ldots)}	    & {\sf GrB\_Matrix\_apply\_IndexOp\_FP64(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,double,\ldots)} \\
{\sf GrB\_apply(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,\emph{other},\ldots)}	& {\sf GrB\_Matrix\_apply\_IndexOp\_UDT(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,const void*,\ldots)} \\
\hline
\end{tabular}
}
\end{table}


\begin{table}[htb]
\caption{Long-name, nonpolymorphic form of GraphBLAS methods (continued).}
{\footnotesize
\hspace*{-7em}\begin{tabular}{l|l}
Polymorphic signature	& Nonpolymorphic signature  \\ \hline
{\sf GrB\_select(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,bool,\ldots)}		& {\sf GrB\_Vector\_select\_IndexOp\_BOOL(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,bool,\ldots)} \\
{\sf GrB\_select(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int8\_t,\ldots)}	    & {\sf GrB\_Vector\_select\_IndexOp\_INT8(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int8\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint8\_t,\ldots)}    & {\sf GrB\_Vector\_select\_IndexOp\_UINT8(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint8\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int16\_t,\ldots)}    & {\sf GrB\_Vector\_select\_IndexOp\_INT16(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int16\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint16\_t,\ldots)}	& {\sf GrB\_Vector\_select\_IndexOp\_UINT16(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint16\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int32\_t,\ldots)}    & {\sf GrB\_Vector\_select\_IndexOp\_INT32(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int32\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint32\_t,\ldots)}	& {\sf GrB\_Vector\_select\_IndexOp\_UINT32(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint32\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int64\_t,\ldots)}    & {\sf GrB\_Vector\_select\_IndexOp\_INT64(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,int64\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint64\_t,\ldots)}	& {\sf GrB\_Vector\_select\_IndexOp\_UINT64(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,uint64\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,float,\ldots)}		& {\sf GrB\_Vector\_select\_IndexOp\_FP32(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,float,\ldots)} \\
{\sf GrB\_select(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,double,\ldots)}	    & {\sf GrB\_Vector\_select\_IndexOp\_FP64(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,double,\ldots)} \\
{\sf GrB\_select(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,\emph{other},\ldots)}	& {\sf GrB\_Vector\_select\_IndexOp\_UDT(GrB\_Vector,\ldots,GrB\_IndexUnaryOp,GrB\_Vector,const void*,\ldots)} \\
\hline

{\sf GrB\_select(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,bool,\ldots)}	    & {\sf GrB\_Matrix\_select\_IndexOp\_BOOL(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,bool,\ldots)} \\
{\sf GrB\_select(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int8\_t,\ldots)}	    & {\sf GrB\_Matrix\_select\_IndexOp\_INT8(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int8\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint8\_t,\ldots)}    & {\sf GrB\_Matrix\_select\_IndexOp\_UINT8(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint8\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int16\_t,\ldots)}    & {\sf GrB\_Matrix\_select\_IndexOp\_INT16(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int16\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint16\_t,\ldots)}	& {\sf GrB\_Matrix\_select\_IndexOp\_UINT16(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint16\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int32\_t,\ldots)}    & {\sf GrB\_Matrix\_select\_IndexOp\_INT32(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int32\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint32\_t,\ldots)}	& {\sf GrB\_Matrix\_select\_IndexOp\_UINT32(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint32\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int64\_t,\ldots)}    & {\sf GrB\_Matrix\_select\_IndexOp\_INT64(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,int64\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint64\_t,\ldots)}	& {\sf GrB\_Matrix\_select\_IndexOp\_UINT64(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,uint64\_t,\ldots)} \\
{\sf GrB\_select(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,float,\ldots)}		& {\sf GrB\_Matrix\_select\_IndexOp\_FP32(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,float,\ldots)} \\
{\sf GrB\_select(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,double,\ldots)}	    & {\sf GrB\_Matrix\_select\_IndexOp\_FP64(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,double,\ldots)} \\
{\sf GrB\_select(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,\emph{other},\ldots)}	& {\sf GrB\_Matrix\_select\_IndexOp\_UDT(GrB\_Matrix,\ldots,GrB\_IndexUnaryOp,GrB\_Matrix,const void*,\ldots)} \\
\hline
\end{tabular}
}
\end{table}

\end{landscape}
