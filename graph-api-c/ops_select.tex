\chapter{Methods}
\section{Object Methods}
\subsection{Algebra Methods}
%-----------------------------------------------------------------------------

\subsubsection{{\sf IndexVectorOp\_new}: Create a new GraphBLAS index operator for vectors}

\scott{I think I like the name IndexVectorOp better than IndexOpVector.}

Initializes a new GraphBLAS vector index operator with a specified user-defined 
function and its types (domains).

\paragraph{\syntax}

\begin{verbatim}
    GrB_Info GrB_IndexVectorOp_new(GrB_IndexVectorOp  *index_vector_op,
                                   void (*index_vector_func)(void*,
                                                             const void*,
                                                             GrB_Index,
                                                             const void*),
                                   GrB_Type            d_out,
                                   GrB_Type            d_in1,
                                   GrB_Type            d_in2);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.2in]
    \item[{\sf index\_vector\_op}] ({\sf INOUT}) On successful return, contains a 
          handle to the newly created GraphBLAS vector index operator object.
    \item[{\sf index\_vector\_func}] ({\sf IN}) A pointer to a user-defined function that 
          takes input parameters of types {\sf d\_in1}, {\sf GrB\_Index} and {\sf d\_in2}
          and returns a value of type {\sf d\_out}.  Except for the {\sf GrB\_Index}
          parameter, all are passed as {\sf void} pointers.
          Specifically the signature of the function is expected to 
          be of the form:
      \begin{verbatim}
      void func(void *out,
                const void *in1, GrB_index i, 
                const void *in2);
      \end{verbatim}
    \item[{\sf d\_out}]  ({\sf IN}) The {\sf GrB\_Type} of the return
          value of the vector index operator being created. Should be one of the
          predefined GraphBLAS types in Table~\ref{Tab:PredefinedTypes}, or a 
          user-defined GraphBLAS type.
    \item[{\sf d\_in1}]  ({\sf IN}) The {\sf GrB\_Type} of the left hand 
          argument of the vector index operator being created and corresponds to scalars 
          from the {\sf GrB\_Vector} being operated on. Should be one of the
          predefined GraphBLAS types in Table~\ref{Tab:PredefinedTypes}, or a
          user-defined GraphBLAS type.
    \item[{\sf d\_in2}]  ({\sf IN}) The {\sf GrB\_Type} of the right hand 
          argument of the vector index operator being created and corresponds to a
          scalar provided by the GraphBLAS operation that uses this operator. Should be one of the
          predefined GraphBLAS types in Table~\ref{Tab:PredefinedTypes}, or a 
          user-defined GraphBLAS type.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]           operation completed successfully.
\item[{\sf GrB\_PANIC}]             unknown internal error.
\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          the {\sf GrB\_Type} (for user-defined types)
                                    has not been initialized by a call to {\sf GrB\_Type\_new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf index\_vector\_op} or {\sf index\_vector\_func} pointer is {\sf NULL}.

\jose{Domain mistmatch not possible.}
%\item[{\sf GrB\_DOMAIN\_MISMATCH}]  the types in the function pointer signature are not   
%                                    compatible with the {\sf GrB\_Type} parameters specified.
\end{itemize}

\paragraph{Description}

The {\sf IndexVectorOp\_new} methods creates a new GraphBLAS vector index operator
\begin{quote}
$^{i}f = \langle \mathbf{D}({\sf d\_out}), \mathbf{D}({\sf d\_in1}), \mathbf{D}({\sf GrB\_Index}), \mathbf{D}({\sf d\_in2}), {\sf index\_vector\_func} \rangle$
\end{quote}
and returns a handle to it in {\sf index\_vector\_op}.

The implementation of {\sf index\_vector\_func} must be such that it works
even if any of the {\sf d\_out}, {\sf d\_in1}, and {\sf d\_in2} arguments are aliased to each other.
In other words, for all invocations of the function:
\begin{quote}
\begin{verbatim}
index_vector_func(out,in1,i,in2);
\end{verbatim}
\end{quote}
the value of {\sf out} must be the same as if the following code
was executed:

\begin{quote}
\begin{code}
    $\mathbf{D}({\sf d\_in1})$ tmp1 = malloc(sizeof($\mathbf{D}({\sf d\_in1}$))); \\
    $\mathbf{D}({\sf d\_in2})$ tmp2 = malloc(sizeof($\mathbf{D}({\sf d\_in2}$))); \\
    memcpy(tmp1,in1,sizeof($\mathbf{D}({\sf d\_in1}$))); \\
    memcpy(tmp2,in2,sizeof($\mathbf{D}({\sf d\_in2}$))); \\
    index\_vector\_func(out,tmp1,i,tmp2); \\
    free(tmp2); \\
    free(tmp1);
\end{code}
\end{quote}

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created object will be overwritten. 

%-----------------------------------------------------------------------------

\subsubsection{{\sf IndexMatrixOp\_new}: Create a new GraphBLAS index operator for matrices}

\scott{I think I like IndexMatrixOp better than IndexOpMatrix.}


Initializes a new GraphBLAS matrix index operator with a specified user-defined 
function and its types (domains).

\paragraph{\syntax}

\begin{verbatim}
    GrB_Info GrB_IndexMatrixOp_new(GrB_IndexMatrixOp  *index_matrix_op,
                                   void (*index_matrix_func)(void*,
                                                             const void*,
                                                             const GrB_Index,
                                                             const GrB_Index,
                                                             const void*),
                                   GrB_Type            d_out,
                                   GrB_Type            d_in1,
                                   GrB_Type            d_in2);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf index\_matrix\_op}] ({\sf INOUT}) On successful return, contains a 
          handle to the newly created GraphBLAS matrix index operator object.
    \item[{\sf matrix\_index\_func}] ({\sf IN}) A pointer to a user-defined function that 
          takes input parameters of types {\sf d\_in1}, {\sf GrB\_Index} and {\sf d\_in2}
          and returns a value of type {\sf d\_out}.  Except for the {\sf GrB\_Index}
          parameters, all are  passed as {\sf void} pointers.
          Specifically the signature of the function is expected to 
          be of the form:
      \begin{verbatim}
      void func(void *out,
                const void *in1, GrB_index i, GrB_index j, 
                const void *in2);
      \end{verbatim}
    \item[{\sf d\_out}]  ({\sf IN}) The {\sf GrB\_Type} of the return
          value of the matrix index operator being created. Should be one of the
          predefined GraphBLAS types in Table~\ref{Tab:PredefinedTypes}, or a 
          user-defined GraphBLAS type.
    \item[{\sf d\_in1}]  ({\sf IN}) The {\sf GrB\_Type} of the left hand 
          argument of the matrix index operator being created and corresponds to scalars 
          from the {\sf GrB\_Matrix} being operated on. Should be one of the
          predefined GraphBLAS types in Table~\ref{Tab:PredefinedTypes}, or a
          user-defined GraphBLAS type.
    \item[{\sf d\_in2}]  ({\sf IN}) The {\sf GrB\_Type} of the right hand 
          argument of the matrix index operator being created and corresponds to a
          scalar provided by the GraphBLAS operation that uses this operator. Should be one of the
          predefined GraphBLAS types in Table~\ref{Tab:PredefinedTypes}, or a 
          user-defined GraphBLAS type.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]           operation completed successfully.
\item[{\sf GrB\_PANIC}]             unknown internal error.
\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          the {\sf GrB\_Type} (for user-defined types)
                                    has not been initialized by a call to {\sf GrB\_Type\_new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf index\_matrix\_op} or {\sf index\_matrix\_func} pointer is {\sf NULL}.

\jose{Domain mistmatch not possible.}
%\item[{\sf GrB\_DOMAIN\_MISMATCH}]  the types in the function pointer signature are not   
%                                    compatible with the {\sf GrB\_Type} parameters specified.
\end{itemize}

\paragraph{Description}

The {\sf IndexMatrixOp\_new} methods creates a new GraphBLAS matrix index operator
\begin{quote}
$^{i,j}f = \langle \mathbf{D}({\sf d\_out}), \mathbf{D}({\sf d\_in1}), \mathbf{D}({\sf GrB\_Index}), \mathbf{D}({\sf GrB\_Index}), \mathbf{D}({\sf d\_in2}), {\sf index\_matrix\_func} \rangle$
\end{quote}
and returns a handle to it in {\sf index\_matrix\_op}.

The implementation of {\sf index\_matrix\_func} must be such that it works
even if any of the {\sf d\_out}, {\sf d\_in1}, and {\sf d\_in2} arguments are aliased to each other.
In other words, for all invocations of the function:
\begin{quote}
\begin{verbatim}
index_matrix_func(out,in1,i,j,in2);
\end{verbatim}
\end{quote}
the value of {\sf out} must be the same as if the following code
was executed:

\begin{quote}
\begin{code}
    $\mathbf{D}({\sf d\_in1})$ tmp1 = malloc(sizeof($\mathbf{D}({\sf d\_in1}$))); \\
    $\mathbf{D}({\sf d\_in2})$ tmp2 = malloc(sizeof($\mathbf{D}({\sf d\_in2}$))); \\
    memcpy(tmp1,in1,sizeof($\mathbf{D}({\sf d\_in1}$))); \\
    memcpy(tmp2,in2,sizeof($\mathbf{D}({\sf d\_in2}$))); \\
    index\_matrix\_func(out,tmp1,i,j,tmp2); \\
    free(tmp2); \\
    free(tmp1);
\end{code}
\end{quote}

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created object will be overwritten. 

%-----------------------------------------------------------------------------

\section{GraphBLAS Operations}

\begin{table}[tb]
\hrule
\begin{center}
\newcommand{\odotsp}{\hspace{-0.2cm}\odot\hspace{-0.18cm}}
\begin{tabular}{l|rcrcl}
{\sf Operation Name} & \multicolumn{5}{c}{Mathematical Notation}  \\
\hline
{\sf apply(indexop)}     & $\matrix{C}\langle\matrix{M},z\rangle$ & $=$ & $\matrix{C}$ & $\odotsp$ & $^{i,j}f(\matrix{A},\mathbf{ind}(\matrix{A},s)$ \\
                   & $\vector{w}\langle\matrix{m},z\rangle$ & $=$ & $\vector{w}$ & $\odotsp$ & $^{i}f(\vector{u},\mathbf{ind}(\vector{u},s)$  \\
{\sf select  }     & $\matrix{C}\langle\matrix{M},z\rangle$ & $=$ & $\matrix{C}$ & $\odotsp$ & $\matrix{A}\langle ^{i,j}f(\matrix{A},\mathbf{ind}(\matrix{A},s)\rangle$ \\
                   & $\vector{w}\langle\matrix{m},z\rangle$ & $=$ & $\vector{w}$ & $\odotsp$ & $\vector{u}\langle ^{i}f(\vector{u},\mathbf{ind}(\vector{u},s)\rangle$  \\
\end{tabular}
\end{center}
\hrule
\end{table}

%-----------------------------------------------------------------------------

\subsection{{\sf apply}: Apply a function to the elements of an object}

%-----------------------------------------------------------------------------

\subsubsection{{\sf apply}: Vector index operator variant}

Computes the transformation of the values of the stored elements of a vector
using an index operator that is a function of the stored value, its location 
indices, and an user provided scalar value.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Vector              w,
                           const GrB_Vector        mask,
                           const GrB_BinaryOp      accum,
                           const GrB_IndexMatrixOp op,
                           const GrB_Vector        u,
                           <type>                  val,
                           const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    apply operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector {\sf w}. The 
    mask dimensions must match those of the vector {\sf w}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the
    {\sf mask} vector must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf w}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf w} entries. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}] ({\sf IN}) A index operator replacing each element of input 
    vector, {\sf u}, with the result of a function of the stored value from the input vector, 
	the row anc column indices of its position, and the scalar value, {\sf val}.

    \item[{\sf u}] ({\sf IN}) The GraphBLAS vector whose elements are passed 
    to the index operator.

    \item[{\sf val}] ({\sf IN}) An additional scalar value that is passed to the 
	index operator .
    
    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf mask} vector. The stored values are not examined.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the 
        complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}
%-----------------------------------------------------------------------------

\subsubsection{{\sf apply}: Matrix index operator variant}

Computes the transformation of the values of the stored elements of a matrix
using an index operator that is a function of the stored value, its location 
indices, and an user provided scalar value.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Matrix              C,
                           const GrB_Matrix        Mask,
                           const GrB_BinaryOp      accum,
                           const GrB_IndexMatrixOp op,
                           const GrB_Matrix        A,
                           <type>                  val,
                           const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS matrix. On input,
    the matrix provides values that may be accumulated with the result of the
    apply operation.  On output, the matrix holds the results of the
    operation.

    \item[{\sf Mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix {\sf C}. The 
    mask dimensions must match those of the matrix {\sf C}. If the 
    {\sf GrB\_STRUCTURE} descriptor is {\em not} set for the mask, the domain of the 
    {\sf Mask} matrix must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    mask is desired (\ie, a mask that is all {\sf true} with the dimensions of {\sf C}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf C} entries. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}] ({\sf IN}) A index operator replacing each element of input 
    matrix, {\sf A}, with the result of a function of the stored value from the input vector, 
	the row and column indices of its position, and the scalar value, {\sf val}.

    \item[{\sf A}] ({\sf IN}) The GraphBLAS matrix whose elements are passed 
    to the index operator.

    \item[{\sf val}] ({\sf IN}) An additional scalar value that is passed to the 
	index operator.
	
    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \hspace*{-2em}\begin{tabular}{lllp{2.7in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_STRUCTURE}   & The write mask is
        constructed from the structure (pattern of stored values) of the input
        {\sf Mask} matrix. The stored values are not examined.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_COMP}   & Use the 
        complement of {\sf Mask}. \\

        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A}
        for the operation ({\em bind-second} variant only). \\

        {\sf A}    & {\sf GrB\_INP1} & {\sf GrB\_TRAN}   & Use transpose of {\sf A}
        for the operation ({\em bind-first} variant only). \\
    \end{tabular}
\end{itemize}


%-----------------------------------------------------------------------------

\subsection{{\sf select}: }