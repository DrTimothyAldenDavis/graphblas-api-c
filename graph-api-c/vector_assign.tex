%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_assign}: Standard vector variant}

Assign values (and implied zeros) from one GraphBLAS vector to a subset of a 
vector as specified by a set of indices. The size of the input vector is the
same size as the index array provided.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_assign(GrB_Vector              w,
                                   const GrB_Vector        u,
                                   const GrB_Index        *indices,
                                   const GrB_Index         nindices);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf w}] ({\sf INOUT}) An existing GraphBLAS vector, that will
    be modified by the assign.  On output, this vector holds the results
    of the operation.

    \item[{\sf u}] ({\sf IN}) The GraphBLAS vector whose contents are
    assigned to a subset of {\sf w}.

    \item[{\sf indices}] ({\sf IN}) Pointer to the ordered set (array)
    of indices corresponding to the locations in {\sf w} that are to be
    assigned.  If all elements of {\sf w} are to be assigned in order from
    $0$ to ${\sf nindices} - 1$, then {\sf GrB\_ALL} should be specified.
    Regardless of execution mode and return value, this array may be
    manipulated by the caller after this operation returns without
    affecting any deferred computations for this operation.  If this
    array contains duplicate values, it implies in assignment of more
    than one value to the same location which leads to undefined results.

    \item[{\sf nindices}] ({\sf IN}) The number of values in {\sf
    indices} array.  Must be equal to $\bold{size}({\sf u})$.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]            Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf indices} is greater
    than or equal to $\bold{size}({\sf w})$.  In non-blocking mode, this can be
    reported as an execution error.
    
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] ${\sf nindices} \neq \bold{size}({\sf u})$. 
    
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various vectors are
	incompatible with each other.

    \item[{\sf GrB\_NULL\_POINTER}] Argument {\sf indices} is a {\sf NULL} pointer.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_assign} computes the result of assigning values of elements from 
a source GraphBLAS vector to elements of a destination GraphBLAS vector. 
More explicitly:
\[
\begin{aligned}
	{\sf w}({\sf indices}[i]) = &\ {\sf u}(i),
    \forall i : 0 \leq i < {\sf nindices}.
\end{aligned}
\]  
If a particular element ${\sf u}(i)$ does not exist, the corresponding
element of {\sf w} is also removed. 
Elements of {\sf w} outside the range $({\sf indices}[i])$ are not affected.

Two argument vectors are used in the {\sf GrB\_assign} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),
    \bold{L}({\sf w}) = \{(i,w_i) \} \rangle$
    
	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),
    \bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

The argument vectors 
are tested for domain compatibility as follows:
\begin{enumerate}
	\item $\bold{D}({\sf w})$ must be compatible with $\bold{D}({\sf u})$.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends
and the domain mismatch error listed above is returned.

From the arguments, the internal index array used in 
the computation is formed ($\leftarrow$ denotes copy):
\begin{enumerate}
    \item The internal index array, $\grbarray{\widetilde{I}}$, is computed from 
    argument {\sf indices} as follows:
	\begin{enumerate}
		\item	If ${\sf indices} = {\sf GrB\_ALL}$, then 
        $\grbarray{\widetilde{I}}[i] = i, \forall i : 0 \leq i < {\sf nindices}$.

		\item	Otherwise, $\grbarray{\widetilde{I}}[i] = {\sf indices}[i], 
        \forall i : 0 \leq i < {\sf nindices}$.
    \end{enumerate}
\end{enumerate}

The vectors are checked for dimension compatibility. 
The following conditions must hold:
\begin{enumerate}
    \item ${\sf nindices} = \bold{size}(\vector{\widetilde{u}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the assign.
At this point, if any value of $\grbarray{\widetilde{I}}[i]$ is outside the valid 
range of indices for vector $\vector{\widetilde{w}}$, computation ends and the 
method returns the index-out-of-bounds error listed above. In 
{\sf GrB\_NONBLOCKING} mode, the error can be deferred until a 
sequence-terminating {\sf GrB\_wait()} is called.  Regardless, the result 
vector, {\sf w}, is invalid from this point forward in the 
sequence.

Executing the assign consists of updating the contents of vector {\sf w}
according to the following expression:
\[
	\bold{L}({\sf w}) = (\bold{L}({\sf w}) - \{(\grbarray{\widetilde{I}}[i],w) \forall i : \grbarray{\widetilde{I}}[i] \in \bold{ind}({\sf w})\})
	\cup \{(\grbarray{\widetilde{I}}[i],u_i) \forall i \in \bold{ind}({\sf u})\},
\]
where the difference operator in the previous expressions refers to set difference.
That is, first existing elements of {\sf w} with index in $\grbarray{\widetilde{I}}$ are removed,
and then the elements of {\sf u} are added in the right place.

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.

%-----------------------------------------------------------------------------

\subsubsection{{\sf Vector\_assign}: Constant vector variant}

Assign the same value to a specified subset of a GraphBLAS vector.  With the use of {\sf GrB\_ALL}, the 
entire destination vector can be filled with the constant.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_assign(GrB_Vector              w,
                                   <type>                  val,
                                   const GrB_Index        *indices,
                                   const GrB_Index         nindices);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}] ({\sf INOUT}) An existing GraphBLAS vector, that will
    be modified by the assign.  On output, this vector holds the results
    of the operation.

    \item[{\sf val}] ({\sf IN}) Scalar value to assign to (a subset of)
    {\sf w}.

    \item[{\sf indices}]  ({\sf IN}) Pointer to the ordered set (array)
    of indices corresponding to the locations in {\sf w} that are to
    be assigned.  If all elements of {\sf w} are to be assigned in
    order from $0$ to ${\sf nindices} - 1$, then {\sf GrB\_ALL} should
    be specified.  Regardless of execution mode and return value, this
    array may be manipulated by the caller after this operation returns
    without affecting any deferred computations for this operation.
    In this variant, the specific order of the values in the array has no
    effect on the result.  Unlike other variants, if there are duplicated
    values in this array the result is still defined.

    \item[{\sf nindices}] ({\sf IN}) The number of values in {\sf
    indices} array.  Must be in the range: $[0, \bold{size}({\sf w}))$.
    If {\sf nindices} is zero, the operation becomes a NO-OP.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]            Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf indices} is greater
    than or equal to $\bold{size}({\sf w})$.  In non-blocking mode, this can be
    reported as an execution error.
    
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] {\sf nindices} is not less than $\bold{size}({\sf w})$. 

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the vector and scalar are
	incompatible with each other.

    \item[{\sf GrB\_NULL\_POINTER}] Argument {\sf indices} is a {\sf NULL} pointer.
\end{itemize}


\paragraph{Description}

This variant of {\sf GrB\_assign} computes the result of assigning a constant
scalar value to locations in a destination GraphBLAS vector: 
\[
\begin{aligned}
	{\sf w}({\sf indices}[i]) = &\ {\sf val}, \ 
    \forall \  i : 0 \leq i < {\sf nindices}.
\end{aligned}
\]  

One argument vectors are used in the {\sf GrB\_assign} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),
    \bold{L}({\sf w}) = \{(i,w_i) \} \rangle$
\end{enumerate}

The argument scalar and vectors
are tested for domain compatibility as follows:
\begin{enumerate}
	\item $\bold{D}({\sf w})$ must be compatible with $\bold{D}({\sf val})$.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends
and the domain mismatch error listed above is returned.

From the arguments, the internal index array used in 
the computation is formed ($\leftarrow$ denotes copy):
\begin{enumerate}
    \item The internal index array, $\grbarray{\widetilde{I}}$, is computed from 
    argument {\sf indices} as follows:
	\begin{enumerate}
		\item	If ${\sf indices} = {\sf GrB\_ALL}$, then 
        $\grbarray{\widetilde{I}}[i] = i, \ \forall \ i : 0 \leq i < {\sf nindices}$.

		\item	Otherwise, $\grbarray{\widetilde{I}}[i] = {\sf indices}[i], 
        \ \forall \ i : 0 \leq i < {\sf nindices}$.
    \end{enumerate}
\end{enumerate}

If any compatibility rule above is violated, execution of {\sf GrB\_assign} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the assign.
At this point, if any value of $\grbarray{\widetilde{I}}[i]$ is outside the valid 
range of indices for vector $\vector{\widetilde{w}}$, computation ends and the 
method returns the index-out-of-bounds error listed above. In 
{\sf GrB\_NONBLOCKING} mode, the error can be deferred until a 
sequence-terminating {\sf GrB\_wait()} is called.  Regardless, the result 
vector, {\sf w}, is invalid from this point forward in the 
sequence.

Executing the assign consists of updating the contents of vector {\sf w}
according to the following expression:
\[
	\bold{L}({\sf w}) = (\bold{L}({\sf w}) - \{(\grbarray{\widetilde{I}}[i],w) \forall i : \grbarray{\widetilde{I}}[i] \in \bold{ind}({\sf w})\})
	\cup \{(\grbarray{\widetilde{I}}[i],{\sf val}) \forall i \in \bold{ind}({\sf u})\},
\]
where the difference operator in the previous expressions refers to set difference.
That is, first existing elements of {\sf w} with index in $\grbarray{\widetilde{I}}$ are removed,
and then elements with a value of {\sf val} are added in the right place.

In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.
