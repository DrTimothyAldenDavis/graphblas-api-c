\chapter{Basic Concepts}
\label{Chp:Concepts}

The GraphBLAS C API is used to construct  
graph algorithms expressed ``in the language of linear algebra''.
Graphs are expressed as matrices, and the operations over 
these matrices are generalized through the use of a
semiring algebraic structure.

In this chapter, we will define the basic concepts used to
define the GraphBLAS C API.  We provide the following elements:
\begin{itemize}
\item Glossary of terms used in this document.  

\item Algebraic structures and associated arithmetic foundations of the API.

\item Domains of  elements in the GraphBLAS.  

\item Functions that appear in the GraphBLAS algebraic 
structures and how they are managed.

\item Indices, index arrays, and scalar arrays used
to expose the contents of GraphBLAS objects.  

\item The execution and error models implied by the GraphBLAS C specification.

\end{itemize}

\section{Glossary}

\subsection{GraphBLAS API basic definitions}

\glossBegin

\glossItem{application} A program that calls methods from the GraphBLAS C API to
solve a problem.

\glossItem{GraphBLAS C API} The application programming interface that fully defines the types, objects, 
literals, and other elements of the C binding to the GraphBLAS.

\glossItem{function} Refers to a named group of statements in the C programming language.  Methods, operators,
and user-defined functions are typically implemented as C functions
 and when referring to 
the code programmers write, as opposed to the role of functions as an element of the GraphBLAS, they may
be referred to as such.

\glossItem{method} A function defined in the GraphBLAS C API that manipulates
GraphBLAS objects or other opaque features of the implementation of the GraphBLAS API.

\glossItem{operator} A function that performs an operation on the elements stored in GraphBLAS matrices and vectors.

\glossItem{GraphBLAS operation} A mathematical operation defined in the
GraphBLAS mathematical specification. These operations (not to be confused with \emph{operators}) typically act
on matrices and vectors with elements defined in terms of an algebraic semiring. 
\glossEnd

\subsection{GraphBLAS objects and their structure}

\glossBegin
\glossItem{GraphBLAS object}  An instance of a data type defined by the GraphBLAS C
API that is opaque and manipulated only through the API. There are three groups of 
GraphBLAS objects: \emph{algebraic objects} (operators, monoids and semirings), 
\emph{collections} (vectors, matrices and masks), and descriptors.   Because the object
is based on an opaque datatype, an implementation of the GraphBLAS C API has the
flexibility to optimize data structures for a particular platform.  GraphBLAS objects
are often implemented as sparse data structures, meaning only the subset of the
elements that have non-zero values are stored.

\glossItem{handle}  A variable that uses one of the GraphBLAS opaque data types.
The value of this variable holds a reference to a GraphBLAS object but not the contents of object itself.  
Hence, assigning a value of one handle to another variable copies the reference to the GraphBLAS object
but not the contents of the object.

\glossItem{non-opaque datatype} Any datatype that exposes its internal structure.   
This is contrasted
with an \emph{opaque datatype} that hides its internal structure and can
be manipulated only through an API.

\glossItem{domain} The set of valid values for the elements of a GraphBLAS object.
Note that some GraphBLAS objects involve functions that map values from one or more input domains 
onto values in an output domain.  These GraphBLAS objects would have multiple domains.

\glossItem{structural zero}  Any element that has a valid index (or indices) 
in a GraphBLAS vector or matrix but is not explicitly identified in the list of 
elements of that vector or matrix.  Also known as an \emph{implied zero}.  From 
a mathematical perspective, a \emph{structural zero} is treated as having the 
value of the zero element of the relevant monoid or semiring.

\glossItem{mask} An internal GraphBLAS object used to control how values 
are stored in a method's output object.  The mask exists only inside a method; hence,
it is called an \emph{internal opaque object}.  A mask is formed from the elements of
a collection object (vector or matrix) input as a mask parameter to a method. There
are two different operations for forming the internal mask.  The default 
behavior is that an element of the mask exists for each element that exists in the 
input collection object when the value of that element cast to a Boolean type evaluates to 
{\tt true}.  Alternatively, the input collection could describe a structure whereby an 
element of the mask exists for each element of the input collection regardless of its value.
Masks have structure but no values. That is,
while a tuple for a vector or matrix has indices and values,  tuples within a mask
have indices but not values. Instead, we say that the tuples that exist within a mask
have implied values of {\tt true}, and the tuples that do not exist within the mask have 
implied values of {\tt false}. 
\scott{STRUCTURE changes.}

\glossItem{structural complement} Operation on a mask where stored elements become
{\it structural zeros} and vice versa.  The \emph{structural complement} of a 
GraphBLAS mask, $M$, is another mask, $M'$, where the elements of $M'$
are those elements from $M$ that \emph{do not} exist.  In other words, 
elements of $M$ with implied value {\tt true} are {\tt false} in $M'$
while the structural zeros of $M$ with implied values {\tt false} 
are {\tt true} in $M'$.


%\glossItem{structural complement} The \emph{structural complement} of a 
%GraphBLAS vector or matrix of any domain is another vector or matrix, 
%of domain {\tt bool}, in which the explicitly identified elements (with a value of {\tt true}) 
%are the \emph{structural zeroes} of the original vector or matrix 
%(which have an implied value of {\tt false}). 
\glossEnd



\subsection{Algebraic structures used in the GraphBLAS}

\glossBegin
\glossItem{GraphBLAS operators} Binary or unary operators that act on elements of GraphBLAS 
objects.  \emph{GraphBLAS operators} are used to express algebraic structures used in the 
GraphBLAS such as monoids and semirings. There are two types of \emph{GraphBLAS operators}: 
(1) predefined operators found in Table~\ref{Tab:PredefOperators} and (2) user-defined 
operators using {\sf GrB\_UnaryOp\_new()} or {\sf GrB\_BinaryOp\_new()} 
(see Section~\ref{Sec:AlgebraMethods}).

\glossItem{associative operator} In an expression where a binary operator is used 
two or more times consecutively, that operator is \emph{associative} if the result 
does not change regardless of the way operations are grouped (without changing their order) 
changes. In other words, in a sequence of binary operations using the same associative 
operator, the legal placement of parenthesis does not change the value resulting 
from the sequence operations.  Operators that are associative over infinitely 
precise numbers (e.g., real numbers) are not strictly associative when applied to 
numbers with finite precision (e.g., floating point numbers). Such non-associativity 
results, for example, from roundoff errors or from the fact some numbers can not 
be represented exactly as floating point numbers.   In the GraphBLAS specification, 
as is common practice in computing, we refer to operators as \emph{associative} 
when their mathematical definition over infinitely precise numbers is associative 
even when they are only approximately associative when applied to finite precision 
numbers.

\glossItem{monoid} An algebraic structure consisting of a domain, an associative 
binary operator, and an identity corresponding to that operator.  There are two types 
of \emph{GraphBLAS monoids}: (1) predefined monoids found in 
Table~\ref{Tab:PredefinedMonoids} and (2) user-defined monoids using 
{\sf GrB\_Monoid\_new()} (see Section~\ref{Sec:AlgebraMethods}). 

\glossItem{semiring} An algebraic structure consisting of a set of allowed values
(the \emph{domain}), two commutative binary operators called addition 
and multiplication (where multiplication distributes over addition),
and identities over addition (\emph{0}) and multiplication (\emph{1}).  The additive
identity is an annihilator over multiplication.   
Note that a \emph{GraphBLAS semiring} is allowed to diverge from the mathematically 
rigorous definition of a semiring since certain combinations of domains, operators, and identity 
elements are useful in graph algorithms even when they do not strictly match the mathematical
definition of a semiring.
%do we need to define "annihilator"?
There are two types 
of \emph{GraphBLAS semirings}: (1) predefined semirings found in 
Table~\ref{Tab:PredefinedSemirings} and (2) user-defined semirings using 
{\sf GrB\_Semiring\_new()} (see Section~\ref{Sec:AlgebraMethods}). 
\glossEnd



\subsection{The execution of an application using the GraphBLAS C API}
\glossBegin
\glossItem{program order} The order of the GraphBLAS methods as defined by the 
text of an application program.

\glossItem{sequence} A series of GraphBLAS method calls in program order.  
An implementation of the GraphBLAS may reorder or even fuse GraphBLAS methods within a 
sequence as long as the definitions of any GraphBLAS object that is later read by an application 
are not changed; by ``read'' we mean that values are copied from an opaque GraphBLAS 
object into a non-opaque object.  A sequence begins when a thread calls the first method that creates
or modifies a GraphBLAS object, either (1) the first call in an application or (2) the first call 
following termination of a prior sequence.  The only way to terminate a sequence within an 
application is with a call to the {\sf GrB\_wait()} method. 

%\glossItem{sequence} A sequence of GraphBLAS method calls that fully defines the value of 
%a GraphBLAS object.  The sequence for a particular GraphBLAS object is defined 
%by a series of GraphBLAS method calls in program order that: (1) \emph{begins} with 
%the first GraphBLAS method that creates or modifies the GraphBLAS object; 
%and (2) \emph{terminates} with a GraphBLAS method that explicitly waits for the series of 
%methods to complete or the first method that reads values from the GraphBLAS 
%object and writes them into a non-opaque object.

\glossItem{complete} The state of a GraphBLAS object when the computations that 
implement the mathematical definition of the object have finished and the values 
associated with that object are available to any method that would load them 
into a non-opaque data structure.   
A GraphBLAS object is fully defined by the sequence of methods.   
The execution of a sequence may be deferred, however, so at any point 
in an application, a GraphBLAS object may not be materialized; that is, 
the values associated with a particular GraphBLAS object may not have 
been computed and stored in memory.   Essentially, methods that extract elements 
from an opaque object and copy them into a non-opaque object force completion of the
opaque object. 

\glossItem{materialize} Cause the values associated with that object to be resident 
in memory and visible to an application.  A GraphBLAS object has been 
\emph{materialized} when the computations that implement the mathematical definition 
of the object are {\it complete}. 
A GraphBLAS object that is never loaded into a non-opaque data structure may 
potentially never be materialized.  This might happen, for  example, should the operations 
associated with the object be fused or otherwise changed by the runtime system 
that supports the implementation of the GraphBLAS C API.   

\glossItem{context}  An instance of the GraphBLAS C API implementation
as seen by an application.  An application can have only one context between the 
start and end of the application.  
A context begins with the first thread that calls {\sf GrB\_init()} and ends with the 
first thread to call {\sf GrB\_finalize()}.  
It is an error for {\sf GrB\_init()} or {\sf GrB\_finalize()} to be called more than one
time within an application.  The context is used to constrain the behavior of an
instance of the GraphBLAS C API implementation and support various execution strategies.
Currently, the only
supported constraints on a context pertain to the mode of program execution.

\glossItem{mode} Defines how a GraphBLAS sequence executes, and is associated 
with the {\it context} of a GraphBLAS C API implementation. It is set by an 
application with its call to {\sf GrB\_init()} to one of two possible states.  
In \emph{blocking mode}, GraphBLAS methods return after the computations 
complete and any output objects have been updated.  In {\it nonblocking mode}, a 
method may return once the arguments are tested as consistent with 
the method (\ie, there are no API errors), and potentially before any computation 
has taken place.
\glossEnd

\subsection{GraphBLAS methods: behaviors and error conditions}
\glossBegin
\glossItem{implementation defined behavior} Behavior that must be documented
by the implementation and is allowed to vary among different
compliant implementations. 

\glossItem{undefined behavior} Behavior that is not specified by the GraphBLAS C API.
A conforming implementation is free to choose results delivered from a method
whose behavior is undefined. 

\glossItem{thread safe routine} A routine that performs its intended 
function even when executed concurrently (by more than one thread).

\glossItem{shape compatible objects} GraphBLAS objects (matrices and vectors) 
passed as parameters to a GraphBLAS method that have the correct number of dimensions 
and sizes for each dimension to satisfy the rules of the mathematical definition 
of the operation associated with the method.  This is also referred to as 
\emph{dimension compatible}.

\glossItem{domain compatible} Two domains for which values from one domain can be 
cast to values in the other domain as per the rules of the C language. In particular, 
domains from Table~\ref{Tab:PredefinedTypes} 
are all compatible with each other, and a domain from a user-defined type is only 
compatible with itself. If any \emph{domain compatibility} rule above is 
violated, execution of GraphBLAS method ends and the domain 
mismatch error {\sf GrB\_DOMAIN\_MISMATCH} is returned.
\glossEnd

\vfill

\newgeometry{left=2.5cm,top=2cm,bottom=2cm}

\section{Notation}

\begin{tabular}[H]{l|p{5in}}
Notation & Description \\
\hline
$\Dout, \Dinn, \Din1, \Din2$  & Refers to output and input domains of various GraphBLAS operators. \\
$\bDout(*), \bDinn(*),$ & Evaluates to output and input domains of GraphBLAS operators (usually \\
~~~~$\bDin1(*), \bDin2(*)$ & a unary or binary operator, or semiring). \\
$\mathbf{D}(*)$   & Evaluates to the (only) domain of a GraphBLAS object (usually a monoid, vector, or matrix). \\ 
$f$             & An arbitrary unary function, usually a component of a unary operator. \\
$\mathbf{f}(F_u)$ & Evaluates to the unary function contained in the unary operator given as the argument. \\
$\odot$         & An arbitrary binary function, usually a component of a binary operator. \\
$\mathbf{\bigodot}(*)$ & Evaluates to the binary function contained in the binary operator or monoid given as the argument. \\
$\otimes$       & Multiplicative binary operator of a semiring. \\
$\oplus$        & Additive binary operator of a semiring. \\
$\mathbf{\bigotimes}(S)$ & Evaluates to the multiplicative binary operator of the semiring given as the argument. \\
$\mathbf{\bigoplus}(S)$ & Evaluates to the additive binary operator of the semiring given as the argument. \\
$\mathbf{0}(*)$   & The identity of a monoid, or the additive identity of a GraphBLAS semiring. \\
$\mathbf{L}(*)$   & The contents (all stored values) of the vector or matrix GraphBLAS objects.  For a vector, it is the set of (index, value) pairs, and for a matrix it is the set of (row, col, value) triples. \\
$\mathbf{v}(i)$ or $v_i$   & The $i^{th}$ element of the vector $\vector{v}$.\\
$\mathbf{size}(\vector{v})$ & The size of the vector $\vector{v}$.\\
$\mathbf{ind}(\vector{v})$ & The set of indices corresponding to the stored values of the vector $\vector{v}$.\\
$\mathbf{nrows}(\vector{A})$ & The number of rows in the $\matrix{A}$.\\
$\mathbf{ncols}(\vector{A})$ & The number of columns in the $\matrix{A}$.\\
$\mathbf{indrow}(\vector{A})$ & The set of row indices corresponding to rows in $\matrix{A}$ that have stored values.  \\
$\mathbf{indcol}(\vector{A})$ & The set of column indices corresponding to columns in $\matrix{A}$ that have stored values. \\
$\mathbf{ind}(\vector{A})$ & The set of $(i,j)$ indices corresponding to the stored values of the matrix. \\
$\mathbf{A}(i,j)$ or $A_{ij}$ & The element of $\matrix{A}$ with row index $i$ and column index $j$.\\
$\matrix{A}(:,j)$ & The $j^{th}$ column of the the matrix $\matrix{A}$.\\
$\matrix{A}(i,:)$ & The $i^{th}$ row of the the matrix $\matrix{A}$.\\
$\matrix{A}^T$ &The transpose of the matrix $\matrix{A}$. \\
$\neg\matrix{M}$ & The structural complement of $\matrix{M}$.\\
$\vector{\widetilde{t}}$ & A temporary object created  by the GraphBLAS implementation. \\
$<type>$ & A method argument type that is {\sf void *} or one of the types from Table~\ref{Tab:PredefinedTypes}. \\
{\sf GrB\_ALL} & A method argument literal to indicate that all indices of an input array should be used.\\
{\sf GrB\_Type} & A method argument type that is either a user defined type or one of the  types from Table~\ref{Tab:PredefinedTypes}.\\
{\sf GrB\_Object} &  A method argument type referencing any of the GraphBLAS object types.\\
{\sf GrB\_NULL} & The GraphBLAS NULL.\\
\end{tabular}

\restoregeometry


\section{Algebraic and Arithmetic Foundations}

Graphs can be represented in terms of matrices. Operations defined by the GraphBLAS standard
operate on these matrices to construct graph algorithms.
These GraphBLAS operations are defined in terms of GraphBLAS semiring algebraic 
structures. Modifying the underlying semiring changes the result of 
an operation to support a wide range of graph algorithms.

Inside a given algorithm, it is often beneficial to change the GraphBLAS semiring
that applies to an operation on a matrix.  This has two 
implications on the C binding to the GraphBLAS.  First,
it means that we define a separate object for the semiring 
to pass into functions.  Since in many cases the full
semiring is not required, we also support passing monoids or
even binary operators, which means the semiring is implied rather than 
explicitly stated.

Second, the ability to change semirings impacts the meaning of 
the \emph{implied zero} in a sparse representation of a matrix.
This element in real arithmetic is zero, which is the 
identity of the \emph{addition} operator and the annihilator of the
\emph{multiplication} operator.   As the semiring changes, this 
\emph{implied} or \emph{structural zero} changes to the identity of 
the \emph{addition} operator and the annihilator of the \emph{multiplication} 
operator for the new semiring.   Nothing changes in the
stored matrix, but the implied values within the sparse matrix change
with respect to a particular operation.  In most cases, the nature
of the implied zero does not matter since the GraphBLAS treats these
as elements of the matrix that do not exist.  As we will see, however,
there is a small subset of GraphBLAS methods 
(the element-wise operations) where to understand 
the method you need to understand the implied zero.

The mathematical formalism for graph operations in the language of 
linear algebra assumes that we can operate in the field of real numbers. 
However, the GraphBLAS C binding is designed for implementation on computers, 
which by necessity have a finite number of bits to represent numbers. 
Therefore, we require a conforming implementation to use floating point 
numbers such as those defined by the IEEE-754 standard (both single- and double-precision) 
wherever real numbers need to be represented. The practical implications of 
these finite precision numbers is that the result of a sequence of 
computations may vary from one execution to the next as the association 
of operations changes.  While techniques are known to 
reduce these effects, we do not require or even expect an implementation 
to use them as they may add considerable overhead. The fact is that in most 
cases, these roundoff errors are not significant, and when they are significant, 
the problem itself is ill-conditioned and needs to be reformulated.

\section{GraphBLAS Opaque Objects}

Objects defined in the GraphBLAS standard include collections of elements
(matrices and vectors), operators on those elements (unary and binary operators), and 
algebraic structures (semirings and monoids).   GraphBLAS objects are defined
as opaque types; that is, they are managed, manipulated, and accessed solely through the
GraphBLAS application programming interface. This gives an implementation of the
GraphBLAS C specification flexibility to optimize objects for different scenarios or to meet
the needs of different hardware platforms.

A GraphBLAS opaque object is accessed through its handle.  A handle
is a variable that uses one of the types from Table~\ref{Tab:ObjTypes}.  An implementation 
of the GraphBLAS specification has a great deal of flexibility in how these
handles are implemented.  All that is required is that the handle corresponds to a type defined in the 
C language that supports assignment and comparison for equality.  The
GraphBLAS specification defines a 
literal {\sf GrB\_INVALID\_HANDLE} that is valid for each type.  Using the logical equality 
operator from C, it must be possible to compare a handle to {\sf GrB\_INVALID\_HANDLE}
to verify that a handle is valid.


\begin{table}
\hrule
\begin{center}
\caption{GraphBLAS opaque objects and their types.}
\label{Tab:ObjTypes}
~\\
\begin{tabular}{l|l}
{\sf GrB\_Object types} & Description \\
\hline
{\sf GrB\_Type}           & User-defined scalar type.     \\
{\sf GrB\_UnaryOp}        & Unary operator, built-in or associated with a single-argument C function.     \\
{\sf GrB\_BinaryOp}       & Binary operator, built-in or associated with a two-argument C function.     \\
{\sf GrB\_Monoid}         & Monoid algebraic structure.     \\
{\sf GrB\_Semiring}       & A GraphBLAS semiring algebraic structure.     \\
{\sf GrB\_Matrix}         & Two-dimensional collection of elements; typically sparse.    \\
{\sf GrB\_Vector}         & One-dimensional collection of elements.     \\
{\sf GrB\_Descriptor}     & Descriptor object, used to modify behavior of methods.     \\
\end{tabular}
\end{center}
\hrule
\end{table}

An application using the GraphBLAS API will declare variables of the appropriate
type for the objects it will use.  Before use, the object must be initialized with 
the appropriate method.  This is done with one of the methods that has a ``{\sf \_new}'' suffix in its 
name (e.g., {\sf GrB\_Vector\_new}).  Alternatively, an object can be initialized by duplicating
an existing object with one of the methods that has the ``{\sf \_dup}'' suffix in its 
name  (e.g., {\sf GrB\_Vector\_dup}).   When an application is finished with 
an object, any resources associated with that object can be released by a
call to the {\sf GrB\_free} method.    

These {\sf new}, {\sf dup}, and {\sf free} methods are the only methods that 
change the value of a handle.  Hence, objects changed by these methods are passed
into the method as pointers.  In all other cases, handles are not changed by the 
method and are passed by value.  For example, even when multiplying matrices, 
while the contents of the output product matrix changes, the handle for that matrix is unchanged. 

Programmers using GraphBLAS handles must be careful to distinguish between a handle and the 
object manipulated through a handle.  For example, a program may declare two 
GraphBLAS objects of the same type, initialize one, and then assign it to the other
variable.  That assignment, however, only assigns the handle to the variable.  It does not 
create a copy of that variable (to do that, one would need to use the appropriate duplication method).
If later the object is freed by calling {\sf GrB\_free} with the first variable, the object
is destroyed and the second variable is left referencing an object that no longer 
exists (a so called ``dangling handle'').

In addition to opaque objects manipulated through handles, the GraphBLAS C API defines
an additional opaque object as an internal object; that is, the object is never exposed as
a variable within an application.  This opaque object is the mask used to
control how computed values are stored in the output from a method.  Masks 
are described in section~\ref{Sec:Masks}.

\section{Domains}

GraphBLAS defines two kinds of collections: matrices and vectors.
For any given collection, the elements of the collection belong to
a \emph{domain}, which is the set of valid values for the elements.
In GraphBLAS, domains correspond to the valid values for types from
the host language (in our case, the C programming language).  For any
variable or object $V$ in GraphBLAS we denote as $\mathbf{D}(V)$ the
domain of $V$, that is, the set of possible values that elements of
$V$ can take.  The predefined types and corresponding domains used in the 
GraphBLAS are shown in Table~\ref{Tab:PredefinedTypes}.  The Boolean
type is defined in {\tt stdbool.h}, the integral types are defined in
{\tt stdint.h}, and the floating point types are native to the language
and in most cases defined by the IEEE-754 standard.


\begin{table}
\hrule
\begin{center}
\caption{Predefined {\sf GrB\_Type} values, the corresponding C type (for scalar
parameters), and domains for GraphBLAS.}
\label{Tab:PredefinedTypes}
\begin{tabular}{l|l|l}
{\sf GrB\_Type values} & C type            & domain \\
\hline
{\sf GrB\_BOOL}        & {\tt bool}        & $\{ {\tt false}, {\tt true} \}$  \\
{\sf GrB\_INT8}        & {\tt int8\_t}     & $\mathbb{Z} \cap [-2^{7},2^{7})$  \\
{\sf GrB\_UINT8}       & {\tt uint8\_t}    & $\mathbb{Z} \cap [0,2{^8})$  \\
{\sf GrB\_INT16}       & {\tt int16\_t}    & $\mathbb{Z} \cap [-2^{15},2^{15})$ \\
{\sf GrB\_UINT16}      & {\tt uint16\_t}   & $\mathbb{Z} \cap [0,2^{16})$ \\
{\sf GrB\_INT32}       & {\tt int32\_t}    & $\mathbb{Z} \cap [-2^{31},2^{31})$ \\
{\sf GrB\_UINT32}      & {\tt uint32\_t}   & $\mathbb{Z} \cap [0,2^{32})$ \\
{\sf GrB\_INT64}       & {\tt int64\_t}    & $\mathbb{Z} \cap [-2^{63},2^{63})$ \\
{\sf GrB\_UINT64}      & {\tt uint64\_t}   & $\mathbb{Z} \cap [0,2^{64})$ \\
{\sf GrB\_FP32}        & {\tt float}       & IEEE 754 {\sf binary32}  \\
{\sf GrB\_FP64}        & {\tt double}      & IEEE 754 {\sf binary64}  \\
\end{tabular}
\end{center}
\hrule
\end{table}

\section{Operators and Associated Functions}

GraphBLAS operators act on elements of GraphBLAS objects.   A
 \emph{binary operator} is a function that maps two input
values to one output value. A \emph{unary operator} is a function that 
maps one input value to one output value. The value of the output is 
determined by the value of the input(s).  Binary operators are defined over 
two input domains and produce an output from a (possibly different) third 
domain. Unary operators are specified over one input domain and produce an 
output from a (possibly different) second domain.

Similar to GraphBLAS types with predefined types and user-defined types, 
GraphBLAS operators come in two types: (1) predefined operators 
found in Table~\ref{Tab:PredefOperators} and (2) user-defined operators 
using {\sf GrB\_UnaryOp\_new()} or {\sf GrB\_BinaryOp\_new()} (see 
Section~\ref{Sec:AlgebraMethods}).  Likewise, a list of predefined monoids and 
semirings can be found in Tables~\ref{Tab:PredefinedMonoids} 
and~\ref{Tab:PredefinedSemirings}, respectively.

%====================

\begin{table}
\hrule
\begin{center}
\caption{Valid GraphBLAS domain suffixes and corresponding C types (for $T$ in 
Tables~\ref{Tab:PredefOperators}, \ref{Tab:PredefinedMonoids}, 
and~\ref{Tab:PredefinedSemirings}).}
\label{Tab:PredefineDomains}

\vspace{1\baselineskip}

\begin{tabular}{l|l}
Suffix			& C type \\ \hline
{\sf BOOL}		& {\tt bool} \\
{\sf INT8}		& {\tt int8\_t} \\
{\sf UINT8}		& {\tt uint8\_t} \\
{\sf INT16}		& {\tt int16\_t} \\
{\sf UINT16}	& {\tt uint16\_t} \\
{\sf INT32}		& {\tt int32\_t} \\
{\sf UINT32}	& {\tt uint32\_t} \\
{\sf INT64}		& {\tt int64\_t} \\
{\sf UINT64}	& {\tt uint64\_t} \\
{\sf FP32}		& {\tt float} \\
{\sf FP64}		& {\tt double} \\
\end{tabular}
\end{center}
\hrule
\end{table}

%====================

\begin{table}
\hrule
\begin{center}
\caption{Predefined unary and binary operators for GraphBLAS in C.}
\label{Tab:PredefOperators}
\vspace{1\baselineskip}

\hspace*{-3em}
\begin{tabular}{l|l|l|ll}
Operator & GraphBLAS             &                                                              & \\
type     & identifier            & Domains                                              & Description \\ \hline
{\sf GrB\_UnaryOp}    & {\sf GrB\_IDENTITY\_$T$} & $T \rightarrow T $     & $f(x) = x$, &identity \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_ABS\_$T$}      & $T \rightarrow T $     & $f(x) = |x|$, &absolute value \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_AINV\_$T$}     & $T \rightarrow T $     & $f(x) = -x$, &additive inverse \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_MINV\_$T$}     & $T \rightarrow T $     & $f(x) = \frac{1}{x}$, &multiplicative inverse \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_LNOT}          & ${\tt bool} \rightarrow {\tt bool}$  & $f(x) =~\neg x$, &logical inverse  \\

&&&\\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LOR}        & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$ & $f(x,y) = x \lor y$, & logical OR \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LAND}       & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$ & $f(x,y) = x \land y$, & logical AND \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LXOR}       & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$ & $f(x,y) = x \oplus y$, & logical XOR \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LXNOR}      & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$ & $f(x,y) = \overline{x \oplus y}$, & logical XNOR \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_EQ\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x == y)$ & equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_NE\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x \neq y)$ & not equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_GT\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x > y)$ & greater than  \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LT\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x < y)$ & less than  \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_GE\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x \geq y)$ & greater than or equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LE\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x \leq y)$ & less than or equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_FIRST\_$T$} & $T \times T \rightarrow T$  & $f(x,y) = x$, & first argument \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_SECOND\_$T$}& $T \times T \rightarrow T$  & $f(x,y) = y$, & second argument \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_MIN\_$T$}   & $T \times T \rightarrow T$  & $f(x,y) = (x < y)~?~x : y$, & minimum \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_MAX\_$T$}   & $T \times T \rightarrow T$  & $f(x,y) = (x > y)~?~x : y$, & maximum \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_ANY\_$T$}   & $T \times T \rightarrow T$  & $f(x,y) = $ either $x$ or $y$, & any\scott{MORE INFO NEEDED} \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_PLUS\_$T$}  & $T \times T \rightarrow T$  & $f(x,y) = x + y$, & addition \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_MINUS\_$T$} & $T \times T \rightarrow T$  & $f(x,y) = x - y$, & subtraction \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_TIMES\_$T$} & $T \times T \rightarrow T$  & $f(x,y) = xy$, & multiplication \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_DIV\_$T$}   & $T \times T \rightarrow T$  & $f(x,y) = \frac{x}{y}$, & division \\
\end{tabular}
\end{center}
\hrule
\end{table}

%==================

\begin{table}
\hrule
\begin{center}
\caption{Predefined monoids for GraphBLAS in C.\scott{We need to decide what takes the place of +/- infinity identities for domains that aren't supported in C. The only place we need to expose this implementation detail is in reduce to scalar, I think.  We need to decide about two boolean monoids for NE and EQ.  We can do LXOR for one. I have added LXNOR to the table of binary operators for the other.}}
\label{Tab:PredefinedMonoids}
\vspace{1\baselineskip}

\begin{tabular}{l|l|l|ll}
GraphBLAS					    & Domains, $T$           &               & \\
identifier		         & ($T \times T \rightarrow T$) & Identity      & Description \\ \hline
{\sf GrB\_PLUS\_MONOID\_T}		& {\sf UINTx}  & 0               & addition \\
                                & {\sf INTx}   & 0    & \\
                                & {\sf FPx}    & 0    & \\
{\sf GrB\_TIMES\_MONOID\_T}		& {\sf INTxx}  & 1             & multiplication \\
                                & {\sf INTx}   & 1    & \\
                                & {\sf FPx}    & 1    & \\
{\sf GrB\_MIN\_MONOID\_T}		& {\sf UINTx}  & ``$+\infty$"    & minimum \\
                                & {\sf INTx}   & ``$+\infty$"    & \\
                                & {\sf FPx}    & ``$+\infty$"    & \\
{\sf GrB\_MAX\_MONOID\_T}		& {\sf UINTx}  & 0               & maximum \\
                                & {\sf INTx}   & ``$-\infty$"    & \\
                                & {\sf FPx}    & ``$-\infty$"    & \\ 
                                & & & \\
{\sf GrB\_ANY\_MONOID\_T}		& $T$    & (implicit)    & either input \scott{MORE DETAIL NEEDED}\\
                                & & & \\
{\sf GrB\_LOR\_MONOID\_BOOL}	& {\sf BOOL}            & {\tt false}   & logical OR \\
{\sf GrB\_LAND\_MONOID\_BOOL}	& {\sf BOOL}            & {\tt true}    & logical AND \\
{\sf GrB\_LXNOR\_MONOID\_BOOL}	& {\sf BOOL}            & {\tt true}    & logical XNOR (equal) \\
{\sf GrB\_LXOR\_MONOID\_BOOL}	& {\sf BOOL}            & {\tt false}   & logical XOR (not equal) \\
\end{tabular}
\end{center}
\hrule
\end{table}

%==================

\begin{table}
\hrule
\begin{center}
\caption{Predefined semirings for GraphBLAS in C. \scott{Same issue with infinity as with monoids.}}
\label{Tab:PredefinedSemirings}
\vspace{1\baselineskip}

(a) "true" semirings where the additive identity is the same as the multiplicative annihilator.
\hspace*{-1.5em}
\begin{tabular}{l|l|l|ll}
GraphBLAS                   & Domains, $T$                  & $+$ identity          & \\
identifier                  & ($T \times T \rightarrow T$)  & $\times$ annihilator   & Description \\ \hline

{\sf GrB\_PLUS\_TIMES\_SEMIRING\_T} & {\sf UINTx} & 0             & arithmetic semiring \\
                                    & {\sf INTx}  & 0             & \\
                                    & {\sf FPx}   & 0             & \\
{\sf GrB\_MIN\_PLUS\_SEMIRING\_T}   & {\sf UINTx} & ``$+\infty$"  & min-plus semiring \\
                                    & {\sf INTx}  & ``$+\infty$"  & \\
                                    & {\sf FPx}   & ``$+\infty$"  & \\
{\sf GrB\_MAX\_PLUS\_SEMIRING\_T}   & {\sf INTx}  & ``$-\infty$"  & max-plus semiring \\
                                    & {\sf UINTx} & ``$-\infty$?" & (not sure UINTx is possible) \\
                                    & {\sf FPx}   & ``$-\infty$"  &  \\
{\sf GrB\_MIN\_TIMES\_SEMIRING\_T}  & {\sf UINTx} & ``$+\infty$"  & min-times semiring \\
                                    & {\sf INTx}  & ``$+\infty$"  & \\
                                    & {\sf FPx}   & ``$+\infty$"  &  \\
{\sf GrB\_MIN\_MAX\_SEMIRING\_T}    & {\sf UINTx} & ``$+\infty$"  & min-max semiring \\
                                    & {\sf INTx}  & ``$+\infty$"  & \\
                                    & {\sf FPx}   & ``$+\infty$"  & \\
{\sf GrB\_MAX\_MIN\_SEMIRING\_T}    & {\sf UINTx} & 0             & max-min semiring \\
                                    & {\sf INTx}  & ``$-\infty$"  & \\
                                    & {\sf FPx}   & ``$-\infty$"  & \\
{\sf GrB\_MAX\_TIMES\_SEMIRING\_T}  & {\sf UINTx} & 0             & max-times semiring \\
                                    & {\sf INTx}  & 0             & (non-negative range only) \\
                                    & {\sf FPx}   & 0             & (non-negative range only) \\
{\sf GrB\_PLUS\_MIN\_SEMIRING\_T}   & {\sf UINTx} & 0             & plus-min semiring  \\
                                    & {\sf INTx}  & 0             & (non-negative range only) \\ 
                                    & {\sf FPx}   & 0             & (non-negative range only) \\ 
                                    & & & \\
{\sf GrB\_LOR\_LAND\_SEMIRING\_BOOL}  & {\sf BOOL} & {\tt false}   & Logical semiring \\
{\sf GrB\_LAND\_LOR\_SEMIRING\_BOOL}  & {\sf BOOL} & {\tt true}    & Is there a name for this? \\
{\sf GrB\_LXOR\_LAND\_SEMIRING\_BOOL} & {\sf BOOL} & {\tt false}   & same as NEQ\_LAND \\
{\sf GrB\_LXNOR\_LOR\_SEMIRING\_BOOL} & {\sf BOOL} & {\tt true}    & Is there a name for this? \\
\end{tabular}
\vspace{1\baselineskip}

(b) Other useful GraphBLAS semirings (that don't have a multiplicative annihilator)
\vspace{1\baselineskip}

\begin{tabular}{l|l|l|ll}
GraphBLAS                   & Domains, $T$                  &               & \\
identifier                  & ($T \times T \rightarrow T$)  & $+$ identity  & Description \\ \hline
{\sf GrB\_MIN\_FIRST\_SEMIRING\_T}    & ? & ``$+\infty$"    & min-select first  semiring \\
{\sf GrB\_MIN\_SECOND\_SEMIRING\_T}   & ? & ``$+\infty$"    & min-select second semiring \\
{\sf GrB\_MAX\_FIRST\_SEMIRING\_T}    & ? & ``$-\infty$",0  & max-select first semiring \\
{\sf GrB\_MAX\_SECOND\_SEMIRING\_T}   & ? & ``$-\infty$",0  & max-select second semiring \\
{\sf GrB\_ANY\_FIRST\_SEMIRING\_T}    & ? & (implicit?)     & any-select first semiring \\
{\sf GrB\_ANY\_SECOND\_SEMIRING\_T}   & ? & (implicit?)     & any-select second semiring \\
\end{tabular}

\end{center}
\hrule
\end{table}

% ========================================================================
\section{Indices, Index Arrays, and Scalar Arrays}

In order to interface with third-party software (\ie, software other than
an implementation of the GraphBLAS), operations 
such as {\sf GrB\_Matrix\_build} (\S~\ref{Sec:Matrix_build}) and
{\sf GrB\_Matrix\_extractTuples} (\S~\ref{Sec:Matrix_extractTuples}) must specify
how the data should be laid out in  non-opaque data structures.  To 
this end we explicitly define the types for indices and the arrays 
used by these operations.

For indices a {\sf typedef} is used to give a GraphBLAS name to a concrete type. We define it as follows:

\begin{verbatim}
    typedef uint64_t GrB_Index;
\end{verbatim}

An index array is a pointer to a set of {\sf GrB\_Index} values that are 
stored in a contiguous block of memory (\ie, {\sf GrB\_Index*}).
Likewise, a scalar array is a pointer to a contiguous block of memory 
storing a number of scalar values as specified by the user.
Some GraphBLAS operations (\eg, {\sf GrB\_assign})  include an input parameter with the type of an index array. 
This input index array selects a subset of elements from a GraphBLAS vector object to be used in the operation.
In these cases, the literal {\sf GrB\_ALL} 
can be used in place of the index array input parameter to indicate that all indices 
of the associated GraphBLAS vector object should be used.
As with any literal defined in the GraphBLAS, an implementation of the GraphBLAS C API has considerable 
freedom in terms of how {\sf GrB\_ALL} is defined.  Since it is used as an argument for an array 
parameter, {\sf GrB\_ALL} must use a type consistent with a pointer, and it must have a non-null
value so it can be distinguished from the erroneous case of passing a NULL pointer as an array.

\section{Execution Model}
\label{Sec:ExecutionModel}

A program using the GraphBLAS C API constructs GraphBLAS objects,
manipulates them to implement a graph algorithm, and then extracts
values from the GraphBLAS objects as the result of the algorithm.
Functions defined within the GraphBLAS C API that manipulate GraphBLAS
objects are called \emph{methods}.  If the method corresponds to one
of the operations defined in the GraphBLAS mathematical specification,
we refer to the method as an \emph{operation}.

Graph algorithms are expressed as an ordered collection of GraphBLAS
method calls defined by the order they are encountered in a program.
This is called the \emph{program order}.  Each method in the collection
uniquely and unambiguously defines the output GraphBLAS objects based
on the GraphBLAS operation and the input GraphBLAS objects. This is the case as long
as there are no execution errors, which can put objects in an
invalid state (see \S~\ref{Sec:ErrorModel}).

The GraphBLAS method calls in program order are organized into 
contiguous and nonoverlapping \emph{sequences}.  A sequence is an
ordered collection of method calls as encountered by an executing thread. (For more
on threads and GraphBLAS, see \S~\ref{Sec:ThreadSafety}.)  A sequence
begins with either (i) the first GraphBLAS method called by a thread, or
(ii) the first method called by a thread after the end of the previous
sequence. A sequence always ends (terminates) with a call to the GraphBLAS
{\sf GrB\_wait()} method.

The GraphBLAS objects are fully defined at any point in a sequence by the
methods in the sequence as long as there are no execution errors.
In particular, as soon as a GraphBLAS
method call returns, its output can be used in the next GraphBLAS
method call.  However, individual operations in a sequence may not
be \emph{complete}. We say that an operation is complete when all the
computations in the operation have finished and all the values of its
output object have been produced and committed to the address 
space of the program.

The opaqueness of GraphBLAS objects allows execution to proceed
from one method to the next even when operations are not complete.
Processing of nonopaque objects is never deferred in GraphBLAS. That is,
methods that consume nonopaque objects (\eg, {\sf GrB\_Matrix\_build},
\S~\ref{Sec:Matrix_build}()) and methods that produce nonopaque objects (\eg,
{\sf GrB\_Matrix\_extractTuples()}, \S~\ref{Sec:Matrix_extractTuples})
always finish consuming or producing those nonopaque objects before
returning.   Furthermore, methods that extract values from opaque GraphBLAS objects
into nonopaque user objects (see Table~\ref{Tab:ExtractMethods})
always force completion of all pending computations on the 
corresponding GraphBLAS source object.

\begin{table}[htb]
	\hrule
	\begin{center}
		\caption{Methods that extract values from a GraphBLAS object, thereby
		forcing completion of the operations contributing to that particular object.}
		\label{Tab:ExtractMethods}

		\begin{tabular}{l|l}
			Method	& Section \\ \hline

			{\sf GrB\_Vector\_nvals}		& \ref{Sec:Vector_nvals}		\\
			{\sf GrB\_Vector\_extractElement} 	& \ref{Sec:extract_single_element_vec}	\\
			{\sf GrB\_Vector\_extractTuples}	& \ref{Sec:Vector_extractTuples}	\\
			{\sf GrB\_Matrix\_nvals}		& \ref{Sec:Matrix_nvals}		\\
			{\sf GrB\_Matrix\_extractElement} 	& \ref{Sec:extract_single_element_mat}	\\
			{\sf GrB\_Matrix\_extractTuples}	& \ref{Sec:Matrix_extractTuples}	\\
			{\sf GrB\_reduce} (vector-scalar variant)		& \ref{Sec:Reduce_vector_scalar}		\\
			{\sf GrB\_reduce} (matrix-scalar variant)		& \ref{Sec:Reduce_matrix_scalar}		\\
		\end{tabular}
	\end{center}
	\hrule
\end{table}

\subsection{Execution modes}

The execution model
implied by GraphBLAS sequences depends on the \emph{execution mode} of the 
GraphBLAS program.  There are two modes: \emph{blocking} and \emph{nonblocking}.  
\begin{itemize}

\item \emph{blocking}: In blocking mode, each method completes the
GraphBLAS operation defined by the method before proceeding to the
next statement in program order.  Output GraphBLAS objects defined by a
method are fully produced and stored in  memory (\ie, they are
\emph{materialized}).  In other words, it is as if each method call is its own sequence.
Even mechanisms that break the opaqueness of the
GraphBLAS objects (\eg, performance monitors, debuggers, memory dumps)
will observe the operation as complete.

\item \emph{nonblocking}: In nonblocking mode, each method may return
once the input arguments have been inspected and verified to define a
well formed GraphBLAS operation. (That is, there are no API errors. See
\S~\ref{Sec:ErrorModel}.) The GraphBLAS operation may not have completed,
but the output object is ready to be used by the next GraphBLAS method
call.  Completion of \emph{all} operations in a sequence, including any that may generate execution
errors, is guaranteed once the sequence terminates.  Sequence termination is
accomplished by a call to  {\sf GrB\_wait()}.

\end{itemize}

An application executing in nonblocking mode is not required to return
immediately after input arguments have been verified. A conforming
implementation of the GraphBLAS C API running in nonblocking mode may
choose to execute {\it as if} in blocking mode.  Further, a sequence in
nonblocking mode where every GraphBLAS operation is followed by a {\sf
GrB\_wait()} call is equivalent to the same sequence in blocking mode
with {\sf GrB\_wait()} calls removed.

Nonblocking mode allows for any execution strategy that satisfies the
mathematical definition of the sequence.  The methods can be placed
into a queue and deferred.  They can be chained together and fused
(\eg, replacing a chained pair of matrix products with a matrix triple
product).  Lazy evaluation, greedy evaluation, and asynchronous execution
are all valid as long as the final result agrees with the mathematical
definition provided by the sequence of GraphBLAS method calls appearing
in  program order.

Blocking mode forces an implementation to carry out precisely the
GraphBLAS operations defined by the methods and to store output objects
to memory between method calls.  It is valuable for debugging or in
cases where an external tool such as a debugger needs to evaluate the
state of memory during a sequence.

In a  mathematically well-defined sequence with input objects that
are well-conditioned and free of execution errors, the results from
blocking and nonblocking modes should be identical outside of effects
due to roundoff errors associated with floating point arithmetic.
Due to the great flexibility afforded to an implementation when using
nonblocking mode, we expect execution of a sequence in nonblocking mode
to potentially complete execution in less time.

The mode is defined in the GraphBLAS C API when the context of the
library invocation is defined.  This occurs once before any GraphBLAS
methods are called with a call to the {\sf GrB\_init()} function.  This function
takes a single argument of type {\sf GrB\_Mode} with the following possible values:
\begin{itemize}
\item {\sf GrB\_BLOCKING} Specifies the blocking mode context.
\item {\sf GrB\_NONBLOCKING} Specifies the blocking mode context.
\end{itemize}
After all GraphBLAS methods are complete, the context is terminated
with a call to {\sf GrB\_finalize()}.  In the current version of the
GraphBLAS C API, the context can be set only once in the execution of
a program. That is, after {\sf GrB\_finalize()} is called, a subsequent
call to {\sf GrB\_init()} is not allowed.


\subsection{Thread safety}
\label{Sec:ThreadSafety}

The GraphBLAS C API is designed to work in applications that execute with multiple threads; however, 
management of threads is not exposed within the definition of the GraphBLAS C API.   The mapping of 
GraphBLAS methods onto threads and explicit synchronization between methods running on different threads 
are not defined.  Furthermore, errors exposed within the error model (see section~\ref{Sec:ErrorModel}) are
not required to manage information at a per-thread granularity.

The only requirement concerning the needs of multi-threaded execution found in the GraphBLAS C API
is that implementations of GraphBLAS methods must be thread safe.  Different threads 
may create GraphBLAS sequences that do not conflict and expect the results to be the 
same (within floating point roundoff errors) regardless of whether the sequences execute serially or concurrently.

Sequences that do not conflict are free of data races.  A data race occurs
when (1) two or more threads access shared objects, (2) those access 
operations include at least one modify operation,
and (3) those operations are not ordered through synchronization operations.   
The GraphBLAS C API does not provide synchronization operations to define 
ordered accesses to GraphBLAS objects. Hence the only way to assure that 
two sequences running concurrently on different threads do not 
conflict is if neither sequence writes to an object that the other 
sequence either reads or writes.


\section{Error Model}
\label{Sec:ErrorModel}

All GraphBLAS methods return a value of type {\sf GrB\_Info} to provide
information available to the system at the time the method returns. The
returned value can be either {\sf GrB\_SUCCESS} or one of the defined
error values shown in Table~\ref{Tab:ErrorValues}. The errors fall into
two groups: API errors (Table~\ref{Tab:ErrorValues}(a)) and execution
errors (Table~\ref{Tab:ErrorValues}(b)).

\begin{table}[bh]
\hrule
\begin{center}
\caption{Error values returned by GraphBLAS methods.}
\label{Tab:ErrorValues}

\vspace{1\baselineskip}
(a) API errors
\vspace{1\baselineskip}

\begin{tabular}{l|p{3in}}
Error code	& Description \\ \hline
{\sf GrB\_UNINITIALIZED\_OBJECT} & A GraphBLAS object is passed to a method before {\sf new} was called on it.\\
{\sf GrB\_NULL\_POINTER} & A NULL is passed for a pointer parameter. \\
{\sf GrB\_INVALID\_VALUE} & Miscellaneous incorrect values. \\
{\sf GrB\_INVALID\_INDEX} & Indices passed are larger than dimensions of the matrix or vector being accessed. \\
{\sf GrB\_DOMAIN\_MISMATCH} & A mismatch between domains of collections and operations when user-defined domains are in use.\\
{\sf GrB\_DIMENSION\_MISMATCH} & Operations on matrices and vectors with incompatible dimensions. \\
{\sf GrB\_OUTPUT\_NOT\_EMPTY} & An attempt was made to build a matrix or vector using an output object that already contains valid tuples (elements).\\
%{\sf GrB\_NO\_VALUE} & An attempt was made to extract a value from a tuple within a matrix or vector for which there is no stored value. 
{\sf GrB\_NO\_VALUE} & A location in a matrix or vector is being accessed that has no stored value at the specified location. \scott{It depends on whether or not the non-opaque scalar is
well-defined on return from {\sf extract}}\\
\end{tabular}

\vspace{1\baselineskip}
(b) Execution errors
\vspace{1\baselineskip}

\begin{tabular}{l|p{3in}}
Error code	& Description \\ \hline
{\sf GrB\_OUT\_OF\_MEMORY}         & Not enough memory for operations. \\
{\sf GrB\_INSUFFICIENT\_SPACE}     & The array provided is not large enough to hold output. \\
{\sf GrB\_INVALID\_OBJECT}         & One of the opaque GraphBLAS objects (input or output) is in an invalid state caused by a previous execution error. \\
{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}  & Reference to a vector or matrix element that is outside the defined dimensions of the object. \\
{\sf GrB\_PANIC}		& Unknown internal error. \\
\end{tabular}

\end{center}
\hrule
\end{table}

An API error means a GraphBLAS method was called with parameters that
violate the rules for that method.  These errors are restricted to those
that can be determined by inspecting the types and domains of GraphBLAS
objects, GraphBLAS operators, or the values of scalar parameters fixed at
the time a method is called.  API errors are deterministic and consistent
across platforms and implementations.  API errors are never deferred,
even in nonblocking mode. That is, if a method is called in a manner
that would generate an API error, it always returns with the appropriate
API error value.  If a GraphBLAS method returns with an API error, it
is guaranteed that none of the arguments to the method (or any other
program data) have been modified.

Execution errors indicate that something went wrong during the execution
of a legal GraphBLAS method invocation.  Their occurrence may depend on
specifics of the executing environment and data values being manipulated.
This does not mean that execution errors are the fault of the GraphBLAS
implementation.  For example, a memory leak could arise from an error in
an application's source code (a ``program error''), but it may manifest
itself in different points of a program's execution (or not at all)
depending on the platform, problem size, or what else is running at
that time.  Index-out-of-bounds and insuficient space execution errors
always indicate a program error.

In blocking mode, where each method executes to completion, a returned
execution error value applies to the specific method.  If a GraphBLAS
method, executing in blocking mode, returns with any execution error
from Table~\ref{Tab:ErrorValues}(b) other than {\sf GrB\_PANIC}, it
is guaranteed that no argument used as input-only has been modified.
Output arguments may be left in an invalid state, and their use downstream
in the program flow may cause additional errors.  If a GraphBLAS method
returns with a {\sf GrB\_PANIC} execution error, no guarantees can be
made about the state of any program data.

In nonblocking mode, execution errors can be deferred.  A return value
of {\sf GrB\_SUCCESS} only guarantees that there are no API errors in
the method invocation.  If an execution error value is returned by a
method in nonblocking mode, it indicates that an error was found during
execution of the sequence, up to and including the {\sf GrB\_wait()}
method call that ends the sequence. When possible, that return value
will provide information concerning the cause of the error.

If a GraphBLAS method, executing in nonblocking mode, returns with
any execution error from Table~\ref{Tab:ErrorValues}(b) other than
{\sf GrB\_PANIC}, it is guaranteed that no argument used as input-only
through the entire sequence has been modified.  Any output argument in
the sequence may be left in an invalid state and its use downstream in the
program flow may cause additional errors.  If a GraphBLAS method returns
with a {\sf GrB\_PANIC}, no guarantees can be made about the state of
any program data.

\begin{figure}[tb]
	\hrule
	\vspace{1\baselineskip}
	\begin{center}
		\begin{minipage}{3in}
			\begin{verbatim}
			const char *GrB_error();
			\end{verbatim}
		\end{minipage}
	\end{center}
	\caption{Signature of {\sf GrB\_error()} function.}
	\label{Fig:GrB_error}
	\hrule
\end{figure}

After a call to any GraphBLAS method, the program can retrieve additional
error information (beyond the error code returned by the method) though a
call to the function {\sf GrB\_error()}. The signature of that function is
shown in Figure~\ref{Fig:GrB_error}.  The function returns a pointer to a 
NULL-terminated string, and the contents of that string are implementation 
dependent. In particular, a null string (not a {\sf NULL} pointer) is always a valid error string.
The pointer is valid until the next call to any GraphBLAS method by the same thread.
{\sf GrB\_error()} is a thread-safe function, in the sense that multiple threads can
call it simultaneously and each will get its own error string back, referring to the
last GraphBLAS method it called.
