\chapter{Basic Concepts}
\label{Chp:Concepts}

The GraphBLAS C API is used to construct  
graph algorithms expressed ``in the language of linear algebra''.
Graphs are expressed as matrices and the operations over 
these matrices are generalized through the use of a
semiring algebraic structure.

In this chapter, we will define the basic concepts used to
define the GraphBLAS C API.  This includes the following elements:
\begin{itemize}
\item Glossary of terms used in this document.  

\item Algebraic structures and associated arithmetic foundations of the API.

\item Domains of  elements in the GraphBLAS.  

\item Functions that appear in the GraphBLAS algebraic 
structures and how they are managed.

\item Indices, index arrays and scalar arrays used
to expose the contents of GraphBLAS objects.  

\item The execution and error models implied by the GraphBLAS C specification.

\end{itemize}

\section{Glossary}

\subsection{GraphBLAS API: Basic Definitions}

\glossBegin

\glossItem{application} A program that calls methods from the GraphBLAS C API to
solve a problem.

\glossItem{GraphBLAS C API} The Application Programming Interface that fully defines the types, objects, 
literals, and other elements of the C binding to the GraphBLAS.

\glossItem{function} The term \emph{function} as used in the GraphBLAS specification
refers to a named group of statements in the C programming language.  Methods, operators,
and user-defined functions are typically implemented as C functions and when referring to 
the code programmers write, as opposed to their role as an element of the GraphBLAS, they may
be referred to as such.

\glossItem{method} A function defined in the GraphBLAS C API that manipulates
GraphBLAS objects or other opaque features of the implementation of the GraphBLAS API.

\glossItem{GraphBLAS operation} A mathematical operation defined in the
GraphBLAS mathematical specification. These operations (not to be confused with \emph{operators}) typically act
on matrices and vectors with elements defined in terms of an algebraic semiring. 
\glossEnd

\subsection{GraphBLAS objects and their structure}

\glossBegin
\glossItem{GraphBLAS object}  A instance of a data structure defined by the GraphBLAS C
API that is opaque and manipulated only through the API.  The fact the object
is based on an opaque datatype gives an implementation of the GraphBLAS C API
flexibility to optimize data structures for a particular platform.  GraphBLAS objects
are often implemented as sparse data structures meaning only a subset of the
elements have ``non-zero'' values that are stored.

\glossItem{handle}  A variable that uses one of the GraphBLAS opaque data types.
The value of this variable holds a reference to a GraphBLAS object but not the contents of object itself.  
Hence, assigning a value of one handle to another variable copies the reference to the GraphBLAS object
but not the contents of the object.

\glossItem{non-opaque} Any datatype that exposes its internal structure.   This contrasts
with an \emph{opaque} datatype which hides its internals structure and can only
be manipulated through an API.

\glossItem{domain} The set of valid values for the elements of a GraphBLAS object.

\glossItem{structural zero} Also known as an \emph{implied zero}, a \emph{structural zero} is 
any element which has a valid index (or indices) in a GraphBLAS vector or matrix 
but is not explicitly identified in the list of elements of that vector or matrix. From 
a mathematical perspective, a \emph{structural zero} is treated as having the 
value of the zero element of the relevant monoid or semiring.

\glossItem{structural complement} The \emph{structural complement} of a 
GraphBLAS vector or matrix of any domain is another vector or matrix, 
of domain {\tt bool}, in which the explicitly identified elements (with a value of {\tt true}) 
are the \emph{structural zeroes} of the original vector or matrix 
(which have an implied value of {\tt false}). 
\glossEnd



\subsection{Algebraic structures used in the GraphBLAS}

\glossBegin
\glossItem{GraphBLAS operators} Binary or unary operators that act on elements of GraphBLAS 
objects.  \emph{GraphBLAS operators} are used to express algebraic structures used in the 
GraphBLAS such as monoids and semirings. There are two 
types of \emph{GraphBLAS operators}: (1) predefined operators found in Table~\ref{Tab:PredefinedOperators} 
and (2) user-defined operators using {\sf GrB\_UnaryOp\_new()} or {\sf GrB\_BinaryOp\_new()} (see Section~\ref{Sec:AlgebraMethods}).

\glossItem{Associative Operator} In an expression where a binary operator is used two or more times consecutively, that operator is 
\emph{associative} if the result does not change as the way operations are grouped (without changing their order) changes. In other
words in a sequence of binary operations using the same associative operator, the legal placement of parenthesis does not change the 
value resulting from the sequence operations.  Operators that are associative over infinitely precise numbers (e.g. real numbers) are not 
strictly associative when applied to numbers with finite precision (e.g. floating point numbers). Such \emph{nonassociativity} results, for example, from 
round off errors or from the fact some numbers can not be represented exactly as floating point numbers.   In the GraphBLAS specification, 
as is common practice in computing, we refer to operators as \emph{associative} when their mathematical 
definition over infinitely precise numbers is associative even when they are only approximately associative when applied
to finite precision numbers.

\glossItem{monoid} An algebraic structure consisting of a domain, an associative binary operator, and an identity corresponding to 
that operator.

\glossItem{semiring} An algebraic structure consisting of a set of allowed values
(the \emph{domain}), two commutative binary operators called \emph{addition} 
and \emph{multiplication} over which the distributive property holds, identities 
over addition (\emph{0}) and multiplication (\emph{1}), and finally the additive
identity is an annihilator over multiplication.   
Note that a \emph{GraphBLAS semiring} is allowed to diverge from the mathematically 
rigorous definition of a semiring since certain combinations of domains, operators and identity 
elements are useful in graph algorithms even when they do not strictly match the mathematical
definition of a semiring.
\glossEnd



\subsection{The execution of an application using the GraphBLAS C API}
\glossBegin
\glossItem{program order} The text of an application program defines an order
of the GraphBLAS methods. This order is called the \emph{program order}.

\glossItem{sequence} A \emph{sequence} is a series of GraphBLAS method calls in program order.  
An implementation of the GraphBLAS may reorder or even fuse GraphBLAS methods within a 
sequence as long as the definitions of any GraphBLAS object that are later read by an application 
are not changed; where by ``read'' we mean that values are copied from an opaque GraphBLAS 
object into a non-opaque object.  A sequence begins when a thread calls the first method that creates
or modifies a GraphBLAS object either (1) the first call in an application or (2) the first call 
following termination of a prior sequence.  The only way to terminate a sequence within an 
application is with a call to the GrB\_wait() method. 
%\glossItem{sequence} A sequence of GraphBLAS method calls that fully defines the value of 
%a GraphBLAS object.  The sequence for a particular GraphBLAS object is defined 
%by a series of GraphBLAS method calls in program order that: (1) \emph{begins} with 
%the first GraphBLAS method that creates or modifies the GraphBLAS object; 
%and (2) \emph{terminates} with a GraphBLAS method that explicitly waits for the series of 
%methods to complete or the first method that reads values from the GraphBLAS 
%object and writes them into a non-opaque object.

\glossItem{complete} A GraphBLAS object is fully defined by the sequence of methods.   
The execution of a sequence may be deferred, however, so at any point 
in an application, a GraphBLAS object may not be materialized; that is, 
the values associated with a particular GraphBLAS object may not have 
been computed and stored in memory.   We say that a GraphBLAS object is \emph{complete} 
when the computations that implement the mathematical definition of the object have 
finished and the values associated with that object are available to any method that would 
load them into a non-opaque data structure.   Essentially, methods that extract elements 
from an opaque object and copy them into a non-opaque object force \emph{completion} of the
opaque object. 

\glossItem{materialize} A GraphBLAS object has been \emph{materialized} when 
the computations that implement the mathematical definition of the object 
have finished and the values associated with that object reside in memory.   
A GraphBLAS object that is never loaded into a non-opaque data structure may 
potentially never be materialized.  This might happen, for  example, should the operations 
associated with the object be fused or otherwise changed by the runtime system 
that supports the implementation of the GraphBLAS C API.   

\glossItem{context} The GraphBLAS C API was designed with the expectation that
implementations of the API might utilize sophisticated execution strategies 
to optimize performance.   We anticipate that an application may need 
to apply constraints on the behavior of implementations of the 
GraphBAS C API and that these constraints may vary from one application 
to another.   To the application, it appears as if the application 
interacts with a distinct instance of the GraphBLAS C API implementation.
The state of this instance is called the GraphBLAS \emph{context}. 
The context  is set with {\sf GrB\_init()}. Currently, the only
supported constraints on a context pertain to the mode of program execution.

\glossItem{mode} A GraphBLAS sequence executes in one of two modes.  
In \emph{blocking mode}, GraphBLAS methods return after the computations 
complete and any output objects have been updated.  In nonblocking mode, a 
method returns once the arguments are tested as consistent with 
the method but potentially before any computation has proceeded.
\glossEnd

\subsection{GraphBLAS methods: behaviors and error conditions}
\glossBegin
\glossItem{implementation defined} Behavior that must be documented
by the implementation and is allowed to vary among different
compliant implementations. 

\glossItem{undefined} Behavior that is not specified by the GraphBLAS C API.
A conforming implementation is free to choose results delivered from a method
whose behavior is undefined. 

\glossItem{thread safe} A routine is said to be \emph{thread safe} if it performs its intended 
function even when executed concurrently (by more than one thread).

\glossItem{shape compatible} GraphBLAS objects passed as parameters to a GraphBLAS method 
are \emph{shape compatible} if for the operation associated with the method, the number of dimensions
and the sizes in each dimension satisfy the rules from the mathematical definition of the operation.  This
is also referred to as \emph{dimension compatible}.

\glossItem{domain compatible} Two domains are \emph{domain compatible} with 
each other if values from one domain can be cast to values in the other domain 
as per the rules of the C language. In particular, domains from Table~\ref{Tab:PredefinedTypes} 
are all compatible with each other. A domain from a user-defined type is only 
compatible with itself. If any \emph{domain compatibility} rule above is 
violated, execution of GraphBLAS method ends and the domain 
mismatch error {\sf GrB\_DOMAIN\_MISMATCH} is returned.
\glossEnd

\vfill

\newgeometry{left=2.5cm,top=2cm,bottom=2cm}

\section{Notation}

\begin{tabular}[H]{l|p{5in}}
Notation & Description \\
\hline
$D_i$           & The $i$th domain of a GraphBLAS object. \\
$\bold{D}_i(*)$ & Evaluates to the $i$th domain of a GraphBLAS Object (usually a unary or binary operator, or semiring). \\
$\bold{D}(*)$   & Evaluates to the (only) domain of a GraphBLAS Object (usually a monoid, vector or matrix). \\ 
$f$             & An arbitrary unary function, usually a component of a unary operator. \\
$\bold{f}(F_u)$ & Evaluates to the unary function contained in the unary operator given as the argument. \\
$\odot$         & An arbitrary binary function, usually a component of a binary operator. \\
$\bold{\bigodot}(*)$ & Evaluates to the binary function contained in the binary operator or monoid given as the argument. \\
$\otimes$       & Multiplicative binary operator of a semiring. \\
$\oplus$        & Additive binary operator of a semiring. \\
$\bold{\bigotimes}(S)$ & Evaluate to the multiplicative binary operator of the Semiring given as the argument. \\
$\bold{\bigoplus}(S)$ & Evaluate to the additive binary operator of the Semiring given as the argument. \\
$\bold{0}(*)$   & The identity of a monoid, or the additive identity of a GraphBLAS Semiring. \\
$\bold{L}(*)$   & The contents (all stored values) of the vector or matrix GraphBLAS objects.  For a vector, it is the set of (index, value) 2-ples and for a matrix it is the set of (row, col, value) triples. \\
$\bold{v}(i)$   & The $i^{th}$ element of the vector $\vector{v}$.\\
$v_i$           & The $i^{th}$ element of the vector $\vector{v}$.\\
$\bold{size}(\vector{v})$ & The size of the $\vector{v}$.\\
$\bold{ind}(\vector{v})$ & The set of indices corresponding to the stored values of the vector $\vector{v}$.\\
$\bold{nrows}(\vector{A})$ & The number of rows in the $\matrix{A}$.\\
$\bold{ncols}(\vector{A})$ & The number of columns in the $\matrix{A}$.\\
$\bold{indrow}(\vector{A})$ & The set of indices corresponding to the stored values of the indicated row  \\
$\bold{indcol}(\vector{A})$ & The set of indices corresponding to the stored values of the indicated column \\
$\bold{ind}(\vector{A})$ & The set of $(i,j)$ indices corresponding to the stored values of the matrix \\
$\bold{A}(i,j)$ & The element of $\matrix{A}$ with row index $i$ and column index $j$.\\
$A_{ij}$ & The element of $\matrix{A}$ with row index $i$ and column index $j$.\\
$\matrix{A}(:,j)$ & The $j^{th}$ column of the the matrix $\matrix{A}$.\\
$\matrix{A}(i,:)$ & The $i^{th}$ row of the the matrix $\matrix{A}$.\\
$\matrix{A}^T$ &The transpose the matrix $\matrix{A}$. \\
$\neg\matrix{M}$ & The structural compliment of $\matrix{M}$.\\
$\vector{\widetilde{t}}$ & A temporary object created  by the GraphBLAS implementation. \\
$<type>$ & A method argument type that is \sf{void *} or one of the types from Table~\ref{Tab:PredefinedTypes}. \\
{\sf GrB\_ALL} & A method argument literal to indicate that all indices of an input array should be used.\\
{\sf GrB\_Type} & A method argument type that is either a user defined type or one of the  types from Table~\ref{Tab:PredefinedTypes}.\\
{\sf GrB\_Object} &  A method argument type referencing any of the GraphBLAS object types.\\
{\sf GrB\_NULL} & The GraphBLAS NULL.\\
\end{tabular}

\restoregeometry


\section{Algebraic and Arithmetic foundations}

Graphs can be represented in terms of matrices. Operations defined by the GraphBLAS standard
operate on these matrices to construct graph algorithms.
These GraphBLAS operations are defined in terms of GraphBLAS semiring algebraic 
structures. Modifying the underlying semiring changes the result of 
an operation to support a wide range of graph algorithms.

Inside a given algorithm, it is often beneficial to change the GraphBLAS semiring
that applies to an operation on a matrix.  This has two 
implications on the C-binding to the GraphBLAS.  First,
it means that we define a separate object for the semiring 
to pass into functions.  Since in many cases the full
semiring is not required, we also support passing monoids or
even operators; which basically means the semiring is implied but not 
explicitly stated.

Second, the ability to change semirings impacts the meaning of 
the \emph{implied zero} in a sparse representation of a matrix.
This element in real arithmetic is zero which is the 
identity of the \emph{addition} operator and the annihilator of
\emph{multiplication} operator.   As the semiring changes, this 
\emph{implied} or \emph{structural zero} changes to the identity of 
the \emph{addition} operator and the annihilator of the \emph{multiplication} 
operator for the new semiring.   Nothing changes in the
stored matrix, but the implied values within the sparse matrix change
with respect to a particular operation.  In most cases, the nature
of the implied zero does not matter since the GraphBLAS treats these
as elements of the matrix that do not exist.  As we will see, however,
there are a small subset of GraphBLAS methods 
(the element-wise operations) where to understand 
the method you need to understand the implied zero.

The mathematical formalism for graph operations in the language of 
linear algebra assumes that we can operate in the field of real numbers. 
However, the GraphBLAS C binding is designed for implementation on computers 
which by necessity have a finite number of bits to represent numbers. 
Therefore, we require a conforming implementation to use floating-point 
number such as those defined by the IEEE-754 standard (both single- and double-precision) 
wherever real numbers need to be represented. The practical implications of 
these finite precision numbers is that the result of a sequence of 
computations may vary from one execution to the next as the way 
operations are associated change. While techniques are known to 
reduce these effects, we do not require or even expect an implementation 
to use them as they may add considerable overhead. The fact is that in most 
cases, these roundoff errors are not significant and when they are significant, 
the problem itself is ill-conditioned and needs to be reformulated.

\section{GraphBLAS opaque objects}

Objects defined in the GraphBLAS standard include collections of elements
(matrices and vectors), operators on those elements (unary and binary operators), and 
algebraic structures (semirings and monoids).   GraphBLAS objects are defined
as opaque types; i.e. they are managed, manipulated, and accessed solely through the
GraphBLAS application programming interface. This gives an implementation of the
GraphBLAS C specification flexibility to optimize objects for different scenarios or to meet
the needs of different hardware platforms.

A GraphBLAS opaque object is accessed through its handle.  A handle
is a variable that uses one of the types from Table~\ref{Tab:ObjTypes}.  An implementation 
of the GraphBLAS specification has a great deal of flexibility in how these
handles are implemented.  All that is required is that the handle corresponds to a type defined in the 
C language that supports assignment and comparison for equality.  The
GraphBLAS specification defines a 
literal {\sf GrB\_INVALID\_HANDLE} that is valid for each type.  Using the logical equality 
operator from C, it must be possible to compare a handle to {\sf GrB\_INVALID\_HANDLE}
to verify that a handle is valid.


\begin{table}
\hrule
\begin{center}
\caption{GraphBLAS opaque objects and their types.}
\label{Tab:ObjTypes}
\begin{tabular}{l|l}
{\sf GrB\_Object types} & Description \\
\hline
{\sf GrB\_Type}           & User defined scalar type.     \\
{\sf GrB\_UnaryOp}    & Unary Operator,  built-in or associated with a single argument C function.     \\
{\sf GrB\_BinaryOp}    & Unary Operator, built-in or associated with a two argument C function.     \\
{\sf GrB\_Monoid}       & Monoid algebraic structure.     \\
{\sf GrB\_semiring}      & A GraphBLAS semiring algebraic structure.     \\
{\sf GrB\_Matrix}          & Two dimensional collection of elements; typically sparse.    \\
{\sf GrB\_Vector}         & One dimensional collection of elements.     \\
{\sf GrB\_Descriptor}    & Descriptor object, used to modify behavior of methods.     \\
\end{tabular}
\end{center}
\hrule
\end{table}

An application using the GraphBLAS API will declare variables of the appropriate
type for the objects it will use.  Before use, the object must be initialized with 
the appropriate method.  This is done with one of the methods that has a ``{\sf \_new} suffix in its 
name (e.g. {\sf GrB\_Vector\_new}).  Alternatively, an object can be initialized by duplicating
an existing object with one of the methods that has the ``{\sf \_dup} suffix in its 
name  (e.g. {\sf GrB\_Vector\_dup}).   When an application is finished with 
an object, any resources associated with that object can be released by a
call to the {\sf GrB\_free} method.    

These {\sf new}, {\sf dup} and {\sf free} methods are the only methods that 
change the value of a handle.  Hence, objects changed by these methods are passed
into the method as pointers.  In all other cases, handles are not changed by the 
method and are passed by value.  For example, even when multiplying matrices, 
while the contents of the output product matrix changes, the handle for that matrix is unchanged. 

Programmers using GraphBLAS handles must be careful to distinguish between a handle and the 
object manipulated through a handle.  For example, a program may declare two 
GraphBLAS objects of the same type, initialize one and then assign it to the other
variable.  That assignment, however, only assigns the handle to the variable.  It does not 
create a copy of that variable (to do that, you'd need to use the appropriate duplication method).
If later the object is freed by calling {\sf GrB\_free} with the first variable, the object
is destroyed and the second variable is left referencing an object that no longer 
exists (a so called ``dangling handle'').

In addition to opaque objects manipulated through handles, the GraphBLAS C API defines
an additional opaque object as an internal object; i.e. the object is never exposed as
a variable within an application.  This opaque object is the {\emph mask} used to
control how computed values are stored in the output from a method.  Masks 
are described later in section~\ref{Sec:Masks}.

\section{Domains}

GraphBLAS defines two kinds of collections: matrices and vectors.
For any given collection, the elements of the collection belong to
a \emph{domain}, which is the set of valid values for the elements.
In GraphBLAS, domains correspond to the valid values for types from
the host language (in our case, the C programming language).  For any
variable or object $V$ in GraphBLAS we denote as $\bold{D}(V)$ the
domain of $V$; that is, the set of possible values that elements of
$V$ can take.  The predefined types and corresponding domains used in the 
GraphBLAS are shown in Table~\ref{Tab:PredefinedTypes}.  The Boolean
type is defined in {\tt stdbool.h}, the integral types are defined in
{\tt stdint.h}, and the floating-point types are native to the language
and in most cases defined by the IEEE-754 standard.


\begin{table}
\hrule
\begin{center}
\caption{Predefined {\sf GrB\_Type} values, the corresponding C type (for scalar
parameters, and domains for GraphBLAS.}
\label{Tab:PredefinedTypes}
\begin{tabular}{l|l|l}
{\sf GrB\_Type values} & C type            & domain \\
\hline
{\sf GrB\_BOOL}        & {\tt bool}        & $\{ {\tt false}, {\tt true} \}$  \\
{\sf GrB\_INT8}        & {\tt int8\_t}     & $\mathbb{Z} \cap [-2^{7},2^{7})$  \\
{\sf GrB\_UINT8}       & {\tt uint8\_t}    & $\mathbb{Z} \cap [0,2{^8})$  \\
{\sf GrB\_INT16}       & {\tt int16\_t}    & $\mathbb{Z} \cap [-2^{15},2^{15})$ \\
{\sf GrB\_UINT16}      & {\tt uint16\_t}   & $\mathbb{Z} \cap [0,2^{16})$ \\
{\sf GrB\_INT32}       & {\tt int32\_t}    & $\mathbb{Z} \cap [-2^{31},2^{31})$ \\
{\sf GrB\_UINT32}      & {\tt uint32\_t}   & $\mathbb{Z} \cap [0,2^{32})$ \\
{\sf GrB\_INT64}       & {\tt int64\_t}    & $\mathbb{Z} \cap [-2^{63},2^{63})$ \\
{\sf GrB\_UINT64}      & {\tt uint64\_t}   & $\mathbb{Z} \cap [0,2^{64})$ \\
{\sf GrB\_FP32}        & {\tt float}       & IEEE 754 {\sf binary32}  \\
{\sf GrB\_FP64}        & {\tt double}      & IEEE 754 {\sf binary64}  \\
\end{tabular}
\end{center}
\hrule
\end{table}

\section{Operators and Associated Functions}

GraphBLAS operators act on elements of GraphBLAS objects.   A
 \emph{binary operator} is a function that maps two input
values to one output value. A \emph{unary operator} is a function that 
maps one input value to one output value. The value of the output is 
determined by the value of the input(s).  Binary operators are defined over 
two input domains and produce an output from a (possibly different) third 
domain. Unary operators are specified over one input domain and produce an 
output from a (possibly different) second domain.

Similar to GraphBLAS types with predefined types and user-defined types, 
GraphBLAS operators come in two types as well: (1) predefined operators 
found in Table~\ref{Tab:PredefinedOperators} and (2) user-defined operators 
using {\sf GrB\_UnaryOp\_new()} or {\sf GrB\_BinaryOp\_new()} (see Section~\ref{Sec:AlgebraMethods}).

\begin{table}
\hrule
\begin{center}
\caption{Predefined unary and binary operators for GraphBLAS in C.}
\label{Tab:PredefinedOperators}

\vspace{1\baselineskip}
(a) Valid suffixes and corresponding C type ($T$ in table (b)).
\vspace{1\baselineskip}

\begin{tabular}{l|l}
Suffix			& C type \\ \hline
{\sf BOOL}		& {\tt bool} \\
{\sf INT8}		& {\tt int8\_t} \\
{\sf UINT8}		& {\tt uint8\_t} \\
{\sf INT16}		& {\tt int16\_t} \\
{\sf UINT16}	& {\tt uint16\_t} \\
{\sf INT32}		& {\tt int32\_t} \\
{\sf UINT32}	& {\tt uint32\_t} \\
{\sf INT64}		& {\tt int64\_t} \\
{\sf UINT64}	& {\tt uint64\_t} \\
{\sf FP32}		& {\tt float} \\
{\sf FP64}		& {\tt double} \\
\end{tabular}

\vspace{1\baselineskip}
(b) Predefined Operators.
\vspace{1\baselineskip}

\begin{tabular}{l|l|l|ll}
Operator & GraphBLAS             &                                                              & \\
type     & identifier            & Domains                                              & Description \\ \hline
{\sf GrB\_UnaryOp}    & {\sf GrB\_IDENTITY\_$T$} & $T \rightarrow T $     & $f(x) = x$, &identity \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_AINV\_$T$}     & $T \rightarrow T $     & $f(x) = -x$, &additive inverse \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_MINV\_$T$}     & $T \rightarrow T $     & $f(x) = \frac{1}{x}$, &multiplicative inverse \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_LNOT}          & ${\tt bool} \rightarrow {\tt bool}$  & $f(x) =~\neg x$, &logical inverse  \\

&&&\\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LOR}        & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$ & $f(x,y) = x \lor y$, & logical OR \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LAND}       & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$ & $f(x,y) = x \land y$, & logical AND \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LXOR}       & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$ & $f(x,y) = x \oplus y$, & logical XOR \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_EQ\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x == y)$ & equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_NE\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x \neq y)$ & not equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_GT\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x > y)$ & greater than  \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LT\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x < y)$ & less than  \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_GE\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x \geq y)$ & greater than or equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LE\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x \leq y)$ & less than or equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_FIRST\_$T$} & $T \times T \rightarrow T$  & $f(x,y) = x$, & first argument \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_SECOND\_$T$}& $T \times T \rightarrow T$  & $f(x,y) = y$, & second argument \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_MIN\_$T$}   & $T \times T \rightarrow T$  & $f(x,y) = (x < y)~?~x : y$, & minimum \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_MAX\_$T$}   & $T \times T \rightarrow T$  & $f(x,y) = (x > y)~?~x : y$, & maximum \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_PLUS\_$T$}  & $T \times T \rightarrow T$  & $f(x,y) = x + y$, & addition \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_MINUS\_$T$} & $T \times T \rightarrow T$  & $f(x,y) = x - y$, & subtraction \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_TIMES\_$T$} & $T \times T \rightarrow T$  & $f(x,y) = xy$, & multiplication \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_DIV\_$T$}   & $T \times T \rightarrow T$  & $f(x,y) = \frac{x}{y}$, & division \\
\end{tabular}
\end{center}
\hrule
\end{table}


\section{Indices, Index Arrays and Scalar Arrays}

In order to interface with third-party software (i.e. software other than
an implementation of the GraphBLAS), operations 
such as {\sf GrB\_Matrix\_build} (\S~\ref{Sec:Matrix_build}) and
{\sf GrB\_Matrix\_extractTuples} (\S~\ref{Sec:Matrix_extractTuples}) must specify
how the data should be laid out in  non-opaque data structures.  To 
this end we explicitly define the types for indices and the arrays 
used by these operations.

For indices a typedef is used to give a GraphBLAS name to a concrete type. We define it as follows:

\begin{verbatim}
    typedef uint64_t GrB_Index;
\end{verbatim}

An index array is a pointer to a set of {\sf GrB\_Index} values that are 
stored in a contiguous block of memory (\ie, {\sf GrB\_Index*}).
Likewise a scalar array is a pointer to a contiguous block of memory 
storing a number of scalar values as specified by the user.
For any GraphBLAS operation that uses an input index array, the literal {\sf GrB\_ALL} 
can be used to indicate that all indices of the associated GraphBLAS vector object should be used.
As with any literal defined in the GraphBLAS, an implementation of the GraphBLAS C API has considerable 
freedom in terms of how {\sf GrB\_ALL} is defined.  Since it is used as an argument for an array 
parameter, {\sf GrB\_ALL} must use a type consistent with a pointer and it must have a non-null
value so it can be distinguished from the erroneous case of passing a null-pointer as an array.

\section{Execution Model}
\label{Sec:ExecutionModel}

A program using the GraphBLAS C API constructs GraphBLAS objects,
manipulates them to implement a graph algorithm, and then extracts
values from the GraphBLAS objects as the result of the algorithm.
Functions defined within the GraphBLAS C API that manipulate GraphBLAS
objects are called \emph{methods}.  If the method corresponds to one
of the operations defined in the GraphBLAS mathematical specification,
we refer to the method as an \emph{operation}.

Graph algorithms are expressed as an ordered collection of GraphBLAS
method calls defined by the order they are encountered in a program.
This is called the \emph{program order}.  Each method in the collection
uniquely and unambiguously defines the output GraphBLAS objects based
on the GraphBLAS operation and the input GraphBLAS objects. (As long
as there are no execution errors. Execution errors can put objects in
invalid states. See \S~\ref{Sec:ErrorModel}.)

The GraphBLAS method calls in program order are organized into 
contiguous and nonoverlapping \emph{sequences}.  A sequence is an
ordered collection of method calls as encountered by an executing thread. (For more
on threads and GraphBLAS, see \S~\ref{Sec:ThreadSafety}.)  A sequence
begins with either (i) the first GraphBLAS method called by a thread, or
(ii) the first method called by a thread after the end of the previous
sequence. A sequence always ends (terminates) with a call to the GraphBLAS
{\sf GrB\_wait()} method.

The GraphBLAS objects are fully defined at any point in a sequence by the
methods in the sequence as long as there are no execution errors.
In particular, as soon as a GraphBLAS
method call returns, its output can be used in the next GraphBLAS
method call.  However, individual operations in a sequence may not
be \emph{complete}. We say that an operation is complete when all the
computations in the operation have finished and all the values of its
output object have been produced and committed to the address 
space of the program.

The opaqueness of GraphBLAS objects allows execution to proceed
from one method to the next even when operations are not complete.
Processing of nonopaque objects is never deferred in GraphBLAS. That is,
methods that consume nonopaque objects (\eg, {\sf GrB\_Matrix\_build},
\S~\ref{Sec:Matrix_build}()) and methods that produce nonopaque objects (\eg,
{\sf GrB\_Matrix\_extractTuples()}, \S~\ref{Sec:Matrix_extractTuples})
always finish consuming or producing those nonopaque objects before
returning.   Furthermore, methods that extract values from opaque GraphBLAS objects
into nonopaque user objects (see Table~\ref{Tab:ExtractMethods})
always force completion of all pending computations on the 
corresponding GraphBLAS source object.

\begin{table}[htb]
	\hrule
	\begin{center}
		\caption{Methods that extract values from a GraphBLAS object; thereby
		forcing completion of the operations contributing to that particular object.}
		\label{Tab:ExtractMethods}

		\begin{tabular}{l|l}
			Method	& Section \\ \hline

			{\sf GrB\_Vector\_nvals}		& \S~\ref{Sec:Vector_nvals}		\\
			{\sf GrB\_Vector\_extractTuples}	& \S~\ref{Sec:Vector_extractTuples}	\\
			{\sf GrB\_Matrix\_nvals}		& \S~\ref{Sec:Matrix_nvals}		\\
			{\sf GrB\_Matrix\_extractTuples}	& \S~\ref{Sec:Matrix_extractTuples}	\\
			{\sf GrB\_extract} (single element vector variant)	& \S~\ref{Sec:extract_single_element_vec}	\\
			{\sf GrB\_extract} (single element matrix variant)	& \S~\ref{Sec:extract_single_element_mat}	\\
			{\sf GrB\_reduce} (vector-scalar variant)		& \S~\ref{Sec:Reduce_vector_scalar}		\\
			{\sf GrB\_reduce} (matrix-scalar variant)		& \S~\ref{Sec:Reduce_matrix_scalar}		\\
		\end{tabular}
	\end{center}
	\hrule
\end{table}

\subsection{Execution modes}

The execution model
implied by GraphBLAS sequences depends on the \emph{execution mode} of the 
GraphBLAS program.  There are two modes: \emph{blocking} and \emph{nonblocking}.  
\begin{itemize}

\item \emph{blocking}: In blocking mode, each method completes the
GraphBLAS operation defined by the method before proceeding to the
next statement in program order.  Output GraphBLAS objects defined by a
method are fully produced and stored in  memory (\ie, they are
\emph{materialized}).  In other words, it is as if each method call is its own sequence.
Even mechanisms that break the opaqueness of the
GraphBLAS objects (\eg, performance monitors, debuggers, memory dumps)
will observe the operation as complete.

\item \emph{nonblocking}: In nonblocking mode, each method may return
once the input arguments have been inspected and verified to define a
well formed GraphBLAS operation. (That is, there are no API errors. See
\S~\ref{Sec:ErrorModel}.) The GraphBLAS operation may not have completed,
but the output object is ready to be used by the next GraphBLAS method
call.  Completion of \emph{all} operations in a sequence, including any that may generate execution
errors, is guaranteed once the sequence terminates.  Sequence termination is
accomplished by a call to  {\sf GrB\_wait()}.

\end{itemize}

An application executing in nonblocking mode is not required to return
immediately after input arguments have been verified. A conforming
implementation of the GraphBLAS C API running in nonblocking mode may
choose to execute ``as if'' in blocking mode.  Further, a sequence in
nonblocking mode where every GraphBLAS operation is followed by an {\sf
GrB\_wait()} call is equivalent to the same sequence in blocking mode
with {\sf GrB\_wait()} calls removed.

Nonblocking mode allows for any execution strategy that satisfies the
mathematical definition of the sequence.  The methods can be placed
into a queue and deferred.  They can be chained together and fused
(\eg, replacing a chained pair of matrix products with a matrix triple
product).  Lazy evaluation, greedy evaluation or asynchronous execution
are all valid as long as the final result agrees with the mathematical
definition provided by the sequence of GraphBLAS method calls appearing
in  program order.

Blocking mode forces an implementation to carry out precisely the
GraphBLAS operations defined by the methods and to store output objects
to memory between method calls.  It is valuable for debugging or in
cases where an external tool such as a debugger needs to evaluate the
state of memory during a sequence.

In a  mathematically well-defined sequence with input objects that
are well-conditioned, and free of execution errors, the results from
blocking and nonblocking modes should be identical outside of effects
due to round-off errors associated with floating point arithmetic.
Due to the great flexibility afforded to an implementation when using
nonblocking mode, we expect execution of a sequence in nonblocking mode
to potentially complete execution in less time.

The mode is defined in the GraphBLAS C API when the context of the
library invocation is defined.  This occurs once before any GraphBLAS
methods are called with a call to the {\sf GrB\_init()} function.  This function
takes a single argument of type {\sf GrB\_Mode} with possible values:
\begin{itemize}
\item {\sf GrB\_BLOCKING} Specifies the blocking mode context.
\item {\sf GrB\_NONBLOCKING} Specifies the blocking mode context.
\end{itemize}
After all GraphBLAS methods are complete, the context is terminated
with a call to {\sf GrB\_finalize()}.  In the current version of the
GraphBLAS C API, the context can only be set once in the execution of
a program. That is, after {\sf GrB\_finalize()} is called a following
call to {\sf GrB\_init()} is not allowed.


\subsection{Thread safety}
\label{Sec:ThreadSafety}

Implementations of the GraphBLAS C API are required to be thread safe.  Different threads 
may create GraphBLAS sequences that do not conflict and expect the results to be the 
same (within floating point roundoff errors) regardless of whether the sequences execute serially or concurrently.

Sequences that do not conflict are free of data races.  A data race occurs
when: (1) two or more threads access shared objects, (2) those access 
operations include at least one modify operation,
and (3) those operations are not ordered through synchronization operations.   
The GraphBLAS C API does not provide synchronization operations to define 
ordered accesses to GraphBLAS objects. Hence the only way to assure that 
two sequences running concurrently on different threads do not 
conflict is if neither sequence writes to an object that the other 
sequence either reads or writes.

\section{Error Model}
\label{Sec:ErrorModel}

All GraphBLAS methods return a value of type {\sf GrB\_Info} to provide
information available to the system at the time the method returns.� The
returned value can be either {\sf GrB\_SUCCESS} or one of the defined
error values shown in Table~\ref{Tab:ErrorValues}. The errors fall into
two groups: API errors (Table~\ref{Tab:ErrorValues}(a)) and execution
errors (Table~\ref{Tab:ErrorValues}(b)).

An API error means a GraphBLAS method was called with parameters that
violate the rules for that method. API errors are deterministic and
consistent across platforms and implementations.  API errors are never
deferred, even in nonblocking mode. That is, if a method is called in a manner
that would generate an API error, it always returns with the appropriate API error value.  
If a GraphBLAS method returns with an API error, it is guaranteed that none of the
arguments to the method (or any other program data) have been modified.

Execution errors indicate that something went wrong during the execution
of a legal GraphBLAS method invocation.  Their occurrence may depend on
specifics of the executing environment.  This does not mean that execution
errors are the fault of the GraphBLAS implementation.  For example, a
memory leak could arise from an error in an application's source code (a 
``program error'') but it may manifest itself in different
points of a program's execution (or not at all) depending on the platform,
problem size, or what else is running at that time.  Index-out-of-bounds
execution errors always indicate a program error.

In blocking mode, where each method executes to completion, a returned
execution error value applies to the specific method.  If a GraphBLAS
method, executing in blocking mode, returns with a {\sf GrB\_OUT\_OF\_MEMORY} or
a {\sf GrB\_INDEX\_OUT\_OF\_BOUNDS} error, it is guaranteed that no argument
used as input-only has been modified. Output arguments may be left in
an invalid state and their use downstream in the program flow may cause
additional errors.  If a GraphBLAS method returns with a {\sf GrB\_PANIC},
no guarantees can be made about the state of any program data.

In nonblocking mode, execution errors can be deferred.  A return value
of {\sf GrB\_SUCCESS} only guarantees that there are no API errors in the
method invocation.  If an execution error value is returned by a method in
nonblocking mode, it indicates that an error was found during execution
of the sequence, up to and including the {\sf GrB\_wait()} method call
that ends the sequence.� When possible, that return value will provide
information concerning the cause of the error.� 

If a GraphBLAS method, executing in nonblocking mode, returns
with a {\sf GrB\_OUT\_OF\_MEMORY} or a {\sf GrB\_INDEX\_OUT\_OF\_BOUNDS} error,
it is guaranteed that no argument used as input-only through the entire
sequence has been modified. Any output argument in the sequence may be
left in an invalid state and its use downstream the program flow may cause
additional errors.  If a GraphBLAS method returns with a {\sf GrB\_PANIC},
no guarantees can be made about the state of any program data.

\begin{table}[htb]
\hrule
\begin{center}
\caption{Error values returned by GraphBLAS methods.}
\label{Tab:ErrorValues}

\vspace{1\baselineskip}
(a) API errors
\vspace{1\baselineskip}

\begin{tabular}{l|p{3in}}
Error code	& Description \\ \hline
{\sf GrB\_UNINITIALIZED\_OBJECT} & A GraphBLAS object is passed to a method before {\sf new} was called on it.\\
{\sf GrB\_NULL\_POINTER} & A NULL is passed for a pointer parameter. \\
{\sf GrB\_INVALID\_VALUE} & Miscellaneous incorrect values. \\
{\sf GrB\_INVALID\_INDEX} & Indices passed are larger than dimensions of matrix or vector being accessed. \\
{\sf GrB\_DOMAIN\_MISMATCH} & A mismatch between domains of collections and operations when user-defined domains are in use.\\
{\sf GrB\_DIMENSION\_MISMATCH} & Operations on matrices and vectors with incompatible dimensions. \\
{\sf GrB\_NO\_VALUE} & A location in a matrix or vector is being access that has no store value at the specified location. \scott{It depends on whether or not the non-opaque scalar is
well-defined on return from {\sf extract}}\\
\end{tabular}

\vspace{1\baselineskip}
(b) Execution errors
\vspace{1\baselineskip}

\begin{tabular}{l|p{3in}}
Error code	& Description \\ \hline
{\sf GrB\_OUT\_OF\_MEMORY}		& Not enough memory for operations. \\
{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}	& Reference to a vector or matrix elements that is outside the defined dimensions of the object. \\
{\sf GrB\_PANIC}		& Unknown internal error. \\
\end{tabular}

\end{center}
\hrule
\end{table}

After a call to any GraphBLAS method, the program can retrieve additional
error information (beyond the error code returned by the method) though a
call to the function {\sf GrB\_error()}. The signature of that function is
shown in Figure~\ref{Fig:GrB_error}.
The function returns a pointer to a null terminated string and the contents of that string
are implementation dependent. In particular, a null string (not a {\sf NULL} pointer) is always a valid error string.
The pointer is valid until the next call to any GraphBLAS method by the same thread.
{\sf GrB\_error()} is a thread-safe function, in the sense that multiple threads can
call it simultaneously and each will get its own error string back, referring to the
last GraphBLAS method it called.

\begin{figure}[htb]
	\hrule
	\vspace{1\baselineskip}
	\begin{center}
		\begin{minipage}{3in}
			\begin{verbatim}
			const char *GrB_error();
			\end{verbatim}
		\end{minipage}
	\end{center}
	\caption{Signature of {\sf GrB\_error()} function.}
	\label{Fig:GrB_error}
	\hrule
\end{figure}
