\chapter{Basic concepts}

\section{Domains}

%
% I will add a comment about floating point arithmetic and
% associativity
%

GraphBLAS defines two kinds of collections: matrices and vectors.
For any given collection, the elements of the collection belong to
a \emph{domain}, which is the set of valid values for the element.
In GraphBLAS, domains correspond to the valid values for types from
the host language (in our case, the C programming language).  For any
variable or object $V$ in GraphBLAS we denote as $\bold{D}(V)$ the
domain of $V$. That is, the set of possible values that elements of
$V$ can take.  The predefined types, and corresponding domains, of
GraphBLAS are shown in Table~\ref{Tab:PredefinedTypes}.  The Boolean
type is defined in {\tt stdbool.h}, the integral types are defined in
{\tt stdint.h}, and the floating-point types are native to the language.
GraphBLAS also supports user defined types. In that case, the domain is
the set of valid values for a variable of that type.

\begin{table}
\hrule
\begin{center}
\caption{Predefined {\sf GrB\_Type} values, the corresponding C type (for scalar
parameters, and domains for GraphBLAS. 
        \scott{Consider name change from GrB\_Type to GrB\_Domain}
        \aydin{There will be a way to introduce new GraphBLAS identifiers,
        similar to MPI\_Type\_Commit, these are just predefined stuff}
        \scott{An example would be nice, 
        especially where there is not a 1-to-1 correspondence to a built-in
        type, e.g. \{0,1\}.}}
\label{Tab:PredefinedTypes}
\begin{tabular}{l|l|l}
{\sf GrB\_Type values} & C type            & domain \\
\hline
{\sf GrB\_BOOL}        & {\tt bool}        & $\{ {\tt false}, {\tt true} \}$  \\
{\sf GrB\_INT8}        & {\tt int8\_t}     & $\mathbb{Z} \cap [-2^{7},2^{7})$  \\
{\sf GrB\_UINT8}       & {\tt uint8\_t}    & $\mathbb{Z} \cap [0,2{^8})$  \\
{\sf GrB\_INT16}       & {\tt int16\_t}    & $\mathbb{Z} \cap [-2^{15},2^{15})$ \\
{\sf GrB\_UINT16}      & {\tt uint16\_t}   & $\mathbb{Z} \cap [0,2^{16})$ \\
{\sf GrB\_INT32}       & {\tt int32\_t}    & $\mathbb{Z} \cap [-2^{31},2^{31})$ \\
{\sf GrB\_UINT32}      & {\tt uint32\_t}   & $\mathbb{Z} \cap [0,2^{32})$ \\
{\sf GrB\_INT64}       & {\tt int64\_t}    & $\mathbb{Z} \cap [-2^{63},2^{63})$ \\
{\sf GrB\_UINT64}      & {\tt uint64\_t}   & $\mathbb{Z} \cap [0,2^{64})$ \\
{\sf GrB\_FLOAT}       & {\tt float}       & IEEE 754 {\sf binary32}  \\
{\sf GrB\_DOUBLE}      & {\tt double}      & IEEE 754 {\sf binary64}  \\
\end{tabular}
\end{center}
\hrule
\end{table}

\section{Functions}

In GraphBLAS, a \emph{binary function} is a function that maps two input
values to one output value. A \emph{unary function} is a function that 
maps one input value to one output value. The value of the output is uniquely
determined by the value of the input(s).  Binary functions are defined over 
two input domains and produce an output from a (possibly different) third 
domain. Unary functions are specified over one input domain and produce an 
output from a (possibly different) second domain.  The predefined functions 
of GraphBLAS are listed in Table~\ref{Tab:PredefinedFunctions}.

\begin{table}
\hrule
\begin{center}
\caption{Predefined unary and binary functions for GraphBLAS in C.}
\label{Tab:PredefinedFunctions}

\vspace{1\baselineskip}
(a) Valid suffixes and corresponding C type ($T$ in table (b)).
\vspace{1\baselineskip}

\begin{tabular}{l|l}
Suffix		& C type \\ \hline
{\sf B}		& {\tt bool} \\
{\sf I8}	& {\tt int8\_t} \\
{\sf U8}	& {\tt uint8\_t} \\
{\sf I16}	& {\tt int16\_t} \\
{\sf U16}	& {\tt uint16\_t} \\
{\sf I32}	& {\tt int32\_t} \\
{\sf U32}	& {\tt uint32\_t} \\
{\sf I64}	& {\tt int64\_t} \\
{\sf U64}	& {\tt uint64\_t} \\
{\sf F32}	& {\tt float} \\
{\sf F64}	& {\tt double} \\
\end{tabular}

\vspace{1\baselineskip}
(b) Predefined functions.
\vspace{1\baselineskip}

\begin{tabular}{l|l|l|l|l}
Function & GraphBLAS             &                                                              & \\
type     & identifier            & Domains                                                      & Description \\ \hline
         & {\sf GrB\_NOP}        &                                                              & no operation \\
unary    & {\sf GrB\_LNOT}       & ${\tt bool} \rightarrow {\tt bool}$                          & logical inverse \\
unary    & {\sf GrB\_SCMP}       & ${\tt bool} \rightarrow {\tt bool}$                          & structural complement \\
binary   & {\sf GrB\_LAND}       & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$	& logical AND \\
binary   & {\sf GrB\_LOR}        & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$        & logical OR \\
binary   & {\sf GrB\_LXOR}       & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$        & logical XOR \\
binary   & {\sf GrB\_MIN\_$T$}   & $T \times T \rightarrow T$                                  & minimum \\
binary   & {\sf GrB\_MAX\_$T$}   & $T \times T \rightarrow T$                                  & maximum \\
binary   & {\sf GrB\_PLUS\_$T$}	 & $T \times T \rightarrow T$    				& addition \\
binary   & {\sf GrB\_MINUS\_$T$} & $T \times T \rightarrow T$    				& subtraction \\
binary   & {\sf GrB\_TIMES\_$T$} & $T \times T \rightarrow T$    				& multiplication \\
binary   & {\sf GrB\_DIV\_$T$}   & $T \times T \rightarrow T$    				& division \\
binary   & {\sf GrB\_EQ\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& equal \\
binary   & {\sf GrB\_NE\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& not equal \\
binary   & {\sf GrB\_GT\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& greater than  \\
binary   & {\sf GrB\_LT\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& less than  \\
binary   & {\sf GrB\_GE\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& greater than or equal \\
binary   & {\sf GrB\_LE\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& less than or equal \\
\end{tabular}
\end{center}
\hrule
\end{table}

\section{Index, Index Arrays and Scalar Arrays}

In order to interface with third-party software packages, operations like
buildMatrix (\S~\ref{Sec:buildMatrix})
and extractTuples (\S~\ref{Sec:extractTuples}) need to specify how the data should be
laid out in  non-opaque data structures.  To this end we define, explicitly
the types for indices and the arrays used by these operations.

For indices a typedef is used to give a GraphBLAS name to a concrete type. We define it as follows:

\begin{verbatim}
    typedef uint64_t GrB_Index;
\end{verbatim}

An index array is a pointer to a set of {\sf GrB\_Index} values that are stored in a contiguous block of memory (\ie, {\sf GrB\_Index*})

Likewise a scalar array is a pointer to a contiguous block of memory storing a number of scalar values as specified by the user.

\section{Execution model}

The purpose of most GraphBLAS operations is to manipulate GraphBLAS vectors and matrices
(the input arguments) and produce new content for another GraphBLAS vector or matrix (the output argument).
Each GraphBLAS operation uniquely and unambigiously defines the contents of its output argument.
Any later call to a GraphBLAS method that uses this matrix or vector will use its defined content, until
that content is redefined by another method.

GraphBLAS matrices and vectors are \emph{opaque} objects. That is, they can only be manipulated
by GraphBLAS methods. This opens a wide spectrum of optimizations that can be exploited by GraphBLAS implementations.
Deferred execution, lazy evaluation, chaining and fusion of operations, are all examples of optimizations
that can be used by a GraphBLAS implementation in a manner that is oblivious to the application program.

However, there are situations when this flexibility of the implementation to decide when (and if) an
operation is executed needs to be controlled. First, there are a few methods that use or produce transparent
(nonopaque) data structures. (See \S~\ref{Sec:buildMatrix}, \S~\ref{Sec:buildVector}, \S~\ref{Sec:extractTuples}, \S~\ref{Sec:extract_single_element}.) 
The application program needs to know that it is safe to modify or inspect
these data structures. (In other words, that the GraphBLAS run-time is done with them.)
Second, there are situations when one wants to make performance measurements of specific
GraphBLAS operations. Making measurements when the actual computation can be postponed or even 
eliminated can lead to unreliable and even misleading observations.

To address these situations, GraphBLAS includes a set of {\sf wait} methods. (See \S~\ref{Sec:wait}.)
When a call to {\sf wait} returns successfully, the calling program is guaranteed that all associated
pending operations have indeed completed. The set of pending operations addressed depends on the
particular variant of {\sf wait} method and is described in the appropriate section.

