\chapter{Basic concepts}

The GraphBLAS standard defines an API for constructing
graph algorithms expressed ``in the language of linear algebra''.
Graphs are expressed as matrices and the operations over 
these matrices are generalized through the use of the
semiring algebraic structure.

The mathematical definition of the GraphBLAS makes heavy use
of real arithmetic.   The GraphBLAS C binding is designed for
implementation on computers which by necessity have a finite number
of bits to represent numbers.   Therefore, even when the 
text of the specification refers to real numbers or real arithmetic, we 
expect a conforming implementation to use floating point numbers
as defined by the IEEE-754 standard.  The practical implications
of these finite precision numbers is that the result of a sequence
of computations may vary from one execution to the next as the
way operations are associated change.  While 
techniques are known to reduce these effects, we do not require or
even expect an implementation to use them as they add
considerable overhead.  The fact is that in most cases, these
roundoff errors are not significant and when they are, the problem
itself is ill-conditioned and needs to be reformulated.

In an algorithm, it is often beneficial to change the semiring
that applies to an operation on a matrix.  This has two 
implications on the C-binding to the GraphBLAS.  First,
it means that we define a separate object for the semiring 
that is passed into functions.  Since in many cases the full
semiring is not required, we also support passing monoids or
even functions; which basically means the semiring is implied but not 
explicitly stated.

Second, the ability to change semirings impacts the meaning of 
the implied ``zero'' in a sparse representation of a matrix.
This element in real arithmetic is zero which is the 
identity of the ``addition'' operator and the annihilator of
``multiplication'' operator.   As the semiring changes, this 
implied or ``structural'' zero changes to the identity of 
the ``addition'' operator and the annihilator of the ``multiplication'' 
operator for the new semiring.   Nothing changes in the
stored matrix, but the implied values within the sparse matrix change
with respect to a particular operation.  In most cases, the nature
of the implied zero does not matter since the GraphBLAS treats these
as elements of the matrix that do not exist.  As we will see, however,
there are a small subset of GraphBLAS functions 
(the element-wise operations) where to understand 
the function you need to understand the implied semiring.

In the remainder of this chapter we will cover the Domains of 
elements in the GraphBLAS.  We will then consider the functions
within the semiring and how they are managed within this specification.
We then describe indices, index arrays and scalar arrays used
to expose GraphBLAS objects to external packages.  Finally, we consider 
the execution model implied by the GraphBLAS C specification.

\section{Domains}

GraphBLAS defines two kinds of collections: matrices and vectors.
For any given collection, the elements of the collection belong to
a \emph{domain}, which is the set of valid values for the elements.
In GraphBLAS, domains correspond to the valid values for types from
the host language (in our case, the C programming language).  For any
variable or object $V$ in GraphBLAS we denote as $\bold{D}(V)$ the
domain of $V$; that is, the set of possible values that elements of
$V$ can take.  The predefined types and corresponding domains used in the 
GraphBLAS are shown in Table~\ref{Tab:PredefinedTypes}.  The Boolean
type is defined in {\tt stdbool.h}, the integral types are defined in
{\tt stdint.h}, and the floating-point types are native to the language.
GraphBLAS also supports user defined types. In that case, the domain is
the set of valid values for a variable of that type.

\begin{table}
\hrule
\begin{center}
\caption{Predefined {\sf GrB\_Type} values, the corresponding C type (for scalar
parameters, and domains for GraphBLAS. 
        \scott{Consider name change from GrB\_Type to GrB\_Domain}
        \aydin{There will be a way to introduce new GraphBLAS identifiers,
        similar to MPI\_Type\_Commit, these are just predefined stuff}
        \scott{An example would be nice, 
        especially where there is not a 1-to-1 correspondence to a built-in
        type, e.g. \{0,1\}.}}
\label{Tab:PredefinedTypes}
\begin{tabular}{l|l|l}
{\sf GrB\_Type values} & C type            & domain \\
\hline
{\sf GrB\_BOOL}        & {\tt bool}        & $\{ {\tt false}, {\tt true} \}$  \\
{\sf GrB\_INT8}        & {\tt int8\_t}     & $\mathbb{Z} \cap [-2^{7},2^{7})$  \\
{\sf GrB\_UINT8}       & {\tt uint8\_t}    & $\mathbb{Z} \cap [0,2{^8})$  \\
{\sf GrB\_INT16}       & {\tt int16\_t}    & $\mathbb{Z} \cap [-2^{15},2^{15})$ \\
{\sf GrB\_UINT16}      & {\tt uint16\_t}   & $\mathbb{Z} \cap [0,2^{16})$ \\
{\sf GrB\_INT32}       & {\tt int32\_t}    & $\mathbb{Z} \cap [-2^{31},2^{31})$ \\
{\sf GrB\_UINT32}      & {\tt uint32\_t}   & $\mathbb{Z} \cap [0,2^{32})$ \\
{\sf GrB\_INT64}       & {\tt int64\_t}    & $\mathbb{Z} \cap [-2^{63},2^{63})$ \\
{\sf GrB\_UINT64}      & {\tt uint64\_t}   & $\mathbb{Z} \cap [0,2^{64})$ \\
{\sf GrB\_FLOAT}       & {\tt float}       & IEEE 754 {\sf binary32}  \\
{\sf GrB\_DOUBLE}      & {\tt double}      & IEEE 754 {\sf binary64}  \\
\end{tabular}
\end{center}
\hrule
\end{table}

\section{Functions}

In GraphBLAS, a \emph{binary function} is a function that maps two input
values to one output value. A \emph{unary function} is a function that 
maps one input value to one output value. The value of the output is 
determined by the value of the input(s).  Binary functions are defined over 
two input domains and produce an output from a (possibly different) third 
domain. Unary functions are specified over one input domain and produce an 
output from a (possibly different) second domain.  The predefined functions 
of GraphBLAS are listed in Table~\ref{Tab:PredefinedFunctions}.

\begin{table}
\hrule
\begin{center}
\caption{Predefined unary and binary functions for GraphBLAS in C.}
\label{Tab:PredefinedFunctions}

\vspace{1\baselineskip}
(a) Valid suffixes and corresponding C type ($T$ in table (b)).
\vspace{1\baselineskip}

\begin{tabular}{l|l}
Suffix		& C type \\ \hline
{\sf B}		& {\tt bool} \\
{\sf I8}	& {\tt int8\_t} \\
{\sf U8}	& {\tt uint8\_t} \\
{\sf I16}	& {\tt int16\_t} \\
{\sf U16}	& {\tt uint16\_t} \\
{\sf I32}	& {\tt int32\_t} \\
{\sf U32}	& {\tt uint32\_t} \\
{\sf I64}	& {\tt int64\_t} \\
{\sf U64}	& {\tt uint64\_t} \\
{\sf F32}	& {\tt float} \\
{\sf F64}	& {\tt double} \\
\end{tabular}

\vspace{1\baselineskip}
(b) Predefined functions.
\vspace{1\baselineskip}

\begin{tabular}{l|l|l|l|l}
Function & GraphBLAS             &                                                              & \\
type     & identifier            & Domains                                                      & Description \\ \hline
         & {\sf GrB\_NOP}        &                                                              & no operation \\
unary    & {\sf GrB\_LNOT}       & ${\tt bool} \rightarrow {\tt bool}$                          & logical inverse \\
unary    & {\sf GrB\_SCMP}       & ${\tt bool} \rightarrow {\tt bool}$                          & structural complement \\
binary   & {\sf GrB\_LAND}       & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$	& logical AND \\
binary   & {\sf GrB\_LOR}        & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$        & logical OR \\
binary   & {\sf GrB\_LXOR}       & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$        & logical XOR \\
binary   & {\sf GrB\_MIN\_$T$}   & $T \times T \rightarrow T$                                  & minimum \\
binary   & {\sf GrB\_MAX\_$T$}   & $T \times T \rightarrow T$                                  & maximum \\
binary   & {\sf GrB\_PLUS\_$T$}	 & $T \times T \rightarrow T$    				& addition \\
binary   & {\sf GrB\_MINUS\_$T$} & $T \times T \rightarrow T$    				& subtraction \\
binary   & {\sf GrB\_TIMES\_$T$} & $T \times T \rightarrow T$    				& multiplication \\
binary   & {\sf GrB\_DIV\_$T$}   & $T \times T \rightarrow T$    				& division \\
binary   & {\sf GrB\_EQ\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& equal \\
binary   & {\sf GrB\_NE\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& not equal \\
binary   & {\sf GrB\_GT\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& greater than  \\
binary   & {\sf GrB\_LT\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& less than  \\
binary   & {\sf GrB\_GE\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& greater than or equal \\
binary   & {\sf GrB\_LE\_$T$}    & $T \times T \rightarrow {\tt bool}$        			& less than or equal \\
\end{tabular}
\end{center}
\hrule
\end{table}

\section{Indices, Index Arrays and Scalar Arrays}

In order to interface with third-party software packages, operations 
such as buildMatrix (\S~\ref{Sec:buildMatrix})
and extractTuples (\S~\ref{Sec:extractTuples}) must specify how 
the data should be laid out in  non-opaque data structures.  To 
this end we define, explicitly the types for indices and the arrays 
used by these operations.

For indices a typedef is used to give a GraphBLAS name to a concrete type. We define it as follows:

\begin{verbatim}
    typedef uint64_t GrB_Index;
\end{verbatim}

An index array is a pointer to a set of {\sf GrB\_Index} values that are 
stored in a contiguous block of memory (\ie, {\sf GrB\_Index*})

Likewise a scalar array is a pointer to a contiguous block of memory 
storing a number of scalar values as specified by the user.

\section{Execution model}

The purpose of most GraphBLAS functions is to manipulate GraphBLAS 
vectors and matrices (the input arguments) and produce new content for 
another GraphBLAS vector or matrix (the output argument).
Each GraphBLAS operation uniquely and unambiguously defines the 
contents of its output argument.  Any later call to a GraphBLAS function
that uses that output matrix or vector will use that defined content, 
until the GraphBLAS object in question is redefined by a call to 
a different GraphBLAS function.

GraphBLAS matrices and vectors are \emph{opaque} objects. They 
can only be manipulated by GraphBLAS functions. This gives an 
implementation of the GraphBLAS considerable freedom in how 
GraphBLAS functions execute. For example, consider a sequence 
of GraphBLAS function calls.  They are connected by GraphBLAS opaque
objects appearing as input and output arguments.  The functions
within the sequence occur in the order defined by the program.  
Since the values inside a GraphBLAS object are not visible until a 
function is called that reads values from a GraphBLAS object (e.g. 
a call to GrB\_ExtractTuples()),  any execution strategy that 
satisfies the mathematical definition of that sequence of 
GraphBLAS functions is allowed. The operations can be placed into
a queue and deferred.  They can be chained together and fused (e.g.
replacing a chained pair of matrix products with a matrix triple product).
Lazy evaluation, greedy evaluation or asynchronous execution are all
valid as long as the final result agrees with the mathematical 
definition provided by the sequence of GraphBLAS function calls
appearing in the program.

There are situations when this flexibility of the implementation 
to decide when (and if) an operation is executed needs to be constrained. 
First, there are a few methods that use or produce transparent
(nonopaque) data structures. (See \S~\ref{Sec:buildMatrix}, 
\S~\ref{Sec:buildVector}, \S~\ref{Sec:extractTuples}, 
\S~\ref{Sec:extract_single_element}.) The application program needs to 
know that it is safe to modify or inspect these data structures. 
(In other words, that the GraphBLAS run-time has completed the sequence
of GraphBLAS functions that defines the object in question).

Second, there are situations where the GraphBLAS operations need
to be ordered with respect to operations outside the GraphBLAS. This 
occurs when the GraphBLAS execute within concurrent threads or if they 
are being timed.  To address these situations, the GraphBLAS includes 
a set of {\sf wait} functions. (See \S~\ref{Sec:wait}.) When a 
call to {\sf wait} returns successfully, the calling program is 
guaranteed that all associated pending operations on GraphBLAS 
objects input to the {\sf wait} method have completed. The set 
of pending operations addressed depends on the particular variant 
of {\sf wait} method as described in section~\ref{Sec:wait}.

This flexible execution model complicates the GraphBLAS error model.
Each function in the GraphBLAS returns a value of type GrB\_info.
This references a structure which contains three fields:
\begin{itemize}
\item {\bf Status}: Defines the status of the function execution:  
\begin{itemize}
\item {\it Runnable}: if the function call passes static tests 
on its arguments and is ready to execute.  
\item {\it Successful}: if the sequence of operations the function
is contained within has completed and the function successfully completed
its operation in that sequence.
\item {\it Error}: if an error of some form occurred during the execution
of the function (i.e. an error other than those statically determined 
by the input arguments).
\end{itemize}
\item {\bf Info}: Describes the GraphBLAS error that occurred when the
function completes with the ``Error'' status.  These values
are defined in the definition of each GraphBLAS function. 
\item {\bf Details}: An optional null terminated string containing 
additional information about an error state.
\end{itemize}
The {\it Info} and {\it Details} fields are undefined if the {\it Status}
of a function is any value other than {\it Error}.   The error 
model, consistent with the flexibility afforded by the execution model, 
is only guaranteed to return correct information about the state of the 
computation when: (1) the sequence of operations connected to an object
completes and that object is read into a transparent data structure 
(e.g. a call to GrB\_extractTuple()); or (2) a call to one of the GrB\_wait()
functions containing the terminal output value from a GraphBLAS sequence 
returns.

 
