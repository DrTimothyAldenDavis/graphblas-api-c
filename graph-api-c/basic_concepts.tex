\chapter{Basic Concepts}
\label{Chp:Concepts}

The GraphBLAS C API is used to construct  
graph algorithms expressed ``in the language of linear algebra.''
Graphs are expressed as matrices, and the operations over 
these matrices are generalized through the use of a
semiring algebraic structure.

In this chapter, we will define the basic concepts used to
define the GraphBLAS C API.  We provide the following elements:
\begin{itemize}
\item Glossary of terms used in this document.  

\item Algebraic structures and associated arithmetic foundations of the API.

\item Domains of elements in the GraphBLAS.  

\item Functions that appear in the GraphBLAS algebraic 
structures and how they are managed.

\item Indices, index arrays, and scalar arrays used
to expose the contents of GraphBLAS objects.  

\item The execution and error models implied by the GraphBLAS C specification.

\end{itemize}

\section{Glossary}

\subsection{GraphBLAS API basic definitions}

\glossBegin

\glossItem{application} A program that calls methods from the GraphBLAS C API to
solve a problem.

\glossItem{GraphBLAS C API} The application programming interface that fully defines the types, objects, 
literals, and other elements of the C binding to the GraphBLAS.

\glossItem{function} Refers to a named group of statements in the C programming language.  Methods, operators,
and user-defined functions are typically implemented as C functions.
When referring to 
the code programmers write, as opposed to the role of functions as an element of the GraphBLAS, they may
be referred to as such.

\glossItem{method} A function defined in the GraphBLAS C API that manipulates
GraphBLAS objects or other opaque features of the implementation of the GraphBLAS API.

\glossItem{operator} A function that performs an operation on the elements stored in GraphBLAS matrices and vectors.

\glossItem{GraphBLAS operation} A mathematical operation defined in the
GraphBLAS mathematical specification. These operations (not to be confused with \emph{operators}) typically act
on matrices and vectors with elements defined in terms of an algebraic semiring. 
\glossEnd

\subsection{GraphBLAS objects and their structure}

\glossBegin
\glossItem{GraphBLAS object}  An instance of a data type defined by the GraphBLAS C
API that is opaque and manipulated only through the API. There are three groups of 
GraphBLAS objects: \emph{algebraic objects} (operators, monoids and semirings), 
\emph{collections} (vectors, matrices and masks), and descriptors.   Because the object
is based on an opaque datatype, an implementation of the GraphBLAS C API has the
flexibility to optimize data structures for a particular platform.  GraphBLAS objects
are often implemented as sparse data structures, meaning only the subset of the
elements that have non-zero values are stored.

\glossItem{handle}  A variable that uses one of the GraphBLAS opaque data types.
The value of this variable holds a reference to a GraphBLAS object but not the contents of the object itself.
Hence, assigning a value of one handle to another variable copies the reference to the GraphBLAS object
but not the contents of the object.

\glossItem{non-opaque datatype} Any datatype that exposes its internal structure.   
This is contrasted
with an \emph{opaque datatype} that hides its internal structure and can
be manipulated only through an API.

\glossItem{domain} The set of valid values for the elements of a GraphBLAS object.
Note that some GraphBLAS objects involve functions that map values from one or more input domains 
onto values in an output domain.  These GraphBLAS objects would have multiple domains.

\glossItem{implied zero}  Any element that has a valid index (or indices) 
in a GraphBLAS vector or matrix but is not explicitly identified in the list of 
elements of that vector or matrix. From a mathematical perspective, an
\emph{implied zero} is treated as having the 
value of the zero element of the relevant monoid or semiring.
However, GraphBLAS operations are purposefully defined using set notation in such a way
that it makes it unnecessary to reason about implied zeros. 
Therefore, this concept is not used in the definition of GraphBLAS methods and operators.

\glossItem{mask} An internal GraphBLAS object used to control how values 
are stored in a method's output object.  The mask exists only inside a method; hence,
it is called an \emph{internal opaque object}.  A mask is formed from the elements of
a collection object (vector or matrix) input as a mask parameter to a method. There
are two different operations for forming the internal mask.  

GraphBLAS allows two types of masks:
\begin{enumerate}
\item The default 
behavior is that an element of the mask exists for each element that exists in the 
input collection object when the value of that element cast to a Boolean type evaluates to 
{\tt true}.  
\item In the {\it structure only} case, masks have structure but no values. 
The input collection describes a structure whereby an 
element of the mask exists for each element of the input collection regardless of its value.
\end{enumerate}
%That is,
%while a tuple for a vector or matrix has indices and values,  tuples within a mask
%have indices but not values. Instead, we say that the tuples that exist within a mask
%have implied values of {\tt true}, and the tuples that do not exist within the mask have 
%implied values of {\tt false}. 
%\scott{STRUCTURE changes.}

\glossItem{complement} The \emph{complement} of a 
GraphBLAS mask, $M$, is another mask, $M'$, where the elements of $M'$
are those elements from $M$ that \emph{do not} exist.  

%In other words, 
%elements of $M$ with implied value {\tt true} are {\tt false} in $M'$
%while the structural zeros of $M$ with implied values {\tt false} 
%are {\tt true} in $M'$.


%\glossItem{structural complement} The \emph{structural complement} of a 
%GraphBLAS vector or matrix of any domain is another vector or matrix, 
%of domain {\tt bool}, in which the explicitly identified elements (with a value of {\tt true}) 
%are the \emph{structural zeroes} of the original vector or matrix 
%(which have an implied value of {\tt false}). 
\glossEnd



\subsection{Algebraic structures used in the GraphBLAS\scott{NEW CONTENT}}

\glossBegin
\glossItem{GraphBLAS operators} Binary or unary operators that act on elements of GraphBLAS 
objects.  \emph{GraphBLAS operators} are used to express algebraic structures used in the 
GraphBLAS such as monoids and semirings. There are two types of \emph{GraphBLAS operators}: 
(1) predefined operators found in Table~\ref{Tab:PredefOperators} and (2) user-defined 
operators created using {\sf GrB\_UnaryOp\_new()} or {\sf GrB\_BinaryOp\_new()} 
(see Section~\ref{Sec:AlgebraMethods}).

\glossItem{associative operator} In an expression where a binary operator is used 
two or more times consecutively, that operator is \emph{associative} if the result 
does not change regardless of the way operations are grouped (without changing their order). 
In other words, in a sequence of binary operations using the same associative 
operator, the legal placement of parenthesis does not change the value resulting 
from the sequence operations.  Operators that are associative over infinitely 
precise numbers (e.g., real numbers) are not strictly associative when applied to 
numbers with finite precision (e.g., floating point numbers). Such non-associativity 
results, for example, from roundoff errors or from the fact some numbers can not 
be represented exactly as floating point numbers.   In the GraphBLAS specification, 
as is common practice in computing, we refer to operators as \emph{associative} 
when their mathematical definition over infinitely precise numbers is associative 
even when they are only approximately associative when applied to finite precision 
numbers.

No GraphBLAS method will imply a predefined order over any associative operators. Implementations of the GraphBLAS are encouraged to exploit associativity to optimize performance of any GraphBLAS method. This holds even if the definition of the GraphBLAS method implies a fixed order for the associative operations.

\glossItem{monoid} An algebraic structure consisting of a domain, an associative 
binary operator, and an identity of that operator.  There are two types 
of \emph{GraphBLAS monoids}: (1) predefined monoids found in 
Table~\ref{Tab:PredefinedMonoids} and (2) user-defined monoids created using 
{\sf GrB\_Monoid\_new()} (see Section~\ref{Sec:AlgebraMethods}). 

\glossItem{semiring} An algebraic structure consisting of a set of allowed values
(the \emph{domain}), two commutative binary operators called addition 
and multiplication (where multiplication distributes over addition),
and identities over addition (\emph{0}) and multiplication (\emph{1}).  The additive
identity is an annihilator over multiplication.   
Note that a \emph{GraphBLAS semiring} is allowed to diverge from the mathematically 
rigorous definition of a semiring since certain combinations of domains, operators, and identity 
elements are useful in graph algorithms even when they do not strictly match the mathematical
definition of a semiring.
%do we need to define "annihilator"?
There are two types 
of \emph{GraphBLAS semirings}: (1) predefined semirings found in 
Tables~\ref{Tab:PredefinedTrueSemirings} and~\ref{Tab:PredefinedUsefulSemirings}, and (2) user-defined semirings created using 
{\sf GrB\_Semiring\_new()} (see Section~\ref{Sec:AlgebraMethods}).

\glossItem{index unary operator} A variation of the unary operator that operate
on elements of GraphBLAS vectors and matrices along with the index values 
representing their location in the objects.  There are predefined index unary
operators found in Table~\ref{Tab:PredefIndexOperators}), and user-defined
operators created using {\sf GrB\_IndexUnaryOp\_new} (see Section~\ref{Sec:AlgebraMethods}). \scott{NEW CONTENT}
\glossEnd

\subsection{The execution of an application using the GraphBLAS C API}

\glossBegin
\glossItem{program order} The order of the GraphBLAS method calls in a
thread, as defined by the text of the program.

\tim{
\glossItem{host programming environment} The GraphBLAS specification defines an API.  
The functions from the API appear in a program.  This program is written using a programming language
and execution environment defined outside of the GraphBLAS.  We refer to this programming environment
as the ``host programming environment''.

%\glossItem{execution time} The time it takes to execute a GraphBLAS
%method call. Implementations are free, but not mandated, to specify how
%the execution time of a method call can be retrieved.
\glossItem{execution time} time expended while executing instructions defined by a program.
This term is specifically used in this specification in the context of computations carried out on behalf of
a call to a GraphBLAS method.  
%% The original definition was too narrow by only referencing GraphBLAS methods.
%% Also, I didn't see the reason why the comment about execution time was retrieved was included.

\glossItem{sequence} A GraphBLAS application uniquely defines a directed
acyclic graph (DAG) of GraphLBAS method calls based on their program order.  
At any point in a program, the state of any GraphBLAS object is defined by a 
subgraph of that DAG.  An ordered collection of GraphBLAS method calls in program order that
defines that subgraph for a particular object is the \emph{sequence} for that object.  }

\comment{
\glossItem{sequence} A series of contiguous GraphBLAS method calls in a thread, 
in program order.  An implementation of the GraphBLAS may
reorder or even fuse GraphBLAS methods within a sequence as long as the
definitions of any GraphBLAS object that is later read by an application
are not changed; by ``read'' we mean that values are copied from an
opaque GraphBLAS object into a non-opaque object.

A sequence begins when a thread calls its first GraphBLAS method either
(1) after it starts executing or (2) after termination of the previous
sequence.  In blocking mode, every GraphBLAS method call is its own
sequence, and implicitly terminates it on return.  In nonblocking mode,
a sequence is terminated by either (1) a call to {\sf GrB\_finalize()}
or (2) a call to {\sf GrB\_wait()}.
}

\tim{
\glossItem{complete}  A GraphBLAS object defined on one thread is \emph{complete} when it can be safely used as an {\sf IN} or {\sf INOUT} argument
in a method-call on a second thread assuming the method calls are correctly synchronized so the definition on 
the first thread \emph{happens-before} it is used on the second thread.   This concept is used
when reasoning about memory orders in multithreaded programs.  In blocking-mode, an object is 
complete after a GraphBLAS method call that writes to that object returns.   In nonblocking-mode, an object is complete 
after a call to the {\sf GrB\_complete()} method.
}

\comment{
A GraphBLAS object is fully defined by the sequence
of method calls that produce the object as an output. In blocking mode,
each method call completes upon return. In non-blocking mode,
the execution of a method call may be deferred.  A method call with output
object {\sf obj} is said to be complete in non-blocking mode
when the first {\sf GrB\_wait(obj)} invoked after it has returned.
A complete method call cannot incur
additional execution time or generate additional errors.}

\comment{
\glossItem{materialize} To cause the values associated with an object to be
produced and stored 
in memory.  A GraphBLAS object has been 
\emph{materialized} when the computations that implement the mathematical definition 
of the object are {\it complete}. 
A GraphBLAS object that is never loaded into a non-opaque data structure may 
potentially never be materialized.  This might happen, for example, if the operations 
associated with the object are fused or otherwise changed by the runtime system 
that supports the implementation of the GraphBLAS C API.   
}

\tim{
\glossItem{materialize} A GraphBLAS object is materialized when it is (1) complete, (2) the computations 
defined by the sequence that define the object have finished (either fully or stopped at an error) and will not consume any 
additional computational resources, and (3) any errors associated with that sequence are available to be read according to the 
GraphBLAS error model.  A GraphBLAS object that is never loaded into a non-opaque data structure may 
potentially never be materialized.  This might happen, for example, if the operations 
associated with the object are fused or otherwise changed by the runtime system 
that supports the implementation of the GraphBLAS C API.   An object can be materialized by a call
to the {\sf GrB\_materialize()} method. 
}

\glossItem{context}  An instance of the GraphBLAS C API implementation
as seen by an application.  An application can have only one context between the 
start and end of the application.  
A context begins with the first thread that calls {\sf GrB\_init()} and ends with the 
first thread to call {\sf GrB\_finalize()}.  
It is an error for {\sf GrB\_init()} or {\sf GrB\_finalize()} to be called more than one
time within an application.  The context is used to constrain the behavior of an
instance of the GraphBLAS C API implementation and support various execution strategies.
Currently, the only
supported constraints on a context pertain to the mode of program execution.

\glossItem{mode} Defines how a GraphBLAS sequence executes, and is associated 
with the {\it context} of a GraphBLAS C API implementation. It is set by an 
application with its call to {\sf GrB\_init()} to one of two possible states.  
In \emph{blocking mode}, GraphBLAS methods return after the computations 
complete and any output objects have been materialized.  In {\it nonblocking mode}, a 
method may return once the arguments are tested as consistent with 
the method (\ie, there are no API errors), and potentially before any computation 
has taken place.
\glossEnd

\subsection{GraphBLAS methods: behaviors and error conditions}
\glossBegin
\glossItem{implementation defined behavior} Behavior that must be documented
by the implementation and is allowed to vary among different
compliant implementations. 

\glossItem{undefined behavior} Behavior that is not specified by the GraphBLAS C API.
A conforming implementation is free to choose results delivered from a method
whose behavior is undefined. 

\tim{
\glossItem{thread-safe}  Consider a function called from multiple threads with arguments that 
do not overlap in memory (i.e. the argument lists do not share memory).  If the function is \emph{thread-safe}
then it will behave the same when executed concurrently by multiple threads or sequentially on a single 
thread. }

\glossItem{shape compatible objects} GraphBLAS objects (matrices and vectors) that are
passed as parameters to a GraphBLAS method and have the correct number of dimensions 
and sizes for each dimension to satisfy the rules of the mathematical definition 
of the operation associated with the method.  This is also referred to as 
\emph{dimension compatible}.

\glossItem{domain compatible} Two domains for which values from one domain can be 
cast to values in the other domain as per the rules of the C language. In particular, 
domains from Table~\ref{Tab:PredefinedTypes} 
are all compatible with each other, and a domain from a user-defined type is only 
compatible with itself. If any \emph{domain compatibility} rule above is 
violated, execution of the GraphBLAS method ends and the domain 
mismatch error {\sf GrB\_DOMAIN\_MISMATCH} is returned.
\glossEnd

\vfill

\newgeometry{left=2.5cm,top=2cm,bottom=2cm}

\section{Notation}

\begin{tabular}[H]{l|p{5in}}
Notation & Description \\
\hline
$\Dout, \Dinn, \Din1, \Din2$  & Refers to output and input domains of various GraphBLAS operators. \\
$\bDout(*), \bDinn(*),$ & Evaluates to output and input domains of GraphBLAS operators (usually \\
~~~~$\bDin1(*), \bDin2(*)$ & a unary or binary operator, or semiring). \\
$\mathbf{D}(*)$   & Evaluates to the (only) domain of a GraphBLAS object (usually a monoid, vector, or matrix). \\ 
$f$             & An arbitrary unary function, usually a component of a unary operator. \\
$\mathbf{f}(F_u)$ & Evaluates to the unary function contained in the unary operator given as the argument. \\
$\odot$         & An arbitrary binary function, usually a component of a binary operator. \\
$\mathbf{\bigodot}(*)$ & Evaluates to the binary function contained in the binary operator or monoid given as the argument. \\
$\otimes$       & Multiplicative binary operator of a semiring. \\
$\oplus$        & Additive binary operator of a semiring. \\
$\mathbf{\bigotimes}(S)$ & Evaluates to the multiplicative binary operator of the semiring given as the argument. \\
$\mathbf{\bigoplus}(S)$ & Evaluates to the additive binary operator of the semiring given as the argument. \\
$\mathbf{0}(*)$   & The identity of a monoid, or the additive identity of a GraphBLAS semiring. \\
$\mathbf{L}(*)$   & The contents (all stored values) of the vector or matrix GraphBLAS objects.  For a vector, it is the set of (index, value) pairs, and for a matrix it is the set of (row, col, value) triples. \\
$\mathbf{v}(i)$ or $v_i$   & The $i^{th}$ element of the vector $\vector{v}$.\\
$\mathbf{size}(\vector{v})$ & The size of the vector $\vector{v}$.\\
$\mathbf{ind}(\vector{v})$ & The set of indices corresponding to the stored values of the vector $\vector{v}$.\\
$\mathbf{nrows}(\vector{A})$ & The number of rows in the $\matrix{A}$.\\
$\mathbf{ncols}(\vector{A})$ & The number of columns in the $\matrix{A}$.\\
$\mathbf{indrow}(\vector{A})$ & The set of row indices corresponding to rows in $\matrix{A}$ that have stored values.  \\
$\mathbf{indcol}(\vector{A})$ & The set of column indices corresponding to columns in $\matrix{A}$ that have stored values. \\
$\mathbf{ind}(\vector{A})$ & The set of $(i,j)$ indices corresponding to the stored values of the matrix. \\
$\mathbf{A}(i,j)$ or $A_{ij}$ & The element of $\matrix{A}$ with row index $i$ and column index $j$.\\
$\matrix{A}(:,j)$ & The $j^{th}$ column of the the matrix $\matrix{A}$.\\
$\matrix{A}(i,:)$ & The $i^{th}$ row of the the matrix $\matrix{A}$.\\
$\matrix{A}^T$ &The transpose of the matrix $\matrix{A}$. \\
$\neg\matrix{M}$ & The complement of $\matrix{M}$.\\
$\vector{\widetilde{t}}$ & A temporary object created  by the GraphBLAS implementation. \\
$<type>$ & A method argument type that is {\sf void *} or one of the types from Table~\ref{Tab:PredefinedTypes}. \\
{\sf GrB\_ALL} & A method argument literal to indicate that all indices of an input array should be used.\\
{\sf GrB\_Type} & A method argument type that is either a user defined type or one of the  types from Table~\ref{Tab:PredefinedTypes}.\\
{\sf GrB\_Object} &  A method argument type referencing any of the GraphBLAS object types.\\
{\sf GrB\_NULL} & The GraphBLAS NULL.\\
\end{tabular}

\restoregeometry


\section{Algebraic and Arithmetic Foundations}

Graphs can be represented in terms of matrices. Operations defined by the GraphBLAS standard
operate on these matrices to construct graph algorithms.
These GraphBLAS operations are defined in terms of GraphBLAS semiring algebraic 
structures. Modifying the underlying semiring changes the result of 
an operation to support a wide range of graph algorithms.

Inside a given algorithm, it is often beneficial to change the GraphBLAS semiring
that applies to an operation on a matrix.  This has two 
implications for the C binding of the GraphBLAS API.  First,
it means that we define a separate object for the semiring 
to pass into functions.  Since in many cases the full
semiring is not required, we also support passing monoids or
even binary operators, which means the semiring is implied rather than 
explicitly stated.

Second, the ability to change semirings impacts the meaning of 
the \emph{implied zero} in a sparse representation of a matrix.
This element in real arithmetic is zero, which is the 
identity of the \emph{addition} operator and the annihilator of the
\emph{multiplication} operator.  As the semiring changes, this 
implied zero changes to the identity of 
the \emph{addition} operator and the annihilator of the \emph{multiplication} 
operator for the new semiring. Nothing changes in the stored matrix, but the 
implied zeros within the sparse matrix or vector change with respect to a particular operation. In all cases, 
the nature of the implied zero does not matter since the GraphBLAS C API treats them as nonexistent elements of the matrix or vector.

%Nothing changes in the
%stored matrix, but the implied values within the sparse matrix change
%with respect to a particular operation.  In most cases, the nature
%of the implied zero does not matter since the GraphBLAS treats these
%as elements of the matrix that do not exist.  As we will see, however,
%there is a small subset of GraphBLAS methods 
%(the element-wise operations) where to understand 
%the method you need to understand the implied zero.

The mathematical formalism for graph operations in the language of 
linear algebra assumes that we can operate in the field of real numbers. 
However, the GraphBLAS C binding is designed for implementation on computers, 
which by necessity have a finite number of bits to represent numbers. 
Therefore, we require a conforming implementation to use floating point 
numbers such as those defined by the IEEE-754 standard (both single- and double-precision) 
wherever real numbers need to be represented. The practical implications of 
these finite precision numbers is that the result of a sequence of 
computations may vary from one execution to the next as the association 
of operations changes.  While techniques are known to 
reduce these effects, we do not require or even expect an implementation 
to use them as they may add considerable overhead. In most 
cases, these roundoff errors are not significant. When they are significant, 
the problem itself is ill-conditioned and needs to be reformulated.

\section{GraphBLAS Opaque Objects \scott{NEW CONTENT}}

Objects defined in the GraphBLAS standard include collections of elements
(matrices, vectors, and scalars), operators on those elements (unary and binary operators), and 
algebraic structures (semirings and monoids).   GraphBLAS objects are defined
as opaque types; that is, they are managed, manipulated, and accessed solely through the
GraphBLAS application programming interface. This gives an implementation of the
GraphBLAS C specification flexibility to optimize objects for different scenarios or to meet
the needs of different hardware platforms.

A GraphBLAS opaque object is accessed through its handle.  A handle
is a variable that uses one of the types from Table~\ref{Tab:ObjTypes}.  An implementation 
of the GraphBLAS specification has a great deal of flexibility in how these
handles are implemented.  All that is required is that the handle corresponds to a type defined in the 
C language that supports assignment and comparison for equality.  The
GraphBLAS specification defines a 
literal {\sf GrB\_INVALID\_HANDLE} that is valid for each type.  Using the logical equality 
operator from C, it must be possible to compare a handle to {\sf GrB\_INVALID\_HANDLE}
to verify that a handle is valid.


\begin{table}
\hrule
\begin{center}
\caption{GraphBLAS opaque objects and their types.}
\label{Tab:ObjTypes}
~\\
\begin{tabular}{l|l}
{\sf GrB\_Object types} & Description \\
\hline
{\sf GrB\_Type}           & User-defined scalar type.     \\
{\sf GrB\_UnaryOp}        & Unary operator, built-in or associated with a single-argument C function.     \\
{\sf GrB\_BinaryOp}       & Binary operator, built-in or associated with a two-argument C function.     \\
{\sf GrB\_Monoid}         & Monoid algebraic structure.     \\
{\sf GrB\_Semiring}       & A GraphBLAS semiring algebraic structure.     \\
{\sf GrB\_Matrix}         & Two-dimensional collection of elements; typically sparse.    \\
{\sf GrB\_Vector}         & One-dimensional collection of elements.     \\
{\sf GrB\_Scalar}         & One element; could be empty. \\
{\sf GrB\_Descriptor}     & Descriptor object, used to modify behavior of methods.     \\
\end{tabular}
\end{center}
\hrule
\end{table}

An application using the GraphBLAS API will declare variables of the appropriate
type for the objects it will use.  Before use, the object must be initialized (constructed) with 
the appropriate method.  This is typically done with one of the methods that has a ``{\sf \_new}'' suffix in its 
name (e.g., {\sf GrB\_Vector\_new}).  If available, an object can also be initialized by duplicating
an existing object with one of the methods that has the ``{\sf \_dup}'' suffix in its 
name  (e.g., {\sf GrB\_Vector\_dup}).  Note that there are other valid constructor methods included in 
the API (e.g., ``{\sf \_diag}'', ``{\sf \_import}'', and ``{\sf \_deserialize}'' matrix methods).
Regardless of the method of construction, any resources associated with that object can be released by a
call to the {\sf GrB\_free} method when an application is finished with 
an object.    

These {\sf new}, {\sf dup}, and {\sf free} methods are the only methods that 
change the value of a handle.  Hence, objects changed by these methods are passed
into the method as pointers.  In all other cases, handles are not changed by the 
method and are passed by value.  For example, even when multiplying matrices, 
while the contents of the output product matrix changes, the handle for that matrix is unchanged. 

Programmers using GraphBLAS handles must be careful to distinguish between a handle and the 
object manipulated through a handle.  For example, a program may declare two 
GraphBLAS objects of the same type, initialize one, and then assign it to the other
variable.  That assignment, however, only assigns the handle to the variable.  It does not 
create a copy of that variable (to do that, one would need to use the appropriate duplication method).
If later the object is freed by calling {\sf GrB\_free} with the first variable, the object
is destroyed and the second variable is left referencing an object that no longer 
exists (a so-called ``dangling handle'').

In addition to opaque objects manipulated through handles, the GraphBLAS C API defines
an additional opaque object as an internal object; that is, the object is never exposed as
a variable within an application.  This opaque object is the mask used to
control how computed values are stored in the output from a method.  Masks 
are described in Section~\ref{Sec:Masks}.

\section{Non-Opaque Objects}

We also define a number of data formats for non-opaque objects, which are useful
for importing and exporting data to and from opaque GraphBLAS objects.

\subsection{Indices, Index Arrays, and Scalar Arrays}

In order to interface with third-party software (\ie, software other than
an implementation of the GraphBLAS), operations 
such as {\sf GrB\_Matrix\_build} (Section~\ref{Sec:Matrix_build}) and
{\sf GrB\_Matrix\_extractTuples} (Section~\ref{Sec:Matrix_extractTuples}) must specify
how the data should be laid out in  non-opaque data structures.  To 
this end we explicitly define the types for indices and the arrays 
used by these operations.

For indices a {\sf typedef} is used to give a GraphBLAS name to a concrete type. We define it as follows:

\begin{verbatim}
    typedef uint64_t GrB_Index;
\end{verbatim}

An index array is a pointer to a set of {\sf GrB\_Index} values that are 
stored in a contiguous block of memory (\ie, {\sf GrB\_Index*}).
Likewise, a scalar array is a pointer to a contiguous block of memory 
storing a number of scalar values as specified by the user.
Some GraphBLAS operations (\eg, {\sf GrB\_assign})  include an input parameter with the type of an index array. 
This input index array selects a subset of elements from a GraphBLAS vector object to be used in the operation.
In these cases, the literal {\sf GrB\_ALL} 
can be used in place of the index array input parameter to indicate that all indices 
of the associated GraphBLAS vector object should be used.
As with any literal defined in the GraphBLAS, an implementation of the GraphBLAS C API has considerable 
freedom in terms of how {\sf GrB\_ALL} is defined.  Since {\sf GrB\_ALL} is used as an argument for an array 
parameter, it must use a type consistent with a pointer. {\sf GrB\_ALL} must also have a non-null
value to distinguish it from the erroneous case of passing a {\sf NULL} pointer as an array.

\subsection{External Matrix Formats}
We also define a number of commonly used formats, such as dense matrices in
row-major and column-major formats and sparse matrices in COO, CSR, and CSC
formats.  When
importing or exporting a matrix to or from a GraphBLAS object using
{\sf GrB\_Matrix\_import} or {\sf GrB\_Matrix\_export}, it is necessary to
specify the data format for the matrix data external to GraphBLAS, which is
being imported from or exported to.  This non-opaque data format is specified
using an argument of type {\sf GrB\_Format}, which is used to indicate one of a
number of pre-defined formats.  The pre-defined values of {\sf GrB\_Format} are
specified in Table~\ref{Tab:GrB_Format}.  An precise definition of the non-opaque
data formats can be found in Appendix~\ref{Chp:GrB_Format}.

\begin{table}[bh]
\hrule
\begin{center}
\caption{Pre-defined values of {\sf GrB\_Format}.}
\label{Tab:GrB_Format}
\begin{tabular}{l|r|p{3in}}
Symbol    & Value & Description \\ \hline
{\sf GrB\_CSR\_FORMAT} & 0 & Specifies the compressed sparse row matrix format.\\
\hline
{\sf GrB\_CSC\_FORMAT} & 1 & Specifies the compressed sparse column matrix format.\\
\hline
{\sf GrB\_COO\_FORMAT} & 2 & Specifies the sparse coordinate matrix format.\\
\hline
{\sf GrB\_DENSE\_ROW\_FORMAT} & 3 & Specifies the dense row-major matrix format.\\
\hline
{\sf GrB\_DENSE\_COL\_FORMAT} & 4 & Specifies the dense column-major matrix format.\\
\end{tabular}
\end{center}
\hrule
\end{table}

\section{Domains}

GraphBLAS defines two kinds of collections: matrices and vectors.
For any given collection, the elements of the collection belong to
a \emph{domain}, which is the set of valid values for the elements.
In GraphBLAS, domains correspond to the valid values for types from the
host language (in our case, the C programming language).  For any variable
or object $V$ in GraphBLAS we denote as $\mathbf{D}(V)$ the domain of $V$,
that is, the set of possible values that elements of $V$ can take.

The predefined types and corresponding domains used in the GraphBLAS C API are
shown in Table~\ref{Tab:PredefinedTypes}.  The Boolean type ({\tt bool})
is defined in {\tt stdbool.h}, the integral types ({\tt int8\_t},
{\tt uint8\_t}, {\tt int16\_t}, {\tt uint16\_t}, {\tt int32\_t},
{\tt uint32\_t}, {\tt int64\_t}, {\tt uint64\_t}) are defined in {\tt
stdint.h}, and the floating-point types ({\tt float}, {\tt double}) are
native to the language and in most cases defined by the IEEE-754 standard.

\begin{table}
\hrule
\begin{center}
\caption{Predefined {\sf GrB\_Type} values, the corresponding C type (for scalar
parameters), and domains for GraphBLAS.}
\label{Tab:PredefinedTypes}
\begin{tabular}{l|l|l}
{\sf GrB\_Type values} & C type            & domain \\
\hline
{\sf GrB\_BOOL}        & {\tt bool}        & $\{ {\tt false}, {\tt true} \}$  \\
{\sf GrB\_INT8}        & {\tt int8\_t}     & $\mathbb{Z} \cap [-2^{7},2^{7})$  \\
{\sf GrB\_UINT8}       & {\tt uint8\_t}    & $\mathbb{Z} \cap [0,2{^8})$  \\
{\sf GrB\_INT16}       & {\tt int16\_t}    & $\mathbb{Z} \cap [-2^{15},2^{15})$ \\
{\sf GrB\_UINT16}      & {\tt uint16\_t}   & $\mathbb{Z} \cap [0,2^{16})$ \\
{\sf GrB\_INT32}       & {\tt int32\_t}    & $\mathbb{Z} \cap [-2^{31},2^{31})$ \\
{\sf GrB\_UINT32}      & {\tt uint32\_t}   & $\mathbb{Z} \cap [0,2^{32})$ \\
{\sf GrB\_INT64}       & {\tt int64\_t}    & $\mathbb{Z} \cap [-2^{63},2^{63})$ \\
{\sf GrB\_UINT64}      & {\tt uint64\_t}   & $\mathbb{Z} \cap [0,2^{64})$ \\
{\sf GrB\_FP32}        & {\tt float}       & IEEE 754 {\sf binary32}  \\
{\sf GrB\_FP64}        & {\tt double}      & IEEE 754 {\sf binary64}  \\
\end{tabular}
\end{center}
\hrule
\end{table}

\section{Operators and Associated Functions \scott{NEW CONTENT}}

GraphBLAS operators act on elements of GraphBLAS objects. A \emph{binary
operator} is a function that maps two input values to one output value. A
\emph{unary operator} is a function that maps one input value to one
output value. The value of the output is determined by the value of
the input(s).  Binary operators are defined over two input domains
and produce an output from a (possibly different) third domain. Unary
operators are specified over one input domain and produce an output from a
(possibly different) second domain.

{\color{red}
In addition, to the operators above that operate on stored values, GraphBLAS
also supports an \emph{index unary operator} that maps one
stored value and the indices of its position in the matrix or vector to an output value.
That output value can be used in the index unary operator variants of apply to compute a
new stored value, or be used in the select operation to determine if the
stored input value should be kept or annihilated.
}

Similar to GraphBLAS types with predefined types and user-defined types,
GraphBLAS operators come in two types: (1) predefined operators found
in Table~\ref{Tab:PredefOperators} and (2) user-defined operators
using {\sf GrB\_UnaryOp\_new()}, {\sf GrB\_BinaryOp\_new()}, or 
{\sf GrB\_IndexUnaryOp\_new()} (see Section~\ref{Sec:AlgebraMethods}). \scott{NEW CONTENT}

Likewise, a list of predefined monoids, true semirings and convenience
semirings can be found in Tables~\ref{Tab:PredefinedMonoids},
\ref{Tab:PredefinedTrueSemirings} and~\ref{Tab:PredefinedUsefulSemirings},
respectively.  Predefined monoids are named {\sf
GrB\_\emph{op}\_MONOID\_$T$}, where \emph{op} is the name of the
predefined GraphBLAS operator used as the associative binary operation
of the monoid and $T$ is the domain (type) of the monoid.  Predefined
semirings are named {\sf GrB\_\emph{add}\_\emph{mul}\_SEMIRING\_$T$},
where \emph{add} is the semiring additive operation, \emph{mul} is
the semiring multiplicative operation and $T$ is the domain (type)
of the semiring.

The multiplicative inverse ({\sf GrB\_MINV\_$F$}) function is only defined
for floating-point types ($F = $ {\sf FP32} or {\sf FP64}).  The division
({\sf GrB\_DIV\_$T$}) function is defined for all types, but only if $y
\neq 0$ for integral types and $y \neq {\tt false}$ for the Boolean type.

%====================

\begin{table}
\hrule
\begin{center}
\caption{Valid GraphBLAS domain suffixes and corresponding C types (for $I$ and 
$T$ in Tables~\ref{Tab:PredefOperators}, \ref{Tab:PredefinedMonoids}, 
    \ref{Tab:PredefinedTrueSemirings}, 
and~\ref{Tab:PredefinedUsefulSemirings}).}
\label{Tab:PredefinedDomains}

\vspace{1\baselineskip}

\begin{tabular}{l|l}
Suffix            & C type \\ \hline
{\sf BOOL}        & {\tt bool} \\
{\sf INT8}        & {\tt int8\_t} \\
{\sf UINT8}       & {\tt uint8\_t} \\
{\sf INT16}       & {\tt int16\_t} \\
{\sf UINT16}      & {\tt uint16\_t} \\
{\sf INT32}       & {\tt int32\_t} \\
{\sf UINT32}      & {\tt uint32\_t} \\
{\sf INT64}       & {\tt int64\_t} \\
{\sf UINT64}      & {\tt uint64\_t} \\
{\sf FP32}        & {\tt float} \\
{\sf FP64}        & {\tt double} \\
\end{tabular}
\end{center}
\hrule
\end{table}

%====================
\begin{table}
\hspace*{-2.5em}\begin{threeparttable}
\hrule
\caption{Predefined unary and binary operators for GraphBLAS in C.  The $T$ can 
be any suffix from Table~\ref{Tab:PredefinedDomains}, $I$ can be any integer 
suffix from Table~\ref{Tab:PredefinedDomains}, and $F$ can be any floating-point suffix from Table~\ref{Tab:PredefinedDomains}.}
\label{Tab:PredefOperators}
\vspace{1\baselineskip}

\begin{tabular}{l|l|l|ll}
Operator & GraphBLAS             &                                                              & \\
type     & identifier            & Domains                                              & Description \\ \hline
{\sf GrB\_UnaryOp}    & {\sf GrB\_IDENTITY\_$T$} & $T \rightarrow T $     & $f(x) = x$, &identity \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_ABS\_$T$}      & $T \rightarrow T $     & $f(x) = |x|$, &absolute value \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_AINV\_$T$}     & $T \rightarrow T $     & $f(x) = -x$, &additive inverse \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_MINV\_$F$}     & $F \rightarrow F $     & $f(x) = \frac{1}{x}$, &multiplicative inverse \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_LNOT}          & ${\tt bool} \rightarrow {\tt bool}$  & $f(x) =~\neg x$, &logical inverse  \\
{\sf GrB\_UnaryOp}    & {\sf GrB\_BNOT\_$I$}     & $I \rightarrow I$      & $f(x) =~\mbox{\~{}} x$, &bitwise complement \\

&&&\\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LOR}        & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$ & $f(x,y) = x \lor y$, & logical OR \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LAND}       & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$ & $f(x,y) = x \land y$, & logical AND \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LXOR}       & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$ & $f(x,y) = x \oplus y$, & logical XOR \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LXNOR}      & ${\tt bool} \times {\tt bool} \rightarrow {\tt bool}$ & $f(x,y) = \overline{x \oplus y}$, & logical XNOR \\

{\sf GrB\_BinaryOp}   & {\sf GrB\_BOR\_$I$}   & $I \times I \rightarrow I$ & $f(x,y) = x ~|~ y$, & bitwise OR \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_BAND\_$I$}  & $I \times I \rightarrow I$ & $f(x,y) = x ~\&~ y$, & bitwise AND \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_BXOR\_$I$}  & $I \times I \rightarrow I$ & $f(x,y) = x ~\mbox{\^{}}~ y$, & bitwise XOR \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_BXNOR\_$I$} & $I \times I \rightarrow I$ & $f(x,y) = \overline{x ~\mbox{\^{}}~ y}$, & bitwise XNOR \\

{\sf GrB\_BinaryOp}   & {\sf GrB\_EQ\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x == y)$ & equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_NE\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x \neq y)$ & not equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_GT\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x > y)$ & greater than  \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LT\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x < y)$ & less than  \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_GE\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x \geq y)$ & greater than or equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_LE\_$T$}    & $T \times T \rightarrow {\tt bool}$  & $f(x,y) = (x \leq y)$ & less than or equal \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_FIRST\_$T$} & $T \times T \rightarrow T$  & $f(x,y) = x$, & first argument \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_SECOND\_$T$}& $T \times T \rightarrow T$  & $f(x,y) = y$, & second argument \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_MIN\_$T$}   & $T \times T \rightarrow T$  & $f(x,y) = (x < y)~?~x : y$, & minimum \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_MAX\_$T$}   & $T \times T \rightarrow T$  & $f(x,y) = (x > y)~?~x : y$, & maximum \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_PLUS\_$T$}  & $T \times T \rightarrow T$  & $f(x,y) = x + y$, & addition \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_MINUS\_$T$} & $T \times T \rightarrow T$  & $f(x,y) = x - y$, & subtraction \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_TIMES\_$T$} & $T \times T \rightarrow T$  & $f(x,y) = xy$, & multiplication \\
{\sf GrB\_BinaryOp}   & {\sf GrB\_DIV\_$T$}   & $T \times T \rightarrow T$  & $f(x,y) = \frac{x}{y}$, & division \\
\end{tabular}
\hrule
\comment{
{\sf GrB\_BinaryOp}   & {\sf GrB\_ANY\_$T$}   & $T \times T \rightarrow T$  & $f(x,y) = $ either $x$ or $y$, & either input operand\tnote{1} \\
\begin{tablenotes}
    \item[1] For {\sf GrB\_ANY}, an implementation is free to return either input operand, and is not required to always return the same operand in different invocations.
\end{tablenotes}
}
\end{threeparttable}
\end{table}

%==================

\begin{table}
\centering
\begin{threeparttable}
\hrule
\caption{Predefined monoids for GraphBLAS in C. Maximum and minimum values for the 
various integral types are defined in {\tt stdint.h}. Floating-point infinities are 
defined in {\tt math.h}. The $x$ in {\sf UINT}$x$ or {\sf INT}$x$ can be one of 8, 
16, 32, or 64; whereas in {\sf FP}$x$, it can be 32 or 64.}
\label{Tab:PredefinedMonoids}
\vspace{1\baselineskip}

\begin{tabular}{l|l|l|l}
GraphBLAS                   & Domains, $T$           &               & \\
identifier                  & ($T \times T \rightarrow T$) & Identity      & Description \\ \hline
{\sf GrB\_PLUS\_MONOID\_$T$}  & {\sf UINT}$x$  & 0    & addition \\
                            & {\sf INT}$x$   & 0    & \\
                            & {\sf FP}$x$    & 0    & \\
{\sf GrB\_TIMES\_MONOID\_$T$} & {\sf UINT}$x$  & 1    & multiplication \\
                            & {\sf INT}$x$   & 1    & \\
                            & {\sf FP}$x$    & 1    & \\
{\sf GrB\_MIN\_MONOID\_$T$}   & {\sf UINT}$x$  & {\tt UINT$x$\_MAX}  & minimum \\
                            & {\sf INT}$x$   & {\tt INT$x$\_MAX}  & \\
                            & {\sf FP}$x$    & {\tt INFINITY}   & \\
{\sf GrB\_MAX\_MONOID\_$T$}   & {\sf UINT}$x$  & 0                & maximum \\
                            & {\sf INT}$x$   & {\tt INT$x$\_MIN}  & \\
                            & {\sf FP}$x$    & {\tt -INFINITY}   & \\
\comment{
{\sf GrB\_ANY\_MONOID\_$T$}   & $T$    & (implicit)   & either input\tnote{1} \\
                            & & & \\
}
                               & & & \\
{\sf GrB\_LOR\_MONOID\_BOOL}   & {\sf BOOL}  & {\tt false}   & logical OR \\
{\sf GrB\_LAND\_MONOID\_BOOL}  & {\sf BOOL}  & {\tt true}    & logical AND \\
{\sf GrB\_LXOR\_MONOID\_BOOL}  & {\sf BOOL}  & {\tt false}   & logical XOR (not equal) \\
{\sf GrB\_LXNOR\_MONOID\_BOOL} & {\sf BOOL}  & {\tt true}    & logical XNOR (equal) \\
\end{tabular}
\hrule
\comment{
\begin{tablenotes}
    \item[1] For {\sf GrB\_ANY\_MONOID\_T}, an implementation is free to return either input operand, and is not required to always return the same operand in different invocations.  The identity of this monoid is not defined and therefore should not be used in {\sf GrB\_reduce} variants that produce scalars (where an identity could be needed).
\end{tablenotes}
}
\end{threeparttable}
\end{table}

%==================

\begin{table}
\centering
\begin{threeparttable}
\hrule
\caption{Predefined true semirings where the additive identity is the multiplicative 
annihilator. The $x$ in {\sf UINT$x$} or {\sf INT$x$} can be one of 8, 16, 32, or 64; 
whereas in {\sf FP$x$}, it can be 32 or 64.}
\label{Tab:PredefinedTrueSemirings}

\hspace*{-1.5em}
\begin{tabular}{l|l|l|l}
                                      & Domains, $T$             & $+$ identity         &                 \\
GraphBLAS identifier              & ($T \times T \rightarrow T$) & $\times$ annihilator & Description     \\ \hline
{\sf GrB\_PLUS\_TIMES\_SEMIRING\_$T$}   & {\sf UINT$x$}            & 0                    & arithmetic semiring \\
                                      & {\sf INT$x$}             & 0                    &                 \\
                                      & {\sf FP$x$}              & 0                    &                 \\
{\sf GrB\_MIN\_PLUS\_SEMIRING\_$T$}     & {\sf UINT$x$}            & {\tt UINT$x$\_MAX}   & min-plus semiring  \\
                                      & {\sf INT$x$}             & {\tt INT$x$\_MAX}    &                 \\
                                      & {\sf FP$x$}              & {\tt INFINITY}       &                 \\
{\sf GrB\_MAX\_PLUS\_SEMIRING\_$T$}     & {\sf INT$x$}             & {\tt INT$x$\_MIN}    & max-plus semiring  \\
                                      & {\sf FP$x$}              & {\tt -INFINITY}      &                 \\
{\sf GrB\_MIN\_TIMES\_SEMIRING\_$T$}    & {\sf UINT$x$}            & {\tt UINT$x$\_MAX}   & min-times semiring \\
{\sf GrB\_MIN\_MAX\_SEMIRING\_$T$}      & {\sf UINT$x$}            & {\tt UINT$x$\_MAX}   & min-max semiring   \\
                                      & {\sf INT$x$}             & {\tt INT$x$\_MAX}    &                 \\
                                      & {\sf FP$x$}              & {\tt INFINITY}       &                 \\
{\sf GrB\_MAX\_MIN\_SEMIRING\_$T$}      & {\sf UINT$x$}            & 0                    & max-min semiring   \\
                                      & {\sf INT$x$}             & {\tt INT$x$\_MIN}    &                 \\
                                      & {\sf FP$x$}              & {\tt -INFINITY}      &                 \\
{\sf GrB\_MAX\_TIMES\_SEMIRING\_$T$}    & {\sf UINT$x$}            & 0                    & max-times semiring \\
{\sf GrB\_PLUS\_MIN\_SEMIRING\_$T$}     & {\sf UINT$x$}            & 0                    & plus-min semiring  \\
                                      &                          &                      &                 \\
{\sf GrB\_LOR\_LAND\_SEMIRING\_BOOL}  & {\sf BOOL}               & {\tt false}          & Logical semiring   \\
{\sf GrB\_LAND\_LOR\_SEMIRING\_BOOL}  & {\sf BOOL}               & {\tt true}           & "and-or" semiring  \\
{\sf GrB\_LXOR\_LAND\_SEMIRING\_BOOL} & {\sf BOOL}               & {\tt false}          & same as {\sf NE\_LAND} \\
{\sf GrB\_LXNOR\_LOR\_SEMIRING\_BOOL} & {\sf BOOL}               & {\tt true}           & same as {\sf EQ\_LOR} \\
\end{tabular}

\hrule
\comment{
\begin{tablenotes}
    \item[1] For {\sf GrB\_ANY\_*\_SEMIRING\_T}, an implementation is free to return any of the results of the application of the "multiply" operator ({\sf FIRST} or {\sf SECOND}), and is not required to always return the same result in different invocations..
\end{tablenotes}
}
\end{threeparttable}
\end{table}

\begin{table}
\centering
\begin{threeparttable}
\hrule
\caption{Other useful predefined semirings that don't have a multiplicative annihilator. The $x$ in {\sf UINT$x$} or {\sf INT$x$} can be one of 8, 16, 32, or 64; whereas in {\sf FP$x$}, it can be 32 or 64.}
\label{Tab:PredefinedUsefulSemirings}

\hspace*{-1.5em}
\begin{tabular}{l|l|l|l}
                                    & Domains, $T$             &            &                 \\
GraphBLAS identifier           & ($T \times T \rightarrow T$)  & $+$ identity      & Description             \\ \hline
{\sf GrB\_MAX\_PLUS\_SEMIRING\_$T$}   & {\sf UINT$x$}            & 0                 & max-plus semiring         \\
{\sf GrB\_MIN\_TIMES\_SEMIRING\_$T$}  & {\sf INT$x$}             & {\tt INT$x$\_MAX} & min-times semiring        \\
                                    & {\sf FP$x$}              & {\tt INFINITY}    &                  \\
{\sf GrB\_MAX\_TIMES\_SEMIRING\_$T$}  & {\sf INT$x$}             & {\tt INT$x$\_MIN} & max-times semiring        \\
                                    & {\sf FP$x$}              & {\tt -INFINITY}   &                 \\
{\sf GrB\_PLUS\_MIN\_SEMIRING\_$T$}   & {\sf INT$x$}             & 0                 & plus-min semiring          \\
                                    & {\sf FP$x$}              & 0                 &                 \\ 
{\sf GrB\_MIN\_FIRST\_SEMIRING\_$T$}  & {\sf UINT$x$}            & {\tt UINT$x$\_MAX}& min-select first  semiring     \\
                                    & {\sf INT$x$}             & {\tt INT$x$\_MAX} &                 \\
                                    & {\sf FP$x$}              & {\tt INFINITY}    &                 \\
{\sf GrB\_MIN\_SECOND\_SEMIRING\_$T$} & {\sf UINT$x$}            & {\tt UINT$x$\_MAX}& min-select second semiring     \\
                                    & {\sf INT$x$}             & {\tt INT$x$\_MAX} &                 \\
                                    & {\sf FP$x$}              & {\tt INFINITY}    &                 \\
{\sf GrB\_MAX\_FIRST\_SEMIRING\_$T$}  & {\sf UINT$x$}            & 0                 & max-select first  semiring     \\
                                    & {\sf INT$x$}             & {\tt INT$x$\_MIN} &                 \\
                                    & {\sf FP$x$}              & {\tt -INFINITY}   &                 \\
{\sf GrB\_MAX\_SECOND\_SEMIRING\_$T$} & {\sf UINT$x$}            & 0                 & max-select second semiring     \\
                                    & {\sf INT$x$}             & {\tt INT$x$\_MIN} &                 \\
                                    & {\sf FP$x$}              & {\tt -INFINITY}   &                 \\
\end{tabular}

\hrule
\comment{
\begin{tablenotes}
    \item[1] For {\sf GrB\_ANY\_*\_SEMIRING\_T}, an implementation is free to return any of the results of the application of the "multiply" operator ({\sf FIRST} or {\sf SECOND}), and is not required to always return the same result in different invocations..
\end{tablenotes}
}
\end{threeparttable}
\end{table}

%==================

\begin{landscape}
\begin{table}[h]
\hspace{-1.5em}\begin{threeparttable}
\hrule
\vspace{1\baselineskip}
\caption{Predefined index unary operators for GraphBLAS in C.  The $T$ can 
be any suffix from Table~\ref{Tab:PredefinedDomains}, $\mathbb{I}$ refers to the unsigned 
{\sf GrB\_Index} type, $\mathbb{Z}$ refers to any integer type (signed or unsigned).  
The parameters, $u_i$ or $A_{ij}$, are the stored values from the containers; $i$ 
and $j$ are the row and column indices corresponding to the location of the store value;
and $s$ is an additional scalar value used in the operator. Some operators can be used with both
{\sf GrB\_Vector} and {\sf GrB\_Matrix} (marked with *), but those requiring access to the second index
only work with {\sf GrB\_Matrix} and will result in undefined behavior if used with
{\sf GrB\_Vector}. \scott{NEW CONTENT}}
\label{Tab:PredefIndexOperators}
\vspace{1\baselineskip}

\begin{tabular}{l|l|l|rcll}
Operator & GraphBLAS             &                                                      & \\
type     & identifier            & Domains                                              & Description \\ \hline
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_ROWINDEX\_$T$}*  & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow T$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(i + s)$, & replace with its row index (plus s) \\
                          &                            & $T \times \mathbb{I}^1 \times \mathbb{Z} \rightarrow T$ & $f(u_{i},[i],1,s)$ & $=$ & $(i + s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_COLINDEX\_$T$}   & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow T$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j + s)$, & replace with its column index (plus s) \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_DIAGINDEX\_$T$}  & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow T$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(i - j + s)$, & replace with its diagonal index (plus s) \\
\hline

{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_TRIL\_$T$}       & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j < i + s)$, & lower triangle below diagonal s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_TRIU\_$T$}       & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j > i + s)$, & upper triangle above diagonal s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_DIAG\_$T$}       & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j == i + s)$, & diagonal s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_OFFDIAG\_$T$}    & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j \neq i + s)$, & all but diagonal s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_COLLE\_$T$}      & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j \leq s)$, & columns less or equal to s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_COLGT\_$T$}      & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j > s)$, & columns greater than s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_ROWLE\_$T$}*     & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(i \leq s)$, & rows less or equal to s \\
                          &                            & $T \times \mathbb{I}^1 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(u_{i},[i],1,s)$ & $=$ & $(i \leq s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_ROWGT\_$T$}*     & $T \times \mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(i > s)$, & rows greater than s \\
                          &                            & $T \times \mathbb{I}^1 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(u_{i},[i],1,s)$ & $=$ & $(i > s)$ \\
\hline
                     
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_VALUEEQ\_$T$}*  & $T \times \mathbb{I}^2 \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} == s)$, & elements with value s \\
                          &                            & $T \times \mathbb{I}^1 \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} == s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_VALUENE\_$T$}*  & $T \times \mathbb{I}^2 \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} \neq s)$, & elements without value s \\
                          &                            & $T \times \mathbb{I}^1 \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} \neq s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_VALUELT\_$T$}*  & $T \times \mathbb{I}^2 \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} < s)$, & elements less than value s \\
                          &                            & $T \times \mathbb{I}^1 \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} < s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_VALUELE\_$T$}*  & $T \times \mathbb{I}^2 \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} \leq s)$, & elements less or equal to value s \\
                          &                            & $T \times \mathbb{I}^1 \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} \leq s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_VALUEGT\_$T$}*  & $T \times \mathbb{I}^2 \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} > s)$, & elements greater than value s \\
                          &                            & $T \times \mathbb{I}^1 \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} > s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_VALUEGE\_$T$}*  & $T \times \mathbb{I}^2 \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} \geq s)$, & elements greater or equal to value s \\
                          &                            & $T \times \mathbb{I}^1 \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} \geq s)$ \\
\end{tabular}
\hrule
\end{threeparttable}
\end{table}

\end{landscape}

%==================
\begin{landscape}

\begin{table*}
\hspace{-2.5em}\begin{threeparttable}
\hrule
\vspace{1\baselineskip}
\caption{\scott{Updated responding to some of Tim Davis' comments.} Predefined index unary operators for GraphBLAS in C.  The $T$ can 
be any suffix from Table~\ref{Tab:PredefinedDomains}, $\mathbb{I}$ refers to the unsigned 
{\sf GrB\_Index} type, $\mathbb{Z}$ refers to one of four signed or unsigned, 32- or 64-bit integer types.  
The parameters, $u_i$ or $A_{ij}$, are the stored values from the containers; $i$ 
and $j$ are the row and column indices corresponding to the location of the store value;
and $s$ is an additional scalar value used in the operator. Some operators can be used with both
{\sf GrB\_Vector} and {\sf GrB\_Matrix} (marked with *), but those requiring access to the second index
only work with {\sf GrB\_Matrix} and will result in undefined behavior if used with
{\sf GrB\_Vector}. \scott{NEW CONTENT}}
\label{Tab:PredefIndexOperators}
\vspace{1\baselineskip}

\begin{tabular}{l|l|l|rcll}
Operator & GraphBLAS             &                                                      & \\
type     & identifier            & Domains                                              & Description \\ \hline
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_ROWINDEX\_$Z$}*  & $\mathbb{I}^2 \times \mathbb{Z} \rightarrow \mathbb{Z}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(i + s)$, & replace with its row index (plus s) \\
                          &                            & $\mathbb{I}^1 \times \mathbb{Z} \rightarrow \mathbb{Z}$ & $f(u_{i},[i],1,s)$ & $=$ & $(i + s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_COLINDEX\_$Z$}   & $\mathbb{I}^2 \times \mathbb{Z} \rightarrow \mathbb{Z}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j + s)$, & replace with its column index (plus s) \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_DIAGINDEX\_$Z$}  & $\mathbb{I}^2 \times \mathbb{Z} \rightarrow \mathbb{Z}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(i - j + s)$, & replace with its diagonal index (plus s) \\
\hline

{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_TRIL\_$Z$}       & $\mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j < i + s)$, & lower triangle below diagonal s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_TRIU\_$Z$}       & $\mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j > i + s)$, & upper triangle above diagonal s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_DIAG\_$Z$}       & $\mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j == i + s)$, & diagonal s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_OFFDIAG\_$Z$}    & $\mathbb{I}^2 \times \mathbb{Z} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j \neq i + s)$, & all but diagonal s \\

{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_COLLE\_UINT64}   & $\mathbb{I}^2 \times \mathbb{I} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j \leq s)$, & columns less or equal to s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_COLGT\_UINT64}   & $\mathbb{I}^2 \times \mathbb{I} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(j > s)$, & columns greater than s \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_ROWLT\_UINT64}*  & $\mathbb{I}^2 \times \mathbb{I} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(i \leq s)$, & rows less or equal to s \\
                          &                            & $\mathbb{I}^1 \times \mathbb{I} \rightarrow {\sf bool}$ & $f(u_{i},[i],1,s)$ & $=$ & $(i \leq s)$  \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_ROWGE\_UINT64}*  & $\mathbb{I}^2 \times \mathbb{I} \rightarrow {\sf bool}$ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(i > s)$, & rows greater than s \\
                          &                            & $\mathbb{I}^1 \times \mathbb{I} \rightarrow {\sf bool}$ & $f(u_{i},[i],1,s)$ & $=$ & $(i > s)$ \\
\hline
                     
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_VALUEEQ\_$T$}*  & $T \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} == s)$, & elements with value s \\
                          &                            & $T \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} == s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_VALUENE\_$T$}*  & $T \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} \neq s)$, & elements without value s \\
                          &                            & $T \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} \neq s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_VALUELT\_$T$}*  & $T \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} < s)$, & elements less than value s \\
                          &                            & $T \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} < s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_VALUELE\_$T$}*  & $T \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} \leq s)$, & elements less or equal to value s \\
                          &                            & $T \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} \leq s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_VALUEGT\_$T$}*  & $T \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} > s)$, & elements greater than value s \\
                          &                            & $T \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} > s)$ \\
{\sf GrB\_IndexUnaryOp}   & {\sf GrB\_VALUEGE\_$T$}*  & $T \times T \rightarrow {\sf bool} $ & $f(A_{ij},[i,j],2,s)$ & $=$ & $(A_{ij} \geq s)$, & elements greater or equal to value s \\
                          &                            & $T \times T \rightarrow {\sf bool} $ & $f(u_{i},[i],1,s)$ & $=$ & $(u_{i} \geq s)$ \\
\end{tabular}
\hrule
\end{threeparttable}
\end{table*}

\end{landscape}

%-----------------------------------------------------------------------------

% ========================================================================

\section{Execution Model\tim{New Content}}
\label{Sec:ExecutionModel}

A program using the GraphBLAS C API is called
a GraphBLAS application.  The application constructs GraphBLAS objects,
manipulates them to implement a graph algorithm, and then extracts
values from the GraphBLAS objects to produce the result from the algorithm. 
Functions defined within the GraphBLAS C API that manipulate GraphBLAS
objects are called \emph{methods}.  If the method corresponds to one
of the operations defined in the GraphBLAS mathematical specification,
we refer to the method as an \emph{operation}.

%In the case of single-threaded execution, 
The GraphBLAS application specifies an ordered collection of 
GraphBLAS method calls defined by the order
they appear in the text of the program (the \emph{program order}).  
These define a directed acyclic graph (DAG) where nodes are GraphBLAS
method calls and edges are dependencies between method calls.  

Each method call in the DAG uniquely and unambiguously defines output
GraphBLAS objects as long as there are no execution errors that
put objects in an invalid state (see Section~\ref{Sec:ErrorModel}).
The ordered collection of method calls, a subgraph of the overall DAG for an application,
defines the state of a GraphBLAS object at any point in a program.  This ordered collection 
is the \emph{sequence} for that object.  

Since the GraphBLAS execution is defined in terms of a DAG and the 
GraphBLAS objects are opaque, the semantics of the GraphBLAS specification
affords an implementation of the specification considerable flexibility 
to optimize performance.  A GraphBLAS implementation can defer execution 
of nodes in the DAG, fuse nodes, or even replace whole subgraphs within the DAG 
to optimize performance.  We discuss this topic further in section~\ref{Sec:Modes} when we 
describe  \emph{blocking} and \emph{non-blocking} execution modes.

A correct GraphBLAS application must be \emph{race-free}.  This means that the DAG 
produced by an application and the results produced by execution of that DAG must be the same
regardless of how the threads are scheduled for execution.  It is the application programmer's 
responsibility to control memory orders and establish the required synchronized-with
relationships to assure race-free execution of a multi-threaded GraphBLAS 
application.  Writing race-free GraphBLAS applications is discussed further in section~\ref{Sec:MultiThread}.


\comment{Furthermore, methods that extract values from opaque GraphBLAS
objects into nonopaque user objects (see Table~\ref{Tab:ExtractMethods})
always force completion of all pending computations on the corresponding
GraphBLAS source object.

\begin{table}[htb]
    \hrule
    \begin{center}
        \caption{Methods that extract values from a GraphBLAS object, thereby
        forcing completion of the operations contributing to that particular object.}
        \label{Tab:ExtractMethods}

        \begin{tabular}{l|l}
            Method    					& Section 				\\ \hline

            {\sf GrB\_Vector\_nvals}        		& \ref{Sec:Vector_nvals}        	\\
            {\sf GrB\_Vector\_extractElement}     	& \ref{Sec:extract_single_element_vec}  \\
            {\sf GrB\_Vector\_extractTuples}    	& \ref{Sec:Vector_extractTuples}    	\\
            {\sf GrB\_Matrix\_nvals}        		& \ref{Sec:Matrix_nvals}        	\\
            {\sf GrB\_Matrix\_extractElement}     	& \ref{Sec:extract_single_element_mat}  \\
            {\sf GrB\_Matrix\_extractTuples}    	& \ref{Sec:Matrix_extractTuples}    	\\
            {\sf GrB\_reduce} (vector-scalar variant)   & \ref{Sec:Reduce_vector_scalar}        \\
            {\sf GrB\_reduce} (matrix-scalar variant)   & \ref{Sec:Reduce_matrix_scalar}        \\
        \end{tabular}
    \end{center}
    \hrule
\end{table}
}

\subsection{Execution modes}
\label{Sec:Modes}

The execution of the DAG defined by a GraphBLAS application depends on the
\emph{execution mode} of the GraphBLAS program.  There are two modes:
\emph{blocking} and \emph{nonblocking}.

\begin{itemize}

\item \emph{blocking}: In blocking mode, each method finishes the
GraphBLAS operation defined by the method before proceeding to the
next statement.
%%    in program order.    <-- since compilers may reorder statements, its execution-order not program-order that matters here
Output GraphBLAS objects defined
by a method are fully produced and stored in  memory (\ie, they are
\emph{materialized}).  Even mechanisms that break the opaqueness of the
GraphBLAS objects (\eg, performance monitors, debuggers, memory dumps)
will observe that the operation has finished.

\item \emph{nonblocking}: In nonblocking mode, each method may return
once the input arguments have been inspected and verified to define
a well formed GraphBLAS operation (that is, there are no API errors;
see Section~\ref{Sec:ErrorModel}.) The GraphBLAS method may not have
finished, but the output object is ready to be used by the next GraphBLAS
method call.  A call to {\sf GrB\_materialize(obj)} guarantees that
the sequence for the GraphBLAS object ({\sf obj}) has finished.

\end{itemize}

Processing of nonopaque objects is never deferred in
GraphBLAS. That is, methods that consume nonopaque objects (\eg, {\sf
GrB\_Matrix\_build()}, Section~\ref{Sec:Matrix_build}) and methods that
produce nonopaque objects (\eg, {\sf GrB\_Matrix\_extractTuples()},
Section~\ref{Sec:Matrix_extractTuples}) always finish consuming or
producing those nonopaque objects before returning regardless of the 
execution mode.

An application executing in nonblocking mode is not required to return
immediately after input arguments have been verified. A conforming
implementation of the GraphBLAS C API running in nonblocking mode may
choose to execute {\it as if} in blocking mode.  A sequence of operations
in nonblocking mode where every GraphBLAS operation with output object
{\sf obj} is followed by a {\sf GrB\_materialize(obj)} call is equivalent to the
same sequence in blocking mode with {\sf GrB\_materialize(obj)} calls removed.

Nonblocking mode allows for any execution strategy that satisfies the
mathematical definition of the sequence.  The methods can be placed
into a queue and deferred.  They can be chained together and fused
(\eg, replacing a chained pair of matrix products with a matrix triple
product).  Lazy evaluation, greedy evaluation, and asynchronous execution
are all valid as long as the final result agrees with the mathematical
definition provided by the sequence of GraphBLAS method calls appearing
in  program order.

Blocking mode forces an implementation to carry out precisely the
GraphBLAS operations defined by the methods and to complete each and
every method call individually.  It is valuable for debugging or in
cases where an external tool such as a debugger needs to evaluate the
state of memory during a sequence of operations.

In a sequence of operations free of execution errors, and with input
objects that are well-conditioned, the results from blocking and
nonblocking modes should be identical outside of effects due to roundoff
errors associated with floating point arithmetic.  Due to the great
flexibility afforded to an implementation when using nonblocking mode,
we expect execution of a sequence in nonblocking mode to potentially
complete execution in less time.

The mode is defined in the GraphBLAS C API when the context of the
library invocation is defined.  This occurs once before any GraphBLAS
methods are called with a call to the {\sf GrB\_init()} function.
This function takes a single argument of type {\sf GrB\_Mode} with the
following possible values:

\begin{itemize}

\item {\sf GrB\_BLOCKING} specifies the blocking mode context.

\item {\sf GrB\_NONBLOCKING} specifies the nonblocking mode context.

\end{itemize}

After all GraphBLAS method calls have been made, the context is terminated
with a call to {\sf GrB\_finalize()}.  In the current version of the
GraphBLAS C API, the context can be set only once in the execution of
a program. That is, after {\sf GrB\_finalize()} is called, a subsequent
call to {\sf GrB\_init()} is not allowed.

\subsection{Multi-threaded execution}
\label{Sec:MultiThread}

%% Note: This section was incorrectly titled "thread safety" in an earlier version of the specification.
%% Thread safety is a different concept then writing race-free code.

The GraphBLAS C API is designed to work in applications that run
as multiple threads of execution that share an address space.
This specification does not say how threads are created, managed and
synchronized.  We expect the host programming environment to provide
those services. 

An implementation of the GraphBLAS specification is required to be {thread safe}.  This means
that when different threads define sequences of GraphBLAS method calls and those sequences
are independent (they do not update objects shared between sequences), the results from each sequence must 
be the same when executed concurrently from multiple threads or when executed sequentially from a single thread.

The more challenging problem occurs when multiple threads cooperatively work on a single DAG and with
GraphBLAS objects defined in one thread and subsequently used in a different thread.  Consistent
with current practice in multi-threaded programming, we require that a valid GraphBLAS application
is \emph{race-free}.  This means that the results from the DAG defined by a GraphBLAS application
must be the same regardless of how the threads might be scheduled by the operating system.
%when executed with a single thread or with multiple threads.

In a multi-threaded execution, multiple threads can be active and
executing concurrently. Each thread consists of an ordered collection
of method calls defined by the program order on that thread.  Within a
thread there is a strict temporal relationship between any two method
calls. A method call $a$ is said to \emph{happen-before} a method call $b$
in the same thread if an only if method call $a$ precedes method call $b$
in the program order of that thread.

Since different threads execute concurrently, there is no intrinsic
temporal relationship between method calls in different threads.
The \emph{happen-before} relationship between method calls  in different
threads has to be explicitly established within the program by:
\begin{itemize}

\item Define a \emph{synchronized-with} relation between the threads.
\item Establish the memory order for variables shared between threads.

\end{itemize}

The GraphBLAS specification does not define how a synchronized-with relation
is defined.  Any programming model that supports multithreading includes 
capabilities to support synchronization.  Furthermore, for variables other than
the opaque GraphBLAS objects, a programming model that supports multithreading 
includes ways to control memory orders around synchronization events.  We
expect programmers to use those capabilities to create a race free program and do not
discuss them further in the GraphBLAS C API specification.

The one issue we need to address within the GraphBLAS specification concerning race-free programs
pertains to the memory orders for GraphBLAS objects.  These objects are opaque and therefore not defined 
in terms of values at an address in memory.  
Hence, we can not use the memory orders defined
by the memory model of the host programming environment.   Furthermore, a sequence
that defines a GraphBLAS object may be deferred due to execution in non-blocking mode.
This further complicates the state of a GraphBLAS object with respect to the 
order of memory operations around a synchronized-with relation.

To address these issues, we define the concept of \emph{completion} of 
a GraphBLAS object.  A GraphBLAS object is said to be 
\emph{complete} when it can be
safely used as an {\sf IN} or {\sf INOUT} argument in a 
GraphBLAS method call from a different thread.  A GraphBLAS
object is complete on return from the function {\sf GrB\_complete(obj)}.

The order of events is important.  
If object {\sf obj} is an input argument ({\sf IN} or {\sf INOUT})
to a GraphBLAS method call, then that method call is said to
\emph{use} {\sf obj}. Correspondingly, if object {\sf obj} is
an output argument ({\sf OUT} or {\sf INOUT})
to a GraphBLAS method call, then that method call is said
to \emph{define} {\sf obj.}    
On one thread, a sequence defines
a graphBLAS object.   Following the method calls that \emph{defines} the object,
the method {\sf GrB\_complete(obj)} is called followed by a
synchronization event (specified within the host programming environment).  
The second thread completes the synchronized-with relation with a synchronization
event and then \emph{uses} the GraphBLAS object in a sequence of 
GraphBLAS method calls.    The synchronized-with relation defines happens-before
relations between method-calls on the two threads and the {\sf GrB\_complete(obj)}
defines the order of memory operations on the GraphBLAS object, {\sf obj}, so the object
is well-defined before it is used on the second thread.

The following summarizes the key rules.  A multi-threaded execution is said to be race-free, and must
be supported by a GraphBLAS C API implementation, if the following
conditions hold:

\begin{enumerate}

	\item For every \emph{use} of a GraphBLAS object in a method call, there
	is a method call that \emph{defines} that object and happens-before
	the use.
	
	\item There are no method calls that define an object and are
	unordered with respect to one or more methods that use that
	object.

	\item Definitions of an object may not be unordered
	with respect to each other.	
	
	\item If \emph{definition} and \emph{use} occur on separate threads, 
	a synchronized-with relation establishes a happen-before relation
	between \emph{definition} and \emph{use} plus a call to
	{\sf GrB\_complete(obj)} occurs on the thread where the object was defined
      but before the synchronization event on that thread.    

	\item The most recent API error-free method call defining an object before
		its use does not return an execution error. (Methods calls
		that return an API error can be treated as null operations, as
		disscussed in Section~\ref{Sec:ErrorModel}.)

	\item No method call returns {\sf GrB\_PANIC}.

\end{enumerate}

We note that multi-threaded execution is compatible with both blocking and non-blocking
modes of execution. 


\section{Error Model\scott{NEW CONTENT}}
\label{Sec:ErrorModel}

All GraphBLAS methods return a value of type {\sf GrB\_Info} (an enum) to provide
information available to the system at the time the method returns. The
returned value will be one of the defined values shown in 
Table~\ref{Tab:ErrorValues}. The return values fall into three groups: 
informational (Table~\ref{Tab:ErrorValues}(a)), API errors 
(Table~\ref{Tab:ErrorValues}(b)) and execution errors 
(Table~\ref{Tab:ErrorValues}(c)).  Informational return values are 
non-negative and includes {\sf GrB\_SUCCESS} (a value of 0).  {\sf GrB\_NO\_VALUE} 
is also a non-negative informational return value.  API and execution errors
take on negative values.\scott{NEW CONTENT}

\begin{table}[bh]
\hrule
\begin{center}
\caption{Values returned by GraphBLAS methods and operations.\scott{NEW CONTENT}}
\label{Tab:ErrorValues}

\vspace{1\baselineskip}
(a) Informational return values
\vspace{1\baselineskip}

\begin{tabular}{l|r|p{3in}}
Symbol    & Value & Description \\ \hline
{\sf GrB\_SUCCESS} ~~~~~~~~~~~~~~~~~~~~~~~ &  0 & The method/operation completed successfully (blocking mode), or encountered no API errors (non-blocking mode). \\
{\sf GrB\_NO\_VALUE}             &  1 & A location in a matrix or vector is being accessed that has no stored value at the specified location. \scott{It depends on whether or not the non-opaque scalar is
well-defined on return from {\sf extract}}\\
\end{tabular}

\vspace{1\baselineskip}
(b) Execution errors
\vspace{1\baselineskip}

\begin{tabular}{l|r|p{3in}}
Symbol    & Value & Description \\ \hline
{\sf GrB\_UNINITIALIZED\_OBJECT} & -1 & A GraphBLAS object is passed to a method before {\sf new} was called on it.\\
{\sf GrB\_NULL\_POINTER}         & -2 & A NULL is passed for a pointer parameter. \\
{\sf GrB\_INVALID\_VALUE}        & -3 & Miscellaneous incorrect values. \\
{\sf GrB\_INVALID\_INDEX}        & -4 & Indices passed are larger than dimensions of the matrix or vector being accessed. \\
{\sf GrB\_DOMAIN\_MISMATCH}      & -5 & A mismatch between domains of collections and operations when user-defined domains are in use.\\
{\sf GrB\_DIMENSION\_MISMATCH}~~ & -6 & Operations on matrices and vectors with incompatible dimensions. \\
{\sf GrB\_OUTPUT\_NOT\_EMPTY}    & -7 & An attempt was made to build a matrix or vector using an output object that already contains valid tuples (elements).\\
\end{tabular}

\vspace{1\baselineskip}
(c) Execution errors
\vspace{1\baselineskip}

\begin{tabular}{l|r|p{3in}}
Symbol    & Value & Description \\ \hline
{\sf GrB\_OUT\_OF\_MEMORY}        &  -8 & Not enough memory for operations. \\
{\sf GrB\_INSUFFICIENT\_SPACE}    &  -9 & The array provided is not large enough to hold output. \\
{\sf GrB\_INVALID\_OBJECT}        & -10 & One of the opaque GraphBLAS objects (input or output) is in an invalid state caused by a previous execution error. \\
{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS} & -11 & Reference to a vector or matrix element that is outside the defined dimensions of the object. \\
{\sf GrB\_PANIC}                  & -12 & Unknown internal error. \\
\end{tabular}

\end{center}
\hrule
\end{table}

An API error means that a GraphBLAS method was called with parameters
that violate the rules for that method.  These errors are restricted
to those that can be determined by inspecting the types and domains of
GraphBLAS objects, GraphBLAS operators, or the values of scalar parameters
fixed at the time a method is called.  API errors are deterministic and
consistent across platforms and implementations.  API errors are never
deferred, even in nonblocking mode. That is, if a method is called in
a manner that would generate an API error, it always returns with the
appropriate API error value.  If a GraphBLAS method returns with an
API error, it is guaranteed that none of the arguments to the method
(or any other program data) have been modified.  The informational return
value, {\sf GrB\_NO\_VALUE}, is also deterministic and never deferred in 
nonblocking mode.

Execution errors indicate that something went wrong during the execution
of a legal GraphBLAS method invocation.  Their occurrence may depend on
specifics of the executing environment and data values being manipulated.
This does not mean that execution errors are the fault of the GraphBLAS
implementation.  For example, a memory leak could arise from an error in
an application's source code (a ``program error''), but it may manifest
itself in different points of a program's execution (or not at all)
depending on the platform, problem size, or what else is running at
that time.  Index-out-of-bounds errors, for example, always indicate a
program error.

If a GraphBLAS method returns with any execution error from
Table~\ref{Tab:ErrorValues}(b) other than {\sf GrB\_PANIC}, it is
guaranteed that no argument used as input-only has been modified.
Output arguments may be left in an invalid state, and their use downstream
in the program flow may cause additional errors.  If a GraphBLAS method
returns with a {\sf GrB\_PANIC} execution error, no guarantees can be
made about the state of any program data.

In nonblocking mode, execution errors can be deferred.  A return value
of {\sf GrB\_SUCCESS} only guarantees that there are no API errors
in the method invocation.  If an execution error value is returned
by a method with output object {\sf obj} in nonblocking mode, it
indicates that an error was found during execution of any of the pending
operations on {\sf obj}, up to and including the {\sf GrB\_wait()} method
(Section~\ref{Sec:GrB_wait}) call that completes those pending operations.
When possible, that return value will provide information concerning
the cause of the error.

As discussed in Section~\ref{Sec:GrB_wait}, a {\sf GrB\_wait(obj)} on a
specific GraphBLAS object {\sf obj} completes all pending operations on
that object.  No additional errors on the methods that precede the call
to {\sf GrB\_wait} and have {\sf obj} as an {\sf OUT} or {\sf INOUT}
argument can be reported.  From a GraphBLAS perspective, those methods
are {\em complete}.  Details on the guaranteed state of objects after
a call to {\sf GrB\_wait} can be found in Section~\ref{Sec:GrB_wait}.

\comment{
\begin{figure}[tb]
    \hrule
    \vspace{1\baselineskip}
    \begin{center}
        \begin{minipage}{3in}
            \begin{verbatim}
            const char *GrB_error();
            \end{verbatim}
        \end{minipage}
    \end{center}
    \caption{Signature of {\sf GrB\_error()} function.}
    \label{Fig:GrB_error}
    \hrule
\end{figure}
}

After a call to any GraphBLAS method, the program can retrieve
additional error information (beyond the error code returned by
the method) though a call to the function {\sf GrB\_error()},
as described in Section~\ref{Sec:GrB_error}.  The function returns a
pointer to a NULL-terminated string, and the contents of that string
are implementation dependent. In particular, a null string (not a {\sf
NULL} pointer) is always a valid error string.  {\sf GrB\_error()} is
a thread-safe function, in the sense that multiple threads can call it
simultaneously and each will get its own error string back, referring
to object passed as an input argument.
