\section*{4.2 Object Methods}

\subsection*{4.2.3 Vector Methods}

%-----------------------------------------------------------------------------

\subsubsection*{4.2.3.8 {\sf Vector\_setElement}: Set a single element in a vector}

Set one element of a vector to a given value.

\paragraph{\syntax}

\begin{verbatim}
        // scalar value
        GrB_Info GrB_Vector_setElement(GrB_Vector   w,
                                       <type>       val,
                                       GrB_Index    index);

        // GraphBLAS scalar
        GrB_Info GrB_Vector_setElement(GrB_Vector   w,
                                       GrB_Scalar   s,
                                       GrB_Index    index);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]   ({\sf INOUT}) An existing GraphBLAS vector for which an 
    element is to be assigned.

    \item[{\sf val} or {\sf s}]   ({\sf IN}) Scalar assign.  Its domain (type) must
    be compatible with the domain of {\sf w}.

    \item[{\sf index}] ({\sf IN}) The location of the element to be assigned.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on index/dimensions and domains for the input arguments passed successfully. 
    Either way, the output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf w}, or 
    GraphBLAS scalar, {\sf s}, has not been initialized by a call to a respective constructor.
    
    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf index} specifies a location 
    that is outside the dimensions of {\sf w}.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of the vector and the scalar
    are incompatible.
\end{itemize}

\paragraph{Description}

First, the scalar and output vector are tested for domain compatibility as follows:
$\mathbf{D}({\sf val})$ or $\mathbf{D}({\sf s})$ must be compatible with $\mathbf{D}({\sf w})$. Two domains 
are compatible with each other if values from one domain can be cast to values 
in the other domain as per the rules of the C language. In particular, domains 
from Table~\ref{Tab:PredefinedTypes} are all compatible with each other. A domain 
from a user-defined type is only compatible with itself. If any compatibility 
rule above is violated, execution of {\sf GrB\_Vector\_setElement} ends and 
the domain mismatch error listed above is returned.

Then, the {\sf index} parameter is checked for a valid value where the following
condition must hold:
\[
	0\ \leq\ {\sf index}\ <\ \mathbf{size}({\sf w})
\]
If this condition is violated, execution of {\sf GrB\_Vector\_setElement} 
ends and the invalid index error listed above is returned.

We are now ready to carry out the assignment; that is: 
\begin{equation*}
    {\sf w}({\sf index}) =
    \begin{cases}
     \mathbf{L}({\sf s}),  & \text{GraphBLAS scalar.} \\
     {\sf val}, & \text{otherwise.}
    \end{cases}
\end{equation*}
In the case of a transparent scalar or if $\mathbf{L}({\sf s})$ is not empty, then a value will be stored at the specified
location in {\sf w}, overwriting any value that may have been stored there before.
In the case of a GraphBLAS scalar, if $\mathbf{L}({\sf s})$ is empty, then any
value stored at the specified location in {\sf w} will be removed.

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.

%-----------------------------------------------------------------------------

\subsubsection*{4.2.3.10 {\sf Vector\_extractElement}: Extract a single element from a vector.}
%\label{Sec:Vector_extractElement}

Extract one element of a vector into a scalar. 

\paragraph{\syntax}

\begin{verbatim}
        // scalar value
        GrB_Info GrB_Vector_extractElement(<type>           *val,
                                           const GrB_Vector  u,
                                           GrB_Index         index); 

        // GraphBLAS scalar
        GrB_Info GrB_Vector_extractElement(GrB_Scalar        s,
                                           const GrB_Vector  u,
                                           GrB_Index         index); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf val} or {\sf s}]   ({\sf INOUT}) An existing scalar of whose domain is 
    compatible with the domain of vector {\sf u}. On successful return, this scalar 
    holds the result of the extract. Any previous value stored in {\sf val} or {\sf s} is 
    overwritten.

    \item[{\sf u}]     ({\sf IN}) The GraphBLAS vector from which an element
    is extracted.
    
    \item[{\sf index}] ({\sf IN}) The location in {\sf u} to extract.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully. This indicates that the compatibility tests on 
    dimensions and domains for the input arguments passed successfully, and
    the output scalar, {\sf val} or {\sf s}, has been computed and is ready to be used in 
    the next method of the sequence.

    \item[{\sf GrB\_NO\_VALUE}]  When using the transparent scalar, {\sf val}, this is returned when there is no stored value at specified location.
    
    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf u}, or scalar,
    {\sf s}, has not been initialized by a call to a corresponding constructor.
    
    \item[{\sf GrB\_NULL\_POINTER}]    {\sf val} pointer is {\sf NULL}.

    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf index} specifies a location 
    that is outside the dimensions of {\sf w}.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of the vector and scalar
    are incompatible.
\end{itemize}

\paragraph{Description}

First, the scalar and input vector are tested for domain compatibility as follows:
$\mathbf{D}({\sf val})$ or $\mathbf{D}({\sf s})$ must be compatible with $\mathbf{D}({\sf u})$. Two domains 
are compatible with each other if values from one domain can be cast to values 
in the other domain as per the rules of the C language. In particular, domains 
from Table~\ref{Tab:PredefinedTypes} are all compatible with each other. A domain 
from a user-defined type is only compatible with itself. If any compatibility 
rule above is violated, execution of {\sf GrB\_Vector\_extractElement} ends and 
the domain mismatch error listed above is returned.

Then, the {\sf index} parameter is checked for a valid value where the following
condition must hold:
\[
	0\ \leq\ {\sf index}\ <\ \mathbf{size}({\sf u})
\]
If this condition is violated, execution of {\sf GrB\_Vector\_extractElement} 
ends and the invalid index error listed above is returned.

We are now ready to carry out the extract into the output scalar; that is: 
\begin{align*}
  \begin{array}{r}
    \mathbf{L}({\sf s}) \\
    {\sf val} 
  \end{array}
  \Bigg\}  =  {\sf u}({\sf index}) 
\end{align*}
If ${\sf index} \in \mathbf{ind}({\sf u})$, then the corresponding value from 
{\sf u} is copied into {\sf s} or {\sf val} with casting as necessary. If ${\sf index} \notin \mathbf{ind}({\sf u})$, then one of the follow occurs depending on output scalar type: 
\begin{itemize}
\item The GraphBLAS scalar, {\sf s}, is cleared and {\sf GrB\_SUCCESS} is returned.
\item The non-opaque scalar, {\sf val}, is unchanged, and {\sf GrB\_NO\_VALUE} is returned. \scott{is {\sf val} unchanged or undefined in this case?}
\end{itemize}

When using the non-opaque scalar variant ({\sf val}) in both {\sf GrB\_BLOCKING} mode 
{\sf GrB\_NONBLOCKING} mode, the new contents of {\sf val} are as defined above
if the method exits with return value {\sf GrB\_SUCCESS} or {\sf GrB\_NO\_VALUE}. 

When using the GraphBLAS scalar variant ({\sf s}) with a {\sf GrB\_SUCCESS} return value,
the method exits and the new contents of {\sf s} is as defined above
and fully computed in {\sf GrB\_BLOCKING} mode. In {\sf GrB\_NONBLOCKING} mode, the 
new contents of {\sf s} is as defined above but may not be fully computed; however, 
it can be used in the next GraphBLAS method call in a sequence.

%-----------------------------------------------------------------------------
%-----------------------------------------------------------------------------

\subsection*{4.2.4 Matrix Methods}

%-----------------------------------------------------------------------------

\subsubsection*{4.2.4.10 {\sf Matrix\_setElement}: Set a single element in a matrix}

Set one element of a matrix to a given value.

\paragraph{\syntax}

\begin{verbatim}
        // scalar value
        GrB_Info GrB_Matrix_setElement(GrB_Matrix   C,
                                       <type>       val,
                                       GrB_Index    row_index,
                                       GrB_Index    col_index); 

        // GraphBLAS scalar
        GrB_Info GrB_Matrix_setElement(GrB_Matrix   C,
                                       GrB_Scalar   s,
                                       GrB_Index    row_index,
                                       GrB_Index    col_index); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]   ({\sf INOUT}) An existing GraphBLAS matrix for which an 
    element is to be assigned.

    \item[{\sf val} or {\sf s}]   ({\sf IN})  Scalar to assign.  Its domain (type) must
    be compatible with the domain of {\sf C}.
    
    \item[{\sf row\_index}] ({\sf IN}) Row index of element to be assigned
    \item[{\sf col\_index}] ({\sf IN}) Column index of element to be assigned
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on index/dimensions and domains for the input arguments passed successfully. 
    Either way, the output matrix {\sf C} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, or 
    GraphBLAS scalar, {\sf s}, has not been initialized by a call to a respective constructor.

    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf row\_index} or {\sf col\_index} is 
    outside the allowable range (i.e., not less than $\mathbf{nrows}({\sf C})$ or
    $\mathbf{ncols}({\sf C})$, respectively).

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]  The domains of the matrix and the scalar
    are incompatible.
\end{itemize}

\paragraph{Description}

First, the scalar and output matrix are tested for domain compatibility as follows:  
$\mathbf{D}({\sf val})$ or $\mathbf{D}({\sf s})$ must be compatible with $\mathbf{D}({\sf C})$. Two domains 
are compatible with each other if values from one domain can be cast to values 
in the other domain as per the rules of the C language.  In particular, domains 
from Table~\ref{Tab:PredefinedTypes} are all compatible with each other. A domain 
from a user-defined type is only compatible with itself.  If any compatibility 
rule above is violated, execution of {\sf GrB\_Matrix\_extractElement} ends and
the domain mismatch error listed above is returned.

Then, both index parameters are checked for valid values where following
conditions must hold:
\[
\begin{aligned}
    0\ \leq\ {\sf row\_index} & \ <\ \mathbf{nrows}({\sf C}), \\
    0\ \leq\ {\sf col\_index} & \ <\ \mathbf{ncols}({\sf C})
\end{aligned}
\]
If either of these conditions is violated, execution of 
{\sf GrB\_Matrix\_extractElement} ends and the invalid 
index error listed above is returned. 

We are now ready to carry out the assignment; that is: 
\begin{equation*}
    {\sf C}({\sf row\_index},{\sf col\_index}) =
    \begin{cases}
     \mathbf{L}({\sf s}),  & \text{GraphBLAS scalar.} \\
     {\sf val}, & \text{otherwise.}
    \end{cases}
\end{equation*}
In the case of a transparent scalar or if $\mathbf{L}({\sf s})$ is not empty, then a value will be stored at the specified
location in {\sf C}, overwriting any value that may have been stored there before.
In the case of a GraphBLAS scalar and if $\mathbf{L}({\sf s})$ is empty, then any
value stored at the specified location in {\sf C} will be removed.

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of {\sf C} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf C} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.


%-----------------------------------------------------------------------------

\subsubsection*{4.2.4.12 {\sf Matrix\_extractElement}: Extract a single element from a matrix}
%\label{Sec:Matrix_extractElement}

Extract one element of a matrix into a scalar. 

\paragraph{\syntax}

\begin{verbatim}
        // scalar value
        GrB_Info GrB_Matrix_extractElement(<type>           *val,
                                           const GrB_Matrix  A,
                                           GrB_Index         row_index,
                                           GrB_Index         col_index);

        // GraphBLAS scalar
        GrB_Info GrB_Matrix_extractElement(GrB_Scalar        s,
                                           const GrB_Matrix  A,
                                           GrB_Index         row_index,
                                           GrB_Index         col_index); 

\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf val} or {\sf s}]   ({\sf INOUT}) An existing scalar whose domain is 
    compatible with the domain of matrix {\sf A}. On successful return, this scalar 
    holds the result of the extract.  Any previous value stored in {\sf val} or {\sf s} is 
    overwritten.

    \item[{\sf A}]     ({\sf IN}) The GraphBLAS matrix from which an element is
    extracted.
    
    \item[{\sf row\_index}] ({\sf IN}) The row index of location in {\sf A} 
    to extract.

    \item[{\sf col\_index}] ({\sf IN}) The column index of location in {\sf A} 
    to extract.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully. This indicates that the compatibility tests on 
    dimensions and domains for the input arguments passed successfully, and
    the output scalar, {\sf val} or {\sf s}, has been computed and is ready to be used in 
    the next method of the sequence.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, or scalar,
    {\sf s}, has not been initialized by a call to a corresponding constructor.

    \item[{\sf GrB\_NULL\_POINTER}]    {\sf val} pointer is {\sf NULL}.

    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf row\_index} or {\sf col\_index} is 
    outside the allowable range (i.e. less than zero or greater than or equal to 
    $\mathbf{nrows}({\sf A})$ or $\mathbf{ncols}({\sf A})$, respectively).

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of the matrix and scalar
    are incompatible.
\end{itemize}

\paragraph{Description}

First, the scalar and input matrix are tested for domain compatibility as follows:  
$\mathbf{D}({\sf val})$ or $\mathbf{D}({\sf s})$ must be compatible with $\mathbf{D}({\sf A})$. Two domains 
are compatible with each other if values from one domain can be cast to values 
in the other domain as per the rules of the C language.  In particular, domains 
from Table~\ref{Tab:PredefinedTypes} are all compatible with each other. A domain 
from a user-defined type is only compatible with itself.  If any compatibility 
rule above is violated, execution of {\sf GrB\_Matrix\_extractElement} ends and
the domain mismatch error listed above is returned.

Then, both index parameters are checked for valid values where following
conditions must hold:
\[
\begin{aligned}
    0\ \leq\ {\sf row\_index} & \ <\ \mathbf{nrows}({\sf A}), \\
    0\ \leq\ {\sf col\_index} & \ <\ \mathbf{ncols}({\sf A})
\end{aligned}
\]
If either condition is violated, execution of 
{\sf GrB\_Matrix\_extractElement} ends and the invalid 
index error listed above is returned. 

We are now ready to carry out the extract into the output scalar; that is,
\begin{align*}
  \begin{array}{r}
    \mathbf{L}({\sf s}) \\
    {\sf val} 
  \end{array}
  \Bigg\}  =  {\sf A}({\sf row\_index},{\sf col\_index})
\end{align*}
If $({\sf row\_index},{\sf col\_index}) \ \in \ \mathbf{ind}({\sf A})$, then the corresponding value from 
{\sf A} is copied into {\sf s} or {\sf val} with casting as necessary. If $({\sf row\_index},{\sf col\_index}) \ \notin \ \mathbf{ind}({\sf A})$, then one of the follow occurs depending on output scalar type: 
\begin{itemize}
\item The GraphBLAS scalar, {\sf s}, is cleared and {\sf GrB\_SUCCESS} is returned.
\item The non-opaque scalar, {\sf val}, is unchanged, and {\sf GrB\_NO\_VALUE} is returned. \scott{is {\sf val} unchanged or undefined in this case?}
\end{itemize}

When using the non-opaque scalar variant ({\sf val}) in both {\sf GrB\_BLOCKING} mode 
{\sf GrB\_NONBLOCKING} mode, the new contents of {\sf val} are as defined above
if the method exits with return value {\sf GrB\_SUCCESS} or {\sf GrB\_NO\_VALUE}. 

When using the GraphBLAS scalar variant ({\sf s}) with a {\sf GrB\_SUCCESS} return value,
the method exits and the new contents of {\sf s} is as defined above
and fully computed in {\sf GrB\_BLOCKING} mode. In {\sf GrB\_NONBLOCKING} mode, the 
new contents of {\sf s} is as defined above but may not be fully computed; however, 
it can be used in the next GraphBLAS method call in a sequence.
