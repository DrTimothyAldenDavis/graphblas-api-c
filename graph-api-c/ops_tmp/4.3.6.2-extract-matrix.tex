\subsubsection{{\sf extract}: Standard matrix variant}

Extract a sub-matrix from a larger matrix as specified by a set of row indices
and a set of column indices.  The result is a matrix whose size is equal to size of the sets of indices.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_extract(GrB_Matrix            C,
                             const GrB_Matrix      Mask,
                             const GrB_BinaryOp    accum,
                             const GrB_Matrix      A,
                             const GrB_Index      *row_indices,
                             const GrB_Index       nrows,
                             const GrB_Index      *col_indices,
                             const GrB_Index       ncols,
                             const GrB_Descriptor  desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS matrix. On input,
    the matrix provides values that may be accumulated with the result of the
    extract operation.  On output, the matrix holds the results of the
    operation.

    \item[{\sf Mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix {\sf C}. The 
    mask dimensions must match those of the matrix {\sf C} and the domain of the 
    {\sf Mask} matrix must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    matrix is desired (\ie, with correct dimensions filled with {\sf true}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf C} entries.
    If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf A}]     ({\sf IN})  The GraphBLAS matrix from which the subset
    is extracted.

    \item[{\sf row\_indices}] ({\sf IN}) Pointer to the ordered set (array) of 
    indices corresponding to the rows of {\sf A} from which elements are 
    extracted.  If elements in all rows of {\sf A} are to be extracted in order, 
    {\sf GrB\_ALL} should be specified.  Regardless of execution mode and return
    value, this array may be manipulated by the caller after this operation 
    returns without affecting any deferred computations for this operation.
    
    \item[{\sf nrows}] ({\sf IN}) The number of values in the {\sf row\_indices}
    array.  Must be equal to $\bold{nrows}({\sf C})$.
    
    \item[{\sf col\_indices}] ({\sf IN}) Pointer to the ordered set (array) of 
    indices corresponding to the columns of {\sf A} from which elements are 
    extracted.  If elements in all columns of {\sf A} are to be extracted in order, 
    then {\sf GrB\_ALL} should be specified.  Regardless of execution mode and return
    value, this array may be manipulated by the caller after this operation 
    returns without affecting any deferred computations for this operation.
    
    \item[{\sf ncols}] ({\sf IN}) The number of values in the {\sf col\_indices}
    array.  Must be equal to $\bold{ncols}({\sf C})$.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural
        complement of {\sf Mask}. \\

        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A}
        for the operation. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output matrix, {\sf C}, is ready to be used in the next method of
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for the operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf Matrix\_dup} for matrix
    parameters).

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf row\_indices} 
    is greater than or equal to $\bold{nrows}({\sf A})$, or a value in 
    {\sf col\_indices} is greater than or equal to $\bold{ncols}({\sf A})$.  In 
    non-blocking mode, this can be reported as an execution error.

    \item[{\sf GrB\_DIMENSION\_MISMATCH}] {\sf Mask} and {\sf C}
    dimensions are incompatible, ${\sf nrows} \neq \bold{nrows}({\sf C})$, or 
    ${\sf ncols} \neq \bold{ncols}({\sf C})$.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various matrices are
    incompatible with each other or the corresponding domains of the 
    accumulation operator, or the mask's domain is not compatible with {\sf bool}.

    \item[{\sf GrB\_NULL\_POINTER}] Either argument {\sf row\_indices} is a {\sf NULL} pointer,
	argument {\sf col\_indices} is a {\sf NULL} pointer, or both.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_extract} computes the result of extracting a subset of
locations from specified rows and columns of a GraphBLAS matrix in a specific 
order: ${\sf C} = {\sf A}({\sf row\_indices},{\sf col\_indices})$; or, if an optional
binary accumulation operator ($\odot$) is provided, ${\sf C} = {\sf C} \odot
{\sf A}({\sf row\_indices},{\sf col\_indices})$.  
More explicitly (not accounting for an optional transpose of {\sf A}):
\[
\begin{aligned}
    {\sf C}(i,j) = &\ \ \ \ \ \ \ \ \ \ \ \ \ {\sf A}({\sf row\_indices}[i],{\sf col\_indices}[j]) 
    \ \forall \ i,j \ : \ 0 \leq i < {\sf nrows},\ 0 \leq j < {\sf ncols} \mbox{,~or~}
    \\
    {\sf C}(i,j) = &\ {\sf C}(i,j) \odot {\sf A}({\sf row\_indices}[i],{\sf col\_indices}[j])
    \ \forall \ i,j \ : \ 0 \leq i < {\sf nrows},\ 0 \leq j < {\sf ncols}
\end{aligned}
\]  
Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.85in]
\item[\bf Setup] The internal matrices and mask used in the computation are formed and their 
domains and dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output matrix, possibly under control of a mask.
\end{enumerate}

Up to three argument matrices are used in the {\sf GrB\_extract} operation:
\begin{enumerate}
	\item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),
    \bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$

	\item ${\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}({\sf Mask}),
    \bold{ncols}({\sf Mask}),\bold{L}({\sf Mask}) = \{(i,j,M_{ij}) \} \rangle$ (optional)

	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}),
    \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
\end{enumerate}

The argument matrices and the accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}
	\item The domain of {\sf Mask} (if not {\sf GrB\_NULL}) must be from one of
    the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $\bold{D}({\sf A})$.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator and 
    $\bold{D}({\sf A})$ must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_extract} ends and 
the domain mismatch error listed above is returned.

From the arguments, the internal matrices, mask, and index arrays used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

	\item Two-dimensional mask, $\matrix{\widetilde{M}}$, is computed from
    argument {\sf Mask} as follows:
	\begin{enumerate}
		\item	If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{M}} = 
        \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), 
        \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < 
        \bold{ncols}({\sf C}) \} \rangle$.

		\item	Otherwise, $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), 
        \bold{ncols}({\sf Mask}), \{(i,j) : (i,j) \in \bold{ind}({\sf Mask}) \wedge 
        ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is set, then 
        $\matrix{\widetilde{M}} \leftarrow \neg \matrix{\widetilde{M}}$.
	\end{enumerate}

	\item Matrix $\matrix{\widetilde{A}} \leftarrow
    {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$.

    \item The internal row index array, $\array{\widetilde{I}}$, is computed from 
    argument {\sf row\_indices} as follows:
	\begin{enumerate}
		\item	If ${\sf row\_indices} = {\sf GrB\_ALL}$, then 
        $\array{\widetilde{I}}[i] = i, \forall i : 0 \leq i < {\sf nrows}$.

		\item	Otherwise, $\array{\widetilde{I}}[i] = {\sf row\_indices}[i], 
        \forall i : 0 \leq i < {\sf nrows}$.
    \end{enumerate}
    
    \item The internal column index array, $\array{\widetilde{J}}$, is computed from 
    argument {\sf col\_indices} as follows:
	\begin{enumerate}
		\item	If ${\sf col\_indices} = {\sf GrB\_ALL}$, then 
        $\array{\widetilde{J}}[j] = j, \forall j : 0 \leq j < {\sf ncols}$.

		\item	Otherwise, $\array{\widetilde{J}}[j] = {\sf col\_indices}[j], 
        \forall j : 0 \leq j < {\sf ncols}$.
    \end{enumerate}
\end{enumerate}

The internal matrices and mask are checked for dimension compatibility. The following
conditions must hold:
\begin{enumerate}
    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{M}})$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{M}})$.

    \item $\bold{nrows}(\matrix{\widetilde{C}}) = {\sf nrows}$.

    \item $\bold{ncols}(\matrix{\widetilde{C}}) = {\sf ncols}$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_extract} ends and
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the extract and any additional 
associated operations.  We describe this in terms of two intermediate matrices:
\begin{itemize}
    \item $\matrix{\widetilde{T}}$: The matrix holding the extraction from 
    $\matrix{\widetilde{A}}$.

    \item $\matrix{\widetilde{Z}}$: The matrix holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

The intermediate matrix, $\matrix{\widetilde{T}}$, is created as follows:
\[
\begin{aligned}
\matrix{\widetilde{T}} = \langle & \bold{D}({\sf A}),
                           \bold{nrows}(\matrix{\widetilde{C}}), 
                           \bold{ncols}(\matrix{\widetilde{C}}), \\
                         & %\bold{L}(\matrix{\widetilde{T}}) =
\{(i,j,\matrix{\widetilde{A}}(\array{\widetilde{I}}[i],\array{\widetilde{J}}[j])) 
\ \forall \ (i,j), \ 0 \leq i < {\sf nrows}, \ 0 \leq j < {\sf ncols} :
(\array{\widetilde{I}}[i], \array{\widetilde{J}}[j]) \in 
\bold{ind}(\matrix{\widetilde{A}}) \} \rangle.
\end{aligned}
\]
At this point, if any value in the $\array{\widetilde{I}}$ array is not in
the range $[0,\ \bold{nrows}(\matrix{\widetilde{A}}) )$ or any value in the 
$\array{\widetilde{J}}$ array is not in the range 
$[0,\ \bold{ncols}(\matrix{\widetilde{A}}))$, the execution of {\sf GrB\_extract} 
ends and the index out-of-bounds error listed above is generated.  In 
{\sf GrB\_NONBLOCKING} mode, the error can be deferred until a 
sequence-terminating {\sf GrB\_wait()} is called.  Regardless, the result 
matrix {\sf C} is invalid from this point forward in the sequence.

The intermediate matrix $\matrix{\widetilde{Z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{Z}} = \matrix{\widetilde{T}}$.

    \item If ${\sf accum}$ is a binary operator, then $\matrix{\widetilde{Z}}$ is defined as
        \[ \langle \bDout({\sf accum}), \bold{nrows}(\matrix{\widetilde{C}}), \bold{ncols}(\matrix{\widetilde{C}}),
        %\bold{L}(\matrix{\widetilde{Z}}) =
        \{(i,j,Z_{ij})  \forall (i,j) \in \bold{ind}(\matrix{\widetilde{C}}) \cup 
        \bold{ind}(\matrix{\widetilde{T}}) \} \rangle.\]

    The values of the elements of $\matrix{\widetilde{Z}}$ are computed based on the
    relationships between the sets of indices in $\matrix{\widetilde{C}}$ and 
    $\matrix{\widetilde{T}}$.
\[
    Z_{ij} = \matrix{\widetilde{C}}(i,j) \odot \matrix{\widetilde{T}}(i,j), \ \mbox{if}\  
    (i,j) \in  (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}})),
\]
\[
    Z_{ij} = \matrix{\widetilde{C}}(i,j), \ \mbox{if}\  
    (i,j) \in (\bold{ind}(\matrix{\widetilde{C}}) - (\bold{ind}(\matrix{\widetilde{T}})
    \cap \bold{ind}(\matrix{\widetilde{C}}))),
\]
\[
    Z_{ij} = \matrix{\widetilde{T}}(i,j), \ \mbox{if}\  (i,j) \in  
    (\bold{ind}(\matrix{\widetilde{T}}) - (\bold{ind}(\matrix{\widetilde{T}})
    \cap \bold{ind}(\matrix{\widetilde{C}}))),
\]
where $\odot  = \bigodot({\sf accum})$, and the difference operator refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\matrix{\widetilde{Z}}$ 
matrix are written into the final result matrix, {\sf C}. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set, then any values in {\sf C} on
input to this operation are deleted and the contents of the new output matrix,
{\sf C}, is defined as,
\[
\bold{L}({\sf C}) = \{(i,j,Z_{ij}) : (i,j) \in (\bold{ind}(\matrix{\widetilde{Z}}) 
\cap \bold{ind}(\matrix{\widetilde{M}})) \}. 
\]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of 
$\matrix{\widetilde{Z}}$ indicated by the mask are copied into the result 
matrix, {\sf C}, and elements of {\sf C} that fall outside the set 
indicated by the mask are unchanged:
\[
\bold{L}({\sf C}) = \{(i,j,C_{ij}) : (i,j) \in (\bold{ind}({\sf C}) 
\cap \bold{ind}(\neg \matrix{\widetilde{M}})) \} \cup \{(i,j,Z_{ij}) : (i,j) \in 
(\bold{ind}(\matrix{\widetilde{Z}}) \cap \bold{ind}(\matrix{\widetilde{M}})) \}.
\]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of matrix {\sf C} is as defined above
and fully computed.
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of matrix {\sf C} is as defined above
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.
