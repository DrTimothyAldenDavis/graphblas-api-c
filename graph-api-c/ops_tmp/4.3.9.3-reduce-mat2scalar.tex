\subsubsection{{\sf reduce}: Matrix-scalar variant}
\label{Sec:Reduce_matrix_scalar}

Reduce all stored values into a single scalar.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_reduce(<type>               *val,
                            const GrB_BinaryOp    accum,
                            const GrB_Monoid      op,
                            const GrB_Matrix      A,
                            const GrB_Descriptor  desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf val}]    ({\sf INOUT}) Scalar to store final reduced value into. On input,
    the scalar provides a value that may be accumulated with the result of the
    reduction operation.  On output, this scalar holds the results of the
    operation.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf val} value. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) The monoid used in the element-wise reduction
    operation, $M = \langle D,\oplus,0 \rangle$. The binary operator,
    $\oplus$, must be commutative and associative; otherwise,
    the outcome of the operation is undefined.
    
    \item[{\sf A}]     ({\sf IN}) The GraphBLAS matrix on which
    reduction will be performed.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
    \end{tabular}

    \emph{Note:} This argument is defined for consistency with the other GraphBLAS operations.
    There are currently no non-default field/value pairs that can be set for this operation.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking or non-blocking mode, 
    the operation completed successfully, and the
    output scalar {\sf val} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for the operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf Matrix\_dup} for matrix
    parameters).
    
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of input and output arguments are
    incompatible with the corresponding domains of the accumulation operator, 
    or reduce operator.

    \item[{\sf GrB\_NULL\_POINTER}]  {\sf val} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_reduce} computes the result of performing
a reduction across each of the elements of an input matrix:
${\sf val} = \bigoplus {\sf A}(:,:)$; or, if an optional binary accumulation 
operator is provided, ${\sf val} = {\sf val} \odot (\bigoplus {\sf A}(:,:))$, 
where $\bigoplus = \bigodot({\sf op})$ and $\odot = \bigodot({\sf accum})$.  

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.85in]
\item[\bf Setup] The internal matrix used in the computation is formed 
and its domain is tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output scalar.
\end{enumerate}

One matrix argument is used in this {\sf GrB\_reduce} operation:
\begin{enumerate}
	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{size}({\sf A}),
    \bold{L}({\sf A}) = \{(i,j,A_{i,j}) \} \rangle$

\end{enumerate}

The output scalar, argument matrix, reduction operator and accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf val})$ must be
    compatible with $\bold{D}({\sf op})$ of the reduction binary operator.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf val})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator and 
    $\bold{D}({\sf op})$ of the reduction binary operator must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.

	\item $\bold{D}({\sf A})$ must be compatible with $\bold{D}({\sf op})$ of the binary reduction operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_reduce} ends and 
the domain mismatch error listed above is returned.

From the argument matrix, the internal matrix used in 
the computation is formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Matrix $\matrix{\widetilde{A}} \leftarrow {\sf A}$.
\end{enumerate}

We are now ready to carry out the reduce and any additional 
associated operations.  
First, an intermediate scalar result $t$ is computed using the recurrence:
\[
	t \leftarrow \bold{0}({\sf op}),
\]
\[
	t \leftarrow t \oplus \matrix{A}(i,j), \forall (i,j) \in \bold{ind}(\matrix{A}). 
\]
Where $\oplus = \bigodot({\sf op})$, and $\bold{0}({\sf op})$ is the identity of the monoid.

The final reduction value {\sf val} is computed as follows:
\begin{itemize}
	\item If ${\sf accum} = {\sf GrB\_NULL}$, then ${\sf val} \leftarrow t$.

	\item If ${\sf accum}$ is a binary operator, then ${\sf val} \leftarrow {\sf val} \odot t$,
    where $\odot  = \bigodot({\sf accum})$. 
\end{itemize}

In both {\sf GrB\_BLOCKING} and {\sf GrB\_NONBLOCKING} modes, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of {\sf val} is as defined above
and fully computed.
