\subsection{{\sf mxv}: Matrix-vector multiply}

Multiplies a matrix by a vector on a semiring. The result is a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_mxv(GrB_Vector             w,
                         const GrB_Vector       mask,
                         const GrB_BinaryOp     accum,
                         const GrB_Semiring     op,
                         const GrB_Matrix       A,
                         const GrB_Vector       u,
                         const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    matrix-vector product.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}] ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector {\sf w}. The 
    mask dimensions must match those of the vector {\sf w} and the domain of the
    {\sf mask} vector must be of type {\sf bool} or any of the predefined 
    ``built-in'' types in Table~\ref{Tab:PredefinedTypes}.  If the default
    vector is desired (\ie, with correct dimensions filled with {\sf true}), 
    {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf w} entries.
    %: ${\sf accum} = \langle \bDout({\sf accum}),\bDin1({\sf accum}),
    %\bDin2({\sf accum}), \odot \rangle$. 
    If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]   ({\sf IN}) Semiring used in the vector-matrix
    multiply.
    %: ${\sf op}=\langle \bDout({\sf op}),\bDin1({\sf op}),\bDin2({\sf op}),\oplus,\otimes,0 \rangle$.

    \item[{\sf A}]    ({\sf IN}) The GraphBLAS matrix holding the values
    for the left-hand matrix in the multiplication.

    \item[{\sf u}]    ({\sf IN}) The GraphBLAS vector holding the values for
    the right-hand vector in the multiplication.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it.\\

        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural
        complement of {\sf mask}. \\

        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A}
        for the operation. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector, {\sf w}, is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for the operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf dup} for matrix or
    vector parameters).

    \item[{\sf GrB\_DIMENSION\_MISMATCH}] Mask, vector, and/or matrix 
    dimensions are incompatible.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various vectors/matrices are
    incompatible with the corresponding domains of the semiring or
    accumulation operator, or the mask's domain is not compatible with {\sf bool}.
\end{itemize}

\paragraph{Description}

{\sf GrB\_mxv} computes the matrix-vector product ${\sf w} = {\sf A}
\otimes . \oplus {\sf u}$, or, if an optional binary accumulation
operator ($\odot$) is provided, ${\sf w} = {\sf w} \odot \left({\sf A}
\otimes . \oplus {\sf u}\right)$ (where matrix {\sf A}
 can be optionally transposed).  Logically, this operation
occurs in three steps:
\begin{enumerate}[leftmargin=0.85in]
\item[\bf Setup] The internal vectors, matrices and mask used in the computation are formed and their domains/dimensions are tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output vector, possibly under control of a mask.
\end{enumerate}

Up to four argument vectors or matrices are used in the {\sf GrB\_mxv} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),\bold{L}({\sf w}) = \{(i,w_i) \} \rangle$
	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),\bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)
	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}), \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),\bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

The argument matrices, vectors, the semiring, and the accumulation operator (if provided) 
are tested for domain compatibility as follows:
\begin{enumerate}
	\item The domain of {\sf mask} (if not {\sf GrB\_NULL}) must be from one of the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item $\bold{D}({\sf A})$ must be compatible with $\bDin1({\sf op})$ of the semiring.

	\item $\bold{D}({\sf u})$ must be compatible with $\bDin2({\sf op})$ of the semiring.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be compatible with $\bDout({\sf op})$ of the semiring.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the 
	accumulation operator and $\bDout({\sf op})$ of the semiring must be compatible with $\bDin2({\sf accum})$ of the accumulation operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_mxv} ends and 
the domain mismatch error listed above is returned.

From the argument vectors and matrices, the internal matrices and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item	If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \ \forall \ i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item	Otherwise, $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf mask}), \{i : i \in \bold{ind}({\sf mask}) \wedge
        ({\sf bool}){\sf mask}(i) = \true \} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is set, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Matrix $\matrix{\widetilde{A}} \leftarrow {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$.

	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
\end{enumerate}

The internal matrices and masks are checked for shape compatibility. The following 
conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$.

	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{nrows}(\matrix{\widetilde{A}})$.

	\item $\bold{size}(\vector{\widetilde{u}}) = \bold{ncols}(\matrix{\widetilde{A}})$.
\end{enumerate}
If any compatibility rule above is violated, execution of {\sf GrB\_mxv} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can 
optionally exit with {\sf GrB\_SUCCESS} return code and defer any computation 
and/or execution error codes.

We are now ready to carry out the matrix-vector multiplication and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
    \item $\vector{\widetilde{t}}$: The vector holding the product of matrix 
    $\matrix{\widetilde{A}}$ and vector $\vector{\widetilde{u}}$.
    \item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulation operator.
\end{itemize}

The intermediate vector $\vector{\widetilde{t}} = \langle
\bDout({\sf op}), \bold{nrows}(\matrix{\widetilde{A}}),
%\bold{L}(\vector{\widetilde{t}}) =
\{(i,t_i) : \bold{ind}(\matrix{\widetilde{A}}(i,:)) \cap 
\bold{ind}(\vector{\widetilde{u}}) \neq \emptyset \} \rangle$
is created.  The value of each of its elements is computed by 
\[t_i = \bigoplus_{k \in \bold{ind}(\matrix{\widetilde{A}}(i,:)) \cap
\bold{ind}(\vector{\widetilde{u}})} (\matrix{\widetilde{A}}(i,k)
\otimes \vector{\widetilde{u}}(k)),\] where $\oplus$ and $\otimes$
are the additive and multiplicative operators of semiring {\sf op},
respectively.

The intermediate vector $\vector{\widetilde{z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\vector{\widetilde{z}} = \vector{\widetilde{t}}$.

    \item If ${\sf accum}$ is a binary operator, then $\vector{\widetilde{z}}$ is defined as
        \[ \langle \bDout({\sf accum}), \bold{size}(\vector{\widetilde{w}}),
        %\bold{L}(\vector{\widetilde{z}}) =
        \{(i,z_{i}) \ \forall \ i \in \bold{ind}(\vector{\widetilde{w}}) \cup 
        \bold{ind}(\vector{\widetilde{t}}) \} \rangle.\]

    The values of the elements of $\vector{\widetilde{z}}$ are computed based on the 
    relationships between the sets of indices in $\vector{\widetilde{w}}$ and 
    $\vector{\widetilde{t}}$.
\[
    z_{i} = \vector{\widetilde{w}}(i) \odot \vector{\widetilde{t}}(i), \ \mbox{if}\  
    i \in  (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}})),
\]
\[
    z_{i} = \vector{\widetilde{w}}(i), \ \mbox{if}\  
    i \in (\bold{ind}(\vector{\widetilde{w}}) - (\bold{ind}(\vector{\widetilde{t}})
    \cap \bold{ind}(\vector{\widetilde{w}}))),
\]
\[
    z_{i} = \vector{\widetilde{t}}(i), \ \mbox{if}\  i \in  
    (\bold{ind}(\vector{\widetilde{t}}) - (\bold{ind}(\vector{\widetilde{t}})
    \cap \bold{ind}(\vector{\widetilde{w}}))),
\]
where $\odot  = \bigodot({\sf accum})$, and the difference operator refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\vector{\widetilde{z}}$ 
vector are written into the final result vector, {\sf w}. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set, then any values in {\sf w} 
on input to this operation are deleted and the contents of the new output vector,
{\sf w}, is defined as,
\[ 
\bold{L}({\sf w}) = \{(i,z_{i}) : i \in (\bold{ind}(\vector{\widetilde{z}}) 
\cap \bold{ind}(\vector{\widetilde{m}})) \}. 
\]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of 
$\vector{\widetilde{z}}$ indicated by the mask are copied into the result 
vector, {\sf w}, and elements of {\sf w} that fall outside the set indicated by 
the mask are unchanged:
\[ 
\bold{L}({\sf w}) = \{(i,w_{i}) : i \in (\bold{ind}({\sf w}) 
\cap \bold{ind}(\neg \vector{\widetilde{m}})) \} \cup \{(i,z_{i}) : i \in 
(\bold{ind}(\vector{\widetilde{z}}) \cap \bold{ind}(\vector{\widetilde{m}})) \}. 
\]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.
