\subsection{{\sf assign}: Modifying Sub-Graphs}
\label{Sec:assign}

Assign the contents of a subset of a matrix or vector.

%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Standard vector variant}

In the standard vector variant of {\sf assign}, a GraphBLAS index array specifies
the locations in the output vector that should be assigned with values
from the input vector.  The size of the input vector is the same size as the
index array provided.

If an accumulation function is specified, then that function is used
to combine current elements of the destination with those elements
from the source.  If no accumulation function is specified, then the
destination is overwritten with the source.


\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Vector             *w,
                            const GrB_Vector        mask,
                            const GrB_BinaryOp      accum,
                            const GrB_Vector        u,
                            const GrB_Index        *indices,
                            const GrB_Index         nindices,
                            const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    assign operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}]  ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector
    ${\sf w}$.  If no mask is desired (\ie, all elements
    of result are copied into the output vector), {\sf GrB\_NULL}
    should be specified. The mask dimensions must match those of the
    vector {\sf w} and the domain of {\sf mask} must be
    of type {\sf bool} or any of the predefined ``built-in'' types in
    Table~\ref{Tab:PredefinedTypes}.


    \item[{\sf accum}]    ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf w} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf u}]       ({\sf IN}) The GraphBLAS source vector from which elements are assigned to the destination vector.
    
    \item[{\sf indices}]  ({\sf IN}) A pointer to an ordered set of indices 
    corresponding to the locations in {\sf w} that are to be assigned.  If all 
    elements of {\sf w} are to be assigned, in order from $0$ to 
    ${\sf nindices} - 1$, then {\sf GrB\_ALL} (i.e. NULL) can be specified.
    
    \item[{\sf nindices}] ({\sf IN}) The number of values in {\sf indices} array.
    Must be equal to $\bold{size}({\sf u})$.  \scott{What should be passed for this parameter when {\sf indices} is GrB\_ALL or NULL}

    \item[{\sf desc}]     ({\sf IN}) An optional operation descriptor.  If a 
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be used.  Valid 
    fields are as follows: \\
    
    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it. \\
        
        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural 
        complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, operation
	completed successfully. In non-blocking mode, this indicates
	that the consistency tests on dimensions and domains for the
	input arguments passed successfully. Either way, output vector
	{\sf w} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_OUT\_OF\_MEMORY}]        Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]        At least one of the GraphBLAS 
    object arguments has not been initialized by a call to {\sf new}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf w} pointer is {\sf NULL}.

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf indices} references a 
    element in {\sf w} that is outside its dimension.
    
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] Mask, vector, or array dimensions are
    incompatible, or ${\sf nindices} \neq \bold{size}({\sf u})$. 
    
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various
	vectors are incompatible with the corresponding domains of the
	accumulating operation or mask.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_assign} computes the result of assigning elements from 
a source GraphBLAS vector to a destination GraphBLAS vector in a specific order: 
${\sf w}({\sf indices}) = {\sf u}$; or, if an optional binary accumulation 
operator ($\odot$) is provided, ${\sf w}({\sf indices}) = {\sf w}({\sf indices}) \odot {\sf u}$.  
More explicitly:
\[
	{\sf w}({\sf indices}(i)) = {\sf u}(i) \mbox{~~or~~} 
    {\sf w}({\sf indices}(i)) = {\sf w}({\sf indices}(i)) \odot {\sf u}(i))
    \forall i \in \left[0..{\sf nindices}\right)
\]  
Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for consistency.
\item[Compute] The indicated computations are carried out.
\item[Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to three argument vectors are used in the {\sf GrB\_assign} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),\bold{L}({\sf w}) = \{(i,w_i) \} \rangle$
	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),\bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)
	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),\bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

The argument vectors and the accumulator 
operator (if provided) are tested for domain consistency as follows:
\begin{enumerate}
	\item The domain of {\sf mask} (if not {\sf GrB\_NULL}) must be from one of the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be 
    compatible with $\bold{D}({\sf u})$.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $D_x$ and $D_z$ of the accumulator operator and 
    $\bold{D}({\sf u})$ must be compatible with $D_y$ of the accumulator operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any consistency rule above is violated, execution of {\sf GrB\_assign} ends
and the domain mismatch error listed above is returned.

From the argument vectors, the internal vectors and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item	If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \forall i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item	Otherwise, $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf mask}), \{i : ({\sf bool}){\sf mask}(i) = 
        \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is \true, then $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
    
        \item The internal index array, $\array{\widetilde{I}}$, is computed from argument {\sf indices} as follows:
	\begin{enumerate}
		\item	If ${\sf indices} = {\sf GrB\_ALL}$, then $\array{\widetilde{I}}[i] = i                , \forall i : 0 \leq i < {\sf nindices} \} \rangle$.

		\item	Otherwise,                                $\array{\widetilde{I}}[i] = {\sf indices}[i]), \forall i : 0 \leq i < {\sf nindices} \} \rangle$.
        \end{enumerate}
\end{enumerate}

The internal vectors and masks are checked for shape consistency. The following 
conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$
    \item ${\sf nindices} \leq \bold{size}(\vector{\widetilde{u}})$.
\end{enumerate}
If any consistency rule above is violated, execution of {\sf GrB\_assign} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can optionally exit
with {\sf GrB\_SUCCESS} return code and defer any computation and/or execution error
codes.

We are now ready to carry out the assign and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
	\item $\vector{\widetilde{t}}$: The vector holding the elements from
		$\vector{\widetilde{u}}$ in their destination locations in $\vector{\widetilde{w}}$.
	\item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulator.
\end{itemize}

The intermediate vector, $\vector{\widetilde{t}}$, is created as follows:
\[ \vector{\widetilde{t}} = \langle
\bold{D}({\sf u}), \bold{size}(\vector{\widetilde{w}}),
\bold{L}(\vector{\widetilde{t}}) =
\{(\array{\widetilde{I}}[i],\vector{\widetilde{u}}(i)) \forall i, 0 \leq i < {\sf nindices} : 
i \in \bold{ind}(\vector{\widetilde{u}}) \} \rangle. \]

If any value of $\array{\widetilde{I}}[i]$ is outside the valid range of indices
for vector $\vector{\widetilde{w}}$, computation ends and the method returns the
index-out-of-bounds error listed above. In {\sf GrB\_NONBLOCKING} mode, the error
can be deferred until a sequence-terminating {\sf GrB\_wait()} is called.
The result vector {\sf w} is invalid \scott{undefined?} from this point forward in
the sequence.

The intermediate vector $\vector{\widetilde{z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\vector{\widetilde{z}} = \vector{\widetilde{t}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then vector $\vector{\widetilde{z}}$ is defined as 
        \[ \langle D_z, \bold{size}(\vector{\widetilde{w}}), \bold{L}(\vector{\widetilde{z}})
		= \{(i,z_{i})  \forall (i) \in \bold{ind}(\vector{\widetilde{w}}) \cup 
        \bold{ind}(\vector{\widetilde{t}}) \} \rangle.\]
    The values of the elements of $\vector{\widetilde{z}}$ are computed based on the relationships between the sets of indices in $\vector{\widetilde{w}}$ and $\vector{\widetilde{t}}$.
\[
z_{i} = \vector{\widetilde{w}}(i) \odot \vector{\widetilde{t}}(i), \forall i \in  (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}})),
\]
\[
z_{i} = \vector{\widetilde{w}}(i), \forall  i \in  (\bold{ind}(\vector{\widetilde{w}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}}))),
\]
\[
z_{i} = \vector{\widetilde{t}}(i), \forall  i \in  (\bold{ind}(\vector{\widetilde{t}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\vector{\widetilde{z}}$ 
vector are written into the final result vector, ${\sf w}$. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set then any values in ${\sf w}$ 
on input to {\sf GrB\_assign()} are deleted and the new output vector ${\sf w}$ is,
\[ \bold{L}({\sf w}) = \{(i,z_{i}) : i \in (\bold{ind}(\vector{\widetilde{z}}) 
\cap \bold{ind}(\vector{\widetilde{m}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of $\vector{\widetilde{z}}$ indicated by 
the mask are copied into the result vector, ${\sf w}$, and elements of 
${\sf w}$ that fall outside the set indicated by the mask are unchanged:
\[ \bold{L}({\sf w}) = \{(i,w_{i}) : i \in (\bold{ind}(\vector{\sf w}) 
\cap \bold{ind}(\neg \vector{\widetilde{m}})) \} \cup \{(i,z_{i}) : i \in 
(\bold{ind}(\vector{\widetilde{z}}) \cap \bold{ind}(\vector{\widetilde{m}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.

\comment{
\paragraph{OLD Description}

Vectors $\vector{u}$ and $\vector{mask}$ are computed from input parameters {\sf u} and {\sf mask}, respectively, as specified by descriptor {\sf desc}. If
the size of $\vector{u}$ does not match argument {\sf n}, return {\sf GrB\_DIMENSION\_MISTMATCH}.

For each $i \in \{0, 1, \ldots, {\sf nindices}-1 \} : \vector{mask}[i] = \true$, do the following:
\begin{itemize}
	\item[] If $(i, u_i) \notin \bold{L}(\vector{u})$ skip to the next $i$.
	\item[] If $({\sf indices}[i], {\sf w}[{\sf indices}[i]]) \notin \bold{L}({\sf w})$ then
	      $\bold{L}({\sf w}) \leftarrow \bold{L}({\sf w}) \cup ({\sf indices}[i],u_i)$.
	\item[] Else, update ${\sf w}[{\sf indices}[i]] \leftarrow {\sf accum}({\sf w}[{\sf indices}[i]],u_i)$.
\end{itemize}
}

%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Standard matrix variant}

In the standard matrix variant of {\sf assign}, two GraphBLAS index arrays 
specify the rows and columns in the output matrix that should be assigned
with all the values from the input matrix.  The number of rows in the source
matrix must be the same size as the row index array, and the number of columns
must be the same size as the column index array.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Matrix             *C,
                            const GrB_Matrix        Mask,
                            const GrB_BinaryOp      accum,
                            const GrB_Matrix        A,
                            const GrB_Index        *row_indices,
                            const GrB_Index         nrows,
                            const GrB_Index        *col_indices,
                            const GrB_Index         ncols,
                            const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS Matrix.  On input,
    the matrix provides values that may be accumulated with the result of the
    assign operation.  On output, this matrix holds the results of the
    operation.

    \item[{\sf Mask}]  ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix
    ${\sf C}$.  If no mask is desired (\ie, all elements
    of result are copied into the output matrix), {\sf GrB\_NULL}
    should be specified. The mask dimensions must match those of the
    matrix {\sf C} and the domain of {\sf Mask} must be
    of type {\sf bool} or any of the predefined ``built-in'' types in
    Table~\ref{Tab:PredefinedTypes}.


    \item[{\sf accum}]    ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf C} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf A}]       ({\sf IN}) The GraphBLAS source matrix from which elements are assigned to the destination matrix.
    
    \item[{\sf row\_indices}]  ({\sf IN}) The ordered set of indices corresponding to the 
    rows of {\sf C} that are assigned.  If rows of
    {\sf C} are to be assigned in order, from $0$ to ${\sf nrows} - 1$, {\sf GrB\_ALL} can be specified.
    
    \item[{\sf nrows}] ({\sf IN}) The number of values in {\sf row\_indices} array.
	    Must be less than or equal to $\bold{nrows}({\sf A})$ if {\sf A} is not tranposed,
	    or less than or equal to $\bold{ncols}({\sf A})$ if {\sf A} is transposed.

    \item[{\sf col\_indices}]  ({\sf IN}) The ordered set of indices corresponding to the 
    columns of {\sf C} that are assigned.  If columns of
    {\sf C} are to be assigned in order, from $0$ to ${\sf ncols} - 1$, {\sf GrB\_ALL} can be specified.
    
    \item[{\sf ncols}] ({\sf IN}) The number of values in {\sf col\_indices} array.
	    Must be less than or equal to $\bold{ncols}({\sf A})$ if {\sf A} is not tranposed,
	    or less than or equal to $\bold{nrows}({\sf A})$ if {\sf A} is transposed.

    \item[{\sf desc}]     ({\sf IN}) An optional operation descriptor.  If a 
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be used.  Valid 
    fields are as follows: \\
    
    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C}
        is cleared (all elements removed) before the result is stored in it. \\
        
        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural 
        complement of {\sf Mask}. \\

	{\sf A}	   & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A} for operation.
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, operation
	completed successfully. In non-blocking mode, this indicates
	that the consistency tests on dimensions and domains for the
	input arguments passed successfully. Either way, output matrix
	{\sf C} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_OUT\_OF\_MEMORY}]        Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]        At least one of the GraphBLAS object arguments is invalid, either because it has
    not been initialized or because of a previous execution error.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf C} pointer is {\sf NULL}.

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf row\_indices} (or {\sf col\_indices}) references a 
	    row (or column) in {\sf C} that is outside its dimensions.
    
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] Mask, matrix, or array dimensions are
	    incompatible (including compatibility of {\sf nrows} and {\sf ncols} with {\sf A}). 
    
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various
	matrices are incompatible with the corresponding domains of the
	accumulating operation or mask.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_assign} computes the result of assigning elements from 
a source GraphBLAS matrix to a destination GraphBLAS matrix in a specific order: 
${\sf C}({\sf row\_indices},{\sf col\_indices}) = {\sf A}$; or, if an optional binary accumulation 
operator ($\odot$) is provided, ${\sf C}({\sf row\_indices},{\sf col\_indices}) = {\sf C}({\sf row\_indices},{\sf col\_indices}) \odot {\sf A}$,  
where matrix {\sf A} can be optionally transposed.
More explicitly, one of the following takes place:
\[
  	{\sf C}({\sf row\_indices}(i),{\sf col\_indices}(j)) = {\sf A}(i,j) 
 	\forall i \in \left[0..{\sf nrows}\right), \forall j \in \left[ 0..{\sf ncols}\right)
\]  
\[
  	{\sf C}({\sf row\_indices}(i),{\sf col\_indices}(j)) = {\sf A}(j,i) 
 	\forall i \in \left[0..{\sf nrows}\right), \forall j \in \left[ 0..{\sf ncols}\right)
\]  
\[
  	{\sf C}({\sf row\_indices}(i),{\sf col\_indices}(j)) = {\sf C}({\sf row\_indices}(i),{\sf col\_indices}(j)) \odot {\sf A}(i,j) 
 	\forall i \in \left[0..{\sf nrows}\right), \forall j \in \left[ 0..{\sf ncols}\right)
\]  
\[
  	{\sf C}({\sf row\_indices}(i),{\sf col\_indices}(j)) = {\sf C}({\sf row\_indices}(i),{\sf col\_indices}(j)) \odot {\sf A}(j,i) 
 	\forall i \in \left[0..{\sf nrows}\right), \forall j \in \left[ 0..{\sf ncols}\right)
\]  
Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[Setup] The internal matrices and mask used in the computation are formed 
and their domains and dimensions are tested for consistency.
\item[Compute] The indicated computations are carried out.
\item[Output] The result is written into the output matrix, possibly under 
control of a mask.
\end{enumerate}

Up to three argument matrices are used in the {\sf GrB\_assign} operation:
\begin{enumerate}
	\item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),\bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$
	\item ${\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}({\sf Mask}),\bold{ncols}({\sf Mask}),\bold{L}({\sf Mask}) = \{(i,j,M_{ij}) \} \rangle$ (optional)
	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}), \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
\end{enumerate}

The argument matrices and the accumulator 
operator (if provided) are tested for domain consistency as follows:
\begin{enumerate}
	\item The domain of {\sf Mask} (if not {\sf GrB\_NULL}) must be from one of the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be 
    compatible with $\bold{D}({\sf A})$.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $D_x$ and $D_z$ of the accumulator operator and 
    $\bold{D}({\sf A})$ must be compatible with $D_y$ of the accumulator operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any consistency rule above is violated, execution of {\sf GrB\_assign} ends
and the domain mismatch error listed above is returned.

From the argument vectors, the internal vectors and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
    
	\item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

	\item Two-dimensional mask $\matrix{\widetilde{M}}$ is computed from argument {\sf Mask} as follows:
	\begin{enumerate}

		\item	If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < \bold{ncols}({\sf C}) \} \rangle$.

		\item	Otherwise, $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), \bold{ncols}({\sf Mask}), \{(i,j) : ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is set, then $\matrix{\widetilde{M}} \leftarrow \neg \matrix{\widetilde{M}}$.

	\end{enumerate}

	\item Matrix $\matrix{\widetilde{A}} \leftarrow {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$.

	\item The internal index arrays, $\array{\widetilde{I}}$ and $\array{\widetilde{J}}$, are computed from arguments {\sf row\_indices} and {\sf col\_indices} respectively as follows:
	\begin{enumerate}
	\item	If ${\sf row\_indices} = {\sf GrB\_ALL}$, then $\array{\widetilde{I}}[i] = i               , \forall i : 0 \leq i < {\sf nrows} \} \rangle$.
	\item	Otherwise,                               $\array{\widetilde{I}}[i] = {\sf row\_indices}[i]), \forall i : 0 \leq i < {\sf nrows} \} \rangle$.
	\item	If ${\sf col\_indices} = {\sf GrB\_ALL}$, then $\array{\widetilde{J}}[j] = j               , \forall j : 0 \leq j < {\sf ncols} \} \rangle$.
	\item	Otherwise,                               $\array{\widetilde{J}}[j] = {\sf col\_indices}[j]), \forall j : 0 \leq j < {\sf ncols} \} \rangle$.
        \end{enumerate}
\end{enumerate}

The internal matrices and mask are checked for shape consistency. The following 
conditions must hold:
\begin{enumerate}
    \item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{M}})$.
    \item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{M}})$.
    \item ${\sf nrows} \leq \bold{nrows}(\matrix{\widetilde{A}})$.
    \item ${\sf ncols} \leq \bold{ncols}(\matrix{\widetilde{A}})$.
\end{enumerate}
If any consistency rule above is violated, execution of {\sf GrB\_assign} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can optionally exit
with {\sf GrB\_SUCCESS} return code and defer any computation and/or execution error
codes.

We are now ready to carry out the assign and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
	\item $\matrix{\widetilde{T}}$: The matrix holding the elements from
		$\matrix{\widetilde{A}}$ in their destination locations in $\matrix{\widetilde{C}}$.
	\item $\matrix{\widetilde{Z}}$: The matrix holding the result after 
    application of the (optional) accumulator.
\end{itemize}

The intermediate matrix, $\matrix{\widetilde{T}}$, is created as follows:
\[ \matrix{\widetilde{T}} = \langle
\bold{D}({\sf A}), \bold{nrows}(\matrix{\widetilde{C}}), \bold{ncols}(\matrix{\widetilde{C}}),
\bold{L}(\matrix{\widetilde{T}}) \rangle, \]
\[
	\bold{L}(\matrix{\widetilde{T}}) =
\{(\array{\widetilde{I}}[i],\array{\widetilde{J}}[j],\matrix{\widetilde{A}}(i,j)) \forall i, 0 \leq i < {\sf nrows}, \forall j, 0 \leq j < {\sf ncols} : 
(i,j) \in \bold{ind}(\matrix{\widetilde{A}}) \}. \]

If any value of $\array{\widetilde{I}}[i]$ is outside the valid range of row indices
for matrix $\matrix{\widetilde{A}}$, or if any value of $\array{\widetilde{J}}[j]$ is outside the valid range of column indices for matrix $\matrix{\widetilde{A}}$,
computation ends and the method returns the
index-out-of-bounds error listed above. In {\sf GrB\_NONBLOCKING} mode, the error
can be deffered up to the sequence-terminating {\sf GrB\_wait()} call.
The result matrix {\sf C} is invalid from this point forward in
the sequence.

The intermediate matrix $\matrix{\widetilde{Z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{Z}} = \matrix{\widetilde{T}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then matrix $\matrix{\widetilde{Z}}$ is defined as 
        \[ \langle D_z, \bold{nrows}(\matrix{\widetilde{C}}),\bold{ncols}(\matrix{\widetilde{C}}), \bold{L}(\matrix{\widetilde{Z}})
		= \{(i,j,Z_{ij})  \forall (i,j) \in \bold{ind}(\matrix{\widetilde{C}}) \cup 
        \bold{ind}(\matrix{\widetilde{T}}) \} \rangle.\]
    The values of the elements of $\matrix{\widetilde{Z}}$ are computed based on the relationships between the sets of indices in $\matrix{\widetilde{C}}$ and $\matrix{\widetilde{T}}$.
\[
	Z_{ij} = \matrix{\widetilde{C}}(i,j) \odot \matrix{\widetilde{T}}(i,j), \forall (i,j) \in  (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}})),
\]
\[
	Z_{ij} = \matrix{\widetilde{C}}(i,j), \forall  (i,j) \in  (\bold{ind}(\matrix{\widetilde{C}}) - (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}}))),
\]
\[
	Z_{ij} = \matrix{\widetilde{T}}(i,j), \forall  (i,j) \in  (\bold{ind}(\matrix{\widetilde{T}}) - (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\matrix{\widetilde{Z}}$ 
matrix are written into the final result matrix, ${\sf C}$. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set then any values in ${\sf C}$ 
on input to {\sf GrB\_assign()} are deleted and the new output matrix ${\sf C}$ is,
		\[ \bold{L}({\sf C}) = \{(i,j,Z_{ij}) : (i,j) \in (\bold{ind}(\matrix{\widetilde{Z}}) 
\cap \bold{ind}(\matrix{\widetilde{M}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of $\matrix{\widetilde{Z}}$ indicated by 
the mask are copied into the result matrix, ${\sf C}$, and elements of 
${\sf C}$ that fall outside the set indicated by the mask are unchanged:
		\[ \bold{L}({\sf C}) = \{(i,j,C_{ij}) : (i,j) \in (\bold{ind}(\matrix{\sf C}) 
		\cap \bold{ind}(\neg \matrix{\widetilde{M}})) \} \cup \{(i,Z_{ij}) : (i,j) \in 
(\bold{ind}(\matrix{\widetilde{Z}}) \cap \bold{ind}(\matrix{\widetilde{M}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of matrix {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of matrix {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.

%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Column variant}

Assign to one column of a matrix from a vector.  

\scott{Note we cannot use transpose on dst to assign a row, so in this case we have two assign functions.  Should I add the second function back into extract variant and ditch the transpose descriptor?}

\scott{The mask in this variant is odd.  It is a vector while the destination is
a matrix.}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Matrix             *C,
                            const GrB_Vector        mask,
                            const GrB_BinaryOp      accum,
                            const GrB_Vector        u,
                            const GrB_Index        *row_indices,
                            const GrB_Index         nrows,
                            GrB_Index               col_index,
                            const GrB_Descriptor    desc); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]   ({\sf INOUT}) The matrix in which to assign column of values.

    \item[{\sf mask}] ({\sf IN}) Output mask. The mask specifies which elements
    of {\sf C} can be modified. If no mask is necessary (i.e., compute all
    elements of a column of {\sf C}), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) Operator used for accumulation into {\sf C}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf u}]     ({\sf IN}) The vector of values to assign in a column of {\sf C}.

    \item[{\sf row\_indices}] ({\sf IN}) An array of row indices to assign. Can be set
                              to a special array, {\sf GrB\_ALL}, if all elements
                              in the column are to be assigned.
    \item[{\sf nrows}]  ({\sf IN}) The number of indices in array {\sf row\_indices}.
    \item[{\sf col\_index}]  ({\sf IN}) The index of the column to assign.

    \item[{\sf desc}]   ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used. Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} &  Output column in {\sf C} 
                                       is cleared (all elements removed) before 
                                       result is stored in it. \scott{JUST THE COLUMN?}\\
    {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_OUT\_OF\_MEMORY}]            Not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf C} or {\sf row\_indices} pointer is {\sf NULL}.
\item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  The indices specify a position that outside the dimensions of {\sf C}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf row\_indices}, as specified in parameter {\sf nrows}, is greater than the size of {\sf u}, or
        the dimensions of the mask (if specified) do not match {\sf C}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between vector/matrix domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}

\paragraph{Description}

Vectors $\vector{u}$ and $\vector{mask}$ are computed from input parameters {\sf u} and {\sf mask}, respectively,
as specified by descriptor {\sf desc}. If the shape of $\vector{u}$ does not match argument {\sf nrows},
return {\sf GrB\_DIMENSION\_MISMATCH}.

For each $i \in \{0, 1, \ldots, {\sf nrows}-1 \} : \vector{mask}[i] = \true$, do the following:
\begin{itemize}
	\item[] If $(i,u_{i}) \notin \bold{L}(\matrix{u})$ skip to next $i$.
	\item[] If $({\sf row\_indices}[i], {\sf col\_index}, {\sf C}[{\sf row\_indices}[i],{\sf col\_index}]) \notin \bold{L}({\sf C})$ then
	      $\bold{L}({\sf C}) \leftarrow \bold{L}({\sf C}) \cup ({\sf row\_indices}[i],{\sf col\_index},u_{i})$.
	\item[]  Else, update ${\sf C}[{\sf row\_indices}[i],{\sf col\_index}] \leftarrow {\sf accum}({\sf C}[{\sf row\_indices}[i],{\sf col\_index}],u_{i})$.
\end{itemize}


%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Row variant}

Assign to one row of a matrix from a vector.  

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Matrix             *C,
                            const GrB_Vector        mask,
                            const GrB_BinaryOp      accum,
                            const GrB_Vector        u,
                            GrB_Index               row_index,
                            const GrB_Index        *col_indices,
                            const GrB_Index         ncols,
                            const GrB_Descriptor    desc); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]   ({\sf INOUT}) The matrix in which to assign column of values.

    \item[{\sf mask}] ({\sf IN}) Output mask. The mask specifies which elements
    of {\sf C} can be modified. If no mask is necessary (i.e., compute all
    elements of a column of {\sf C}), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) Function used for accumulation into {\sf C}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf u}]     ({\sf IN}) The vector of values to assign in a column of {\sf C}.

    \item[{\sf row\_index}]  ({\sf IN}) The index of the row to assign.
    \item[{\sf col\_indices}] ({\sf IN}) An array of column indices to assign. Can be
                              set to a special array, {\sf GrB\_ALL}, if all
                              elements are to be assigned to the row.
    \item[{\sf ncols}]  ({\sf IN}) The size of {\sf col\_indices}.

    \item[{\sf desc}]   ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used. Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} &   Output row in {\sf C} 
                                       is cleared (all elements removed) before 
                                       result is stored in it. \scott{JUST THE ROW?}\\
    {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_OUT\_OF\_MEMORY}]            Not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf C} or {\sf col\_indices} pointer is {\sf NULL}.
\item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  The indices specify a position that outside the dimensions of {\sf C}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf col\_indices}, as specified in parameter {\sf ncols}, is greater than the size of {\sf u}, or
        the dimensions of the mask (if specified) do not match {\sf C}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between vector/matrix domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}

\paragraph{Description}

Vectors $\vector{u}$ and $\vector{mask}$ are computed from input parameters {\sf u} and {\sf mask}, respectively,
as specified by descriptor {\sf desc}. If the shape of $\vector{u}$ does not match argument {\sf mask},
return {\sf GrB\_DIMENSION\_MISMATCH}.

For each $j \in \{0, 1, \ldots, {\sf ncols}-1 \} : \vector{mask}[j] = \true$, do the following:
\begin{itemize}
	\item[] If $(j,u_{j}) \notin \bold{L}(\matrix{u})$ skip to next $j$.
	\item[] If $({\sf row\_index}, {\sf col\_indices}[j], {\sf C}[{\sf row\_index},{\sf col\_indices}[j]]) \notin \bold{L}({\sf C})$ then
	      $\bold{L}({\sf C}) \leftarrow \bold{L}({\sf C}) \cup ({\sf row\_index},{\sf col\_indices}[j],u_{j})$.
	\item[]  Else, update ${\sf C}[{\sf row\_index},{\sf col\_indices}[j]] \leftarrow {\sf accum}({\sf C}[{\sf row\_index},{\sf col\_indices}[j]],u_{j})$.
\end{itemize}

%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Single element vector variant}

Set one element of a vector to a given value.

\scott{I have tried to make this more consistent with the standard version by
adding things like accum. If the destination location is a structural zero, is
a stored value created?.
This could be construed as inconsistent behaviour with standard version.}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Vector           *w,
                            const GrB_BinaryOp    accum,
                            <type>                val,
                            GrB_Index             index,
                            const GrB_Descriptor  desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]   ({\sf INOUT}) Vector/matrix for which an element is to be assigned.

    \item[{\sf accum}] ({\sf IN}) Function used for accumulation into {\sf w}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf val}]   ({\sf IN}) Scalar value to assign to the element.  The type must
                              be consistent with the domain of {\sf w} (or castable, if allowed).
    \item[{\sf index}] ({\sf IN}) Index of element to be assigned

    \item[{\sf desc}]  ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used. Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & \scott{If the column/row variant only clears the column/row of a matrix, this one would only clear the element.  If so, replace mode is not needed. Does this make sense?} \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_OUT\_OF\_MEMORY}]            Not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initalized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf ws} pointer is {\sf NULL}.
\item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  {\sf index} specifies a position that outside the dimensions of {\sf w}
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between vector/matrix domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}

\paragraph{Description}
\scott{DESCRIPTION MISSING}

%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Single element matrix variant}

Set one element of a matrix to a given value.

\scott{I have tried to make this more consistent with the standard version by
adding things like accum. If the destination location is a structural zero, is
a stored value created?.
This could be construed as inconsistent behaviour with standard version.}

\scott{Both single value variants don't have masks and an argument can be made
for not needing a descriptor.  Is this also a Matrix/Vector method?}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Matrix           *C,
                            const GrB_BinaryOp    accum,
                            <type>                val,
                            GrB_Index             row_index,
                            GrB_Index             col_index,
                            const GrB_Descriptor  desc); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]   ({\sf INOUT}) Vector/matrix for which an element is to be assigned.

    \item[{\sf accum}] ({\sf IN}) Function used for accumulation into {\sf C}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf val}]   ({\sf IN}) Scalar value to assign to the element.  The type must
                              be consistent with the domain of C (or castable, if allowed).
    \item[{\sf row\_index}] ({\sf IN}) Row index of element to be assigned
    \item[{\sf col\_index}] ({\sf IN}) Column index of element to be assigned

    \item[{\sf desc}]  ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used. Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}     & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & \scott{If the column/row variant only clears the column/row of a matrix, this one would only clear the element.  If so, replace mode is not needed. Does this make sense?} \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_OUT\_OF\_MEMORY}]            Not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf C} pointer is {\sf NULL}.
\item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  The ({\sf row\_index, col\_index}) indexes specify a position that outside the dimensions of {\sf C}
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between matrix domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}

\paragraph{Description}
\scott{DESCRIPTION MISSING}

%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Constant vector variant}

Assign the same value to a specified subgraph.  With use of {\sf GrB\_ALL} the entire
destination vector or matrix can be filled with the constant.

\scott{We should also seriously consider a fill method for Vector and Matrix.}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Vector             *w,
                            const GrB_Vector        mask,
                            const GrB_BinaryOp      accum,
                            <type>                  val,
                            const GrB_Index        *indices,
                            const GrB_Index         nindices,
                            const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]   ({\sf INOUT}) Vector to be assigned.

    \item[{\sf mask}]     ({\sf IN}) Output mask. The mask specifies which elements
                              of {\sf w} can be modified. If no mask is necessary, 
                              {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]    ({\sf IN}) Operator used for accumulation into {\sf w}.
                              If no accumulation is desired, {\sf GrB\_NULL} 
                              should be specified.

    \item[{\sf val}]      ({\sf IN}) Scalar value to assign to all elements.
    \item[{\sf indices}]  ({\sf IN}) An array of indices specifying locations in
                              {\sf w} that are assigned from {\sf val}.  Can be set
                              to a special array, {\sf GrB\_ALL}, if all elements
                              in {\sf w} are to be assigned.
    \item[{\sf nindices}] ({\sf IN}) The size of {\sf indices}.

    \item[{\sf desc}]     ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used. Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w} is cleared (all elements removed) before result is stored in it.\\
    {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully
\item[{\sf GrB\_PANIC}]               Unknown internal error
\item[{\sf GrB\_OUT\_OF\_MEMORY}]            Not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf w} or {\sf indices} pointer is {\sf NULL}.
\item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]
        A value in indices references a nonexistent row in {\sf w}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        the dimensions of the mask (if specified) do not match {\sf w}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between vector domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}


\paragraph{Description}
\scott{DESCRIPTION MISSING}

%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Constant matrix variant}

Assign the same value to a specified subgraph.  With use of {\sf GrB\_ALL} the entire
destination vector or matrix can be filled with the constant.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Matrix             *C,
                            const GrB_Matrix        Mask,
                            const GrB_BinaryOp      accum,
                            <type>                  val,
                            const GrB_Index        *row_indices,
                            const GrB_Index         nrows,
                            const GrB_Index        *col_indices,
                            const GrB_Index         ncols,
                            const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) Matrix to be assigned.

    \item[{\sf mask}] ({\sf IN}) Output mask. The mask specifies which elements
    of {\sf C} can be modified. If no mask is necessary, {\sf GrB\_NULL} should 
    be specified.

    \item[{\sf accum}] ({\sf IN}) Operator used for accumulation into {\sf C}.  
    If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf val}]    ({\sf IN}) Scalar value to assign to all elements.
    \item[{\sf row\_indices}] ({\sf IN}) An array of row indices specifying locations 
                              in {\sf C} that are assigned from {\sf val}. Can be set
                              to a special array, {\sf GrB\_ALL}, if all rows
                              in {\sf C} are to be assigned.
    \item[{\sf nrows}]  ({\sf IN}) The size of {\sf row\_indices}.
    \item[{\sf col\_indices}] ({\sf IN}) An array of column indices specifying locations
                              in {\sf C} that are assigned from {\sf val}. Can be set
                              to a special array, {\sf GrB\_ALL}, if all columns
                              in {\sf C} are to be assigned.
    \item[{\sf ncols}]  ({\sf IN}) The size of {\sf col\_indices}.


    \item[{\sf desc}]   ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used. Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C} is cleared (all elements removed) before result is stored in it.\\
    {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf Mask}. \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_OUT\_OF\_MEMORY}]            Not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf C}, {\sf row\_indices}, or {\sf col\_indices} pointer is {\sf NULL}.
\item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]
        A value in {\sf row\_indices} references a nonexistent row in {\sf C}, or
        the value in {\sf col\_indices} references a nonexistent column in {\sf C}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        the dimensions of the mask (if specified) do not match {\sf C}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between vector/matrix domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}


\paragraph{Description}
\scott{DESCRIPTION MISSING}
