\subsection{{\sf assign}: Modifying Sub-Graphs}
\label{Sec:assign}

Assign a matrix (vector) to a subset  of a larger matrix (vector) as specified by a index sets.

\jose{We need to discuss if the additional parameters (m,n) that specify the length of index vectors
should be included. They are not strictly necessary, but they make for a self contained description.}


%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Standard vector variant}

In the standard version of {\sf assign}, a single GraphBLAS index array specifies
the locations in the destination vector that should be assigned with values
from the source vector.  The size of the source vector is the same size as the one
index array provided.

If an accumulation function is specified, then that function is used
to combine current elements in the destination with those elements
from the source.  If no accumulation function is specified, then the
destination is overwritten with the source.


\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Vector             *w,
                            const GrB_Vector        mask,
                            const GrB_BinaryOp      accum,
                            const GrB_Vector        u,
                            const GrB_Index        *indices,
                            const GrB_Index         nindices,
                            const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) The vector into which to assign the subgraph.
    \item[{\sf mask}] ({\sf IN}) Output mask. The mask specifies which elements
    of {\sf w} can be modified. If no mask is necessary (i.e., compute all
    elements of destination vector), {\sf GrB\_NULL} should be specified.
    \item[{\sf accum}] ({\sf IN}) Operator used for accumulation into existing {\sf w} entries.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.
    \item[{\sf u}]     ({\sf IN}) The vector containing the subgraph.
    \item[{\sf indices}] ({\sf IN}) An array of indices specifying locations in {\sf w} that
                          are assigned from {\sf u}.
    \item[{\sf nindices}] ({\sf IN}) The number of indices in array {\sf indices}.
    \item[{\sf desc}]     ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used. Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf w}   & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w} 
                                       is cleared (all elements removed) before 
                                       result is stored in it.\\
    {\sf mask}& {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]      operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]     not enough memory available for operation.
\item[{\sf GrB\_NOOBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_INVALID\_VALUE}]    {\sf w} or {\sf indices} pointer is {\sf NULL}.

\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]
        A value in {\sf indices} references an invalid element of {\sf w} (negative or larger than or equal the size of {\sf w}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf indices} (namely {\sf nindices}) is greater than the number of elements in {\sf u}, or
        the dimensions of the mask (if specified) do not match {\sf w}.
\item[\sf GrB\_DOMAIN\_MISMATCH]  
       domain mismatch between vectors or between vector and the accumulation function when casting is disabled.
\end{itemize}

\paragraph{Description}

Vectors $\vector{u}$ and $\vector{mask}$ are computed from input parameters {\sf u} and {\sf mask}, respectively, as specified by descriptor {\sf desc}. If
the size of $\vector{u}$ does not match argument {\sf n}, return {\sf GrB\_DIMENSION\_MISTMATCH}.

For each $i \in \{0, 1, \ldots, {\sf nindices}-1 \} : \vector{mask}[i] = \true$, do the following:
\begin{itemize}
	\item[] If $(i, u_i) \notin \bold{L}(\vector{u})$ skip to the next $i$.
	\item[] If $({\sf indices}[i], {\sf w}[{\sf indices}[i]]) \notin \bold{L}({\sf w})$ then
	      $\bold{L}({\sf w}) \leftarrow \bold{L}({\sf w}) \cup ({\sf indices}[i],u_i)$.
	\item[] Else, update ${\sf w}[{\sf indices}[i]] \leftarrow {\sf accum}({\sf w}[{\sf indices}[i]],u_i)$.
\end{itemize}


%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Standard matrix variant}

In the standard version of {\sf assign}, two GraphBLAS index arrays (for row and
column indices) specify the locations in the destination matrix that should be 
assigned with values from the source matrix.  The size of the source matrix has the same
number of rows as the size of the row index array and the same number
of columns as the size of the column index array.

If an accumulation function is specified, then that function is used
to combine current elements in the destination with those elements
from the source.  If no accumulation function is specified, then the
destination is overwritten with the source.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Matrix             *C,
                            const GrB_Matrix        Mask,
                            const GrB_BinaryOp      accum,
                            const GrB_Matrix        A,
                            const GrB_Index        *rowIDs,
                            const GrB_Index         nrows,
                            const GrB_Index        *colIDs,
                            const GrB_Index         ncols,
                            const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]      ({\sf INOUT}) The matrix into which to assign the subgraph.
    \item[{\sf Mask}]   ({\sf IN}) Output mask. The mask specifies which elements
    of {\sf C} can be modified. If no mask is necessary (i.e., compute all
    elements of destination matrix), {\sf GrB\_NULL} should be specified.
    \item[{\sf accum}]  ({\sf IN}) Operator used for accumulation into existing {\sf C} entries.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.
    \item[{\sf A}]      ({\sf IN}) The matrix containing the subgraph.
    \item[{\sf rowIDs}] ({\sf IN}) An array of row indices specifying locations
                        in {\sf C} that are assigned from {\sf A}. Can be set to
                        a special array, {\sf GrB\_ALL}, if all rows of {\sf C}
                        are to be assigned.
    \item[{\sf nrows}]  ({\sf IN}) The number of indices in array {\sf rowIDs}.
    \item[{\sf colIDs}] ({\sf IN}) An array of column indices specifying locations 
                        in {\sf C} that are assigned from {\sf A}. Can be set to
                        a special array, {\sf GrB\_ALL}, if all columns of {\sf C}
                        are to be assigned.
    \item[{\sf ncols}]  ({\sf IN}) The number of indices in array {\sf colIDs}.
    \item[{\sf desc}]   ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used. Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} &  Output matrix {\sf C} 
                                       is cleared (all elements removed) before 
                                       result is stored in it.\\
    {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf Mask}. \\
    {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Apply transpose to {\sf A} before assign. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]      operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]     not enough memory available for operation.
\item[{\sf GrB\_NOOBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_INVALID\_VALUE}]    {\sf C}, {\sf rowIDs}, or {\sf colIDs} pointer is {\sf NULL}.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]
        A value in {\sf rowIDs} references an invalid row of {\sf C} (negative or larger than or equal the number of rows of {\sf C}),
        or a value in {\sf colIDs} references an invalid column of {\sf A} (negative or larger than or equal the number of columns of {\sf C}).
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf rowIDs} is greater than the number of rows in {\sf A}, or
        the size of {\sf colIDs} is greater than the number of columns in {\sf A}, or
        the dimensions of the mask (if specified) do not match {\sf C}.
\item[\sf GrB\_DOMAIN\_MISMATCH]  
       Domain mismatch between matrices or between matrix and the accumulation function when casting is disabled.
\end{itemize}

\paragraph{Description}

Matrices $\matrix{A}$ and $\matrix{Mask}$ are computed from input parameters {\sf A} and {\sf Mask}, respectively,
as specified by descriptor {\sf desc}. If the shape of $\matrix{A}$ does not match arguments {\sf nrows} and {\sf ncols},
return {\sf GrB\_DIMENSION\_MISMATCH}.

For each $\langle i,j \rangle \in \{0, 1, \ldots, {\sf nrows}-1 \} \times \{0, 1, \ldots, {\sf ncols}-1 \} : \matrix{Mask}[i,j] = \true$, do the following:
\begin{itemize}
	\item[] If $(i,j,A_{ij}) \notin \bold{L}(\matrix{A})$ skip to next $\langle i,j \rangle$.
	\item[] If $({\sf rowIDs}[i], {\sf colIDs}[j], {\sf C}[{\sf rowIDs}[i],{\sf colIDs}[j]]) \notin \bold{L}({\sf C})$ then
	      $\bold{L}({\sf C}) \leftarrow \bold{L}({\sf C}) \cup ({\sf rowIDs}[i],{\sf colIDs}[j],A_{ij})$.
	\item[]  Else, update ${\sf C}[{\sf rowIDs}[i],{\sf colIDs}[j]] \leftarrow {\sf accum}({\sf C}[{\sf rowIDs}[i]],{\sf colIDs}[j],A_{ij})$.
\end{itemize}

%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Column variant}

Assign to one column of a matrix from a vector.  

\scott{Note we cannot use transpose on dst to assign a row, so in this case we have two assign functions.  Should I add the second function back into extract variant and ditch the transpose descriptor?}

\scott{The mask in this variant is odd.  It is a vector while the destination is
a matrix.}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Matrix             *C,
                            const GrB_Vector        mask,
                            const GrB_BinaryOp      accum,
                            const GrB_Vector        u,
                            const GrB_Index        *rowIDs,
                            const GrB_Index         nrows,
                            GrB_Index               colID,
                            const GrB_Descriptor    desc); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]   ({\sf INOUT}) The matrix in which to assign column of values.

    \item[{\sf mask}] ({\sf IN}) Output mask. The mask specifies which elements
    of {\sf C} can be modified. If no mask is necessary (i.e., compute all
    elements of a column of {\sf C}), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) Operator used for accumulation into {\sf C}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf u}]     ({\sf IN}) The vector of values to assign in a column of {\sf C}.

    \item[{\sf rowIDs}] ({\sf IN}) An array of row indices to assign. Can be set
                              to a special array, {\sf GrB\_ALL}, if all elements
                              in the column are to be assigned.
    \item[{\sf nrows}]  ({\sf IN}) The number of indices in array {\sf rowIDs}.
    \item[{\sf colID}]  ({\sf IN}) The index of the column to assign.

    \item[{\sf desc}]   ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used. Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} &  Output column in {\sf C} 
                                       is cleared (all elements removed) before 
                                       result is stored in it. \scott{JUST THE COLUMN?}\\
    {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]            Not enough memory available for operation.
\item[{\sf GrB\_NOOBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_INVALID\_VALUE}]    {\sf C} or {\sf rowIDs} pointer is {\sf NULL}.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  The indices specify a position that outside the dimensions of {\sf C}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf rowIDs}, as specified in parameter {\sf nrows}, is greater than the size of {\sf u}, or
        the dimensions of the mask (if specified) do not match {\sf C}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between vector/matrix domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}

\paragraph{Description}

Vectors $\vector{u}$ and $\vector{mask}$ are computed from input parameters {\sf u} and {\sf mask}, respectively,
as specified by descriptor {\sf desc}. If the shape of $\vector{u}$ does not match argument {\sf nrows},
return {\sf GrB\_DIMENSION\_MISMATCH}.

For each $i \in \{0, 1, \ldots, {\sf nrows}-1 \} : \vector{mask}[i] = \true$, do the following:
\begin{itemize}
	\item[] If $(i,u_{i}) \notin \bold{L}(\matrix{u})$ skip to next $i$.
	\item[] If $({\sf rowIDs}[i], {\sf colID}, {\sf C}[{\sf rowIDs}[i],{\sf colID}]) \notin \bold{L}({\sf C})$ then
	      $\bold{L}({\sf C}) \leftarrow \bold{L}({\sf C}) \cup ({\sf rowIDs}[i],{\sf colID},u_{i})$.
	\item[]  Else, update ${\sf C}[{\sf rowIDs}[i],{\sf colID}] \leftarrow {\sf accum}({\sf C}[{\sf rowIDs}[i],{\sf colID}],u_{i})$.
\end{itemize}


%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Row variant}

Assign to one row of a matrix from a vector.  

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Matrix             *C,
                            const GrB_Vector        mask,
                            const GrB_BinaryOp      accum,
                            const GrB_Vector        u,
                            GrB_Index               rowID,
                            const GrB_Index        *colIDs
                            const GrB_Index         ncols,
                            const GrB_Descriptor    desc); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]   ({\sf INOUT}) The matrix in which to assign column of values.

    \item[{\sf mask}] ({\sf IN}) Output mask. The mask specifies which elements
    of {\sf C} can be modified. If no mask is necessary (i.e., compute all
    elements of a column of {\sf C}), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) Function used for accumulation into {\sf C}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf u}]     ({\sf IN}) The vector of values to assign in a column of {\sf C}.

    \item[{\sf rowID}]  ({\sf IN}) The index of the row to assign.
    \item[{\sf colIDs}] ({\sf IN}) An array of column indices to assign. Can be
                              set to a special array, {\sf GrB\_ALL}, if all
                              elements are to be assigned to the row.
    \item[{\sf ncols}]  ({\sf IN}) The size of {\sf colIDs}.

    \item[{\sf desc}]   ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used. Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} &   Output row in {\sf C} 
                                       is cleared (all elements removed) before 
                                       result is stored in it. \scott{JUST THE ROW?}\\
    {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]            Not enough memory available for operation.
\item[{\sf GrB\_NOOBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_INVALID\_VALUE}]    {\sf C} or {\sf colIDs} pointer is {\sf NULL}.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  The indices specify a position that outside the dimensions of {\sf C}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf colIDs}, as specified in parameter {\sf ncols}, is greater than the size of {\sf u}, or
        the dimensions of the mask (if specified) do not match {\sf C}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between vector/matrix domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}

\paragraph{Description}

Vectors $\vector{u}$ and $\vector{mask}$ are computed from input parameters {\sf u} and {\sf mask}, respectively,
as specified by descriptor {\sf desc}. If the shape of $\vector{u}$ does not match argument {\sf mask},
return {\sf GrB\_DIMENSION\_MISMATCH}.

For each $j \in \{0, 1, \ldots, {\sf ncols}-1 \} : \vector{mask}[j] = \true$, do the following:
\begin{itemize}
	\item[] If $(j,u_{j}) \notin \bold{L}(\matrix{u})$ skip to next $j$.
	\item[] If $({\sf rowID}, {\sf colIDs}[j], {\sf C}[{\sf rowID},{\sf colIDs}[j]]) \notin \bold{L}({\sf C})$ then
	      $\bold{L}({\sf C}) \leftarrow \bold{L}({\sf C}) \cup ({\sf rowID},{\sf colIDs}[j],u_{j})$.
	\item[]  Else, update ${\sf C}[{\sf rowID},{\sf colIDs}[j]] \leftarrow {\sf accum}({\sf C}[{\sf rowID},{\sf colIDs}[j]],u_{j})$.
\end{itemize}

%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Single-Value vector variant}

Set one element of a vector to a given value.

\scott{I have tried to make this more consistent with the standard version by
adding things like accum. If the destination location is a structural zero, is
a stored value created?.
This could be construed as inconsistent behaviour with standard version.}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Vector           *w,
                            const GrB_BinaryOp    accum,
                            <type>                val,
                            GrB_Index             index,
                            const GrB_Descriptor  desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]   ({\sf INOUT}) Vector/matrix for which an element is to be assigned.

    \item[{\sf accum}] ({\sf IN}) Function used for accumulation into {\sf w}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf val}]   ({\sf IN}) Scalar value to assign to the element.  The type must
                              be consistent with the domain of {\sf w} (or castable, if allowed).
    \item[{\sf index}] ({\sf IN}) Index of element to be assigned

    \item[{\sf desc}]  ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used. Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & \scott{If the column/row variant only clears the column/row of a matrix, this one would only clear the element.  If so, replace mode is not needed. Does this make sense?} \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]            Not enough memory available for operation.
\item[{\sf GrB\_NOOBJECT}]          one or more of the GraphBLAS objects has
                                    not been initalized by a call to {\sf new}.
\item[{\sf GrB\_INVALID\_VALUE}]    {\sf ws} pointer is {\sf NULL}.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  {\sf index} specifies a position that outside the dimensions of {\sf w}
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between vector/matrix domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}

\paragraph{Description}
\scott{DESCRIPTION MISSING}

%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Single-Value matrix variant}

Set one element of a matrix to a given value.

\scott{I have tried to make this more consistent with the standard version by
adding things like accum. If the destination location is a structural zero, is
a stored value created?.
This could be construed as inconsistent behaviour with standard version.}

\scott{Both single value variants don't have masks and an argument can be made
for not needing a descriptor.  Is this also a Matrix/Vector method?}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Matrix           *C,
                            const GrB_BinaryOp    accum,
                            <type>                val,
                            GrB_Index             rowID,
                            GrB_Index             colID,
                            const GrB_Descriptor  desc); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]   ({\sf INOUT}) Vector/matrix for which an element is to be assigned.

    \item[{\sf accum}] ({\sf IN}) Function used for accumulation into {\sf C}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf val}]   ({\sf IN}) Scalar value to assign to the element.  The type must
                              be consistent with the domain of C (or castable, if allowed).
    \item[{\sf rowID}] ({\sf IN}) Row index of element to be assigned
    \item[{\sf colID}] ({\sf IN}) Column index of element to be assigned

    \item[{\sf desc}]  ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used. Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}     & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & \scott{If the column/row variant only clears the column/row of a matrix, this one would only clear the element.  If so, replace mode is not needed. Does this make sense?} \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]            Not enough memory available for operation.
\item[{\sf GrB\_NOOBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_INVALID\_VALUE}]    {\sf C} pointer is {\sf NULL}.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  The ({\sf rowID, colID}) indexes specify a position that outside the dimensions of {\sf C}
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between matrix domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}

\paragraph{Description}
\scott{DESCRIPTION MISSING}

%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Vector constant variant}

Assign the same value to a specified subgraph.  With use of {\sf GrB\_ALL} the entire
destination vector or matrix can be filled with the constant.

\scott{We should also seriously consider a fill method for Vector and Matrix.}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Vector             *w,
                            const GrB_Vector        mask,
                            const GrB_BinaryOp      accum,
                            <type>                  val,
                            const GrB_Index        *indices,
                            const GrB_Index         nindices,
                            const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]   ({\sf INOUT}) Vector to be assigned.

    \item[{\sf mask}]     ({\sf IN}) Output mask. The mask specifies which elements
                              of {\sf w} can be modified. If no mask is necessary, 
                              {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]    ({\sf IN}) Operator used for accumulation into {\sf w}.
                              If no accumulation is desired, {\sf GrB\_NULL} 
                              should be specified.

    \item[{\sf val}]      ({\sf IN}) Scalar value to assign to all elements.
    \item[{\sf indices}]  ({\sf IN}) An array of indices specifying locations in
                              {\sf w} that are assigned from {\sf val}.  Can be set
                              to a special array, {\sf GrB\_ALL}, if all elements
                              in {\sf w} are to be assigned.
    \item[{\sf nindices}] ({\sf IN}) The size of {\sf indices}.

    \item[{\sf desc}]     ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used. Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w} is cleared (all elements removed) before result is stored in it.\\
    {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully
\item[{\sf GrB\_PANIC}]               Unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            Not enough memory available for operation.
\item[{\sf GrB\_NOOBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_INVALID\_VALUE}]    {\sf w} or {\sf indices} pointer is {\sf NULL}.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]
        A value in indices references a nonexistent row in {\sf w}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        the dimensions of the mask (if specified) do not match {\sf w}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between vector domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}


\paragraph{Description}
\scott{DESCRIPTION MISSING}

%-----------------------------------------------------------------------------
\subsubsection{{\sf assign}: Matrix constant variant}

Assign the same value to a specified subgraph.  With use of {\sf GrB\_ALL} the entire
destination vector or matrix can be filled with the constant.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_assign(GrB_Matrix             *C,
                            const GrB_Matrix        Mask,
                            const GrB_BinaryOp      accum,
                            <type>                  val,
                            const GrB_Index        *rowIDs,
                            const GrB_Index         nrows,
                            const GrB_Index        *colIDs,
                            const GrB_Index         ncols,
                            const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) Matrix to be assigned.

    \item[{\sf mask}] ({\sf IN}) Output mask. The mask specifies which elements
    of {\sf C} can be modified. If no mask is necessary, {\sf GrB\_NULL} should 
    be specified.

    \item[{\sf accum}] ({\sf IN}) Operator used for accumulation into {\sf C}.  
    If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf val}]    ({\sf IN}) Scalar value to assign to all elements.
    \item[{\sf rowIDs}] ({\sf IN}) An array of row indices specifying locations 
                              in {\sf C} that are assigned from {\sf val}. Can be set
                              to a special array, {\sf GrB\_ALL}, if all rows
                              in {\sf C} are to be assigned.
    \item[{\sf nrows}]  ({\sf IN}) The size of {\sf rowIDs}.
    \item[{\sf colIDs}] ({\sf IN}) An array of column indices specifying locations
                              in {\sf C} that are assigned from {\sf val}. Can be set
                              to a special array, {\sf GrB\_ALL}, if all columns
                              in {\sf C} are to be assigned.
    \item[{\sf ncols}]  ({\sf IN}) The size of {\sf colIDs}.


    \item[{\sf desc}]   ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used. Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C} is cleared (all elements removed) before result is stored in it.\\
    {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf Mask}. \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_NOMATRIX}]            Matrix does not exist.
\item[{\sf GrB\_OUTOFMEM}]            Not enough memory available for operation.
\item[{\sf GrB\_NOOBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_INVALID\_VALUE}]    {\sf C}, {\sf rowIDs}, or {\sf colIDs} pointer is {\sf NULL}.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]
        A value in {\sf rowIDs} references a nonexistent row in {\sf C}, or
        the value in {\sf colIDs} references a nonexistent column in {\sf C}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        the dimensions of the mask (if specified) do not match {\sf C}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between vector/matrix domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}


\paragraph{Description}
\scott{DESCRIPTION MISSING}
