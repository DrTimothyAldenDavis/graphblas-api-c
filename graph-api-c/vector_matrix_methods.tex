\subsection{Vector Methods}

%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_new}: Create new vector}

Creates a new vector with specified domain and size.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_new(GrB_Vector *v,
                                GrB_Type    d,
                                GrB_Index   nsize);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf v}] ({\sf INOUT}) On successful return, contains a handle
                                 to the newly created GraphBLAS vector.
    \item[{\sf d}] ({\sf IN})    The type corresponding to the domain of the 
                                 vector being created.  Can be one of the 
                                 predefined GraphBLAS types in 
                                 Table~\ref{Tab:PredefinedTypes}, or an existing 
                                 user-defined GraphBLAS type.
    \item[{\sf nsize}] ({\sf IN}) The size of the vector being created.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output vector 
    {\sf v} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The {\sf GrB\_Type} object has not 
    been initialized by a call to {\sf GrB\_Type\_new} (needed for user-defined types).
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf v} pointer is {\sf NULL}.
    
    \item[{\sf GrB\_INVALID\_VALUE}] {\sf nsize} is zero.
\end{itemize}

\paragraph{Description}

Creates a new vector $\vector{v}$ of domain $\mathbf{D}({\sf d})$, size {\sf nsize}, 
and empty $\mathbf{L}(\vector{v})$. The method returns a handle to the new vector in {\sf v}.

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created object will be overwritten. 

%\scott{In the context of non-blocking can this operation be deferred?}
%\aydin{why not?}

%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_dup}: Create a copy of a GraphBLAS vector}

Creates a new vector with the same domain, size, and contents as another vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_dup(GrB_Vector       *w,
                                const GrB_Vector  u);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]  ({\sf INOUT}) On successful return, contains a handle
                                  to the newly created GraphBLAS vector.
    \item[{\sf u}]  ({\sf IN})    The GraphBLAS vector to be duplicated.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output vector 
    {\sf w} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf u}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf w} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Creates a new vector $\vector{w}$ of domain $\mathbf{D}({\sf u})$, size 
$\mathbf{size}({\sf u})$, and contents $\mathbf{L}({\sf u})$. The method returns a 
handle to the new vector in {\sf w}.

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created object will be overwritten. 

%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_resize}: Resize a vector}

Changes the size of an existing vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_resize(GrB_Vector  w,
                                   GrB_Index   nsize);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}] ({\sf INOUT}) An existing Vector object that is being resized.
    \item[{\sf nsize}] ({\sf IN}) The new size of the vector. It can be smaller or larger than the current size.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output vector 
    {\sf w} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf w} pointer is {\sf NULL}.
    
    \item[{\sf GrB\_INVALID\_VALUE}] {\sf nsize} is zero.
\end{itemize}

\paragraph{Description}

Changes the size of ${\sf w}$ to {\sf nsize}. The domain
$\mathbf{D}({\sf w})$ of vector ${\sf w}$ remains the same. The
contents $\mathbf{L}({\sf w})$ are modified as described below.

Let ${\sf w} = \langle \mathbf{D}({\sf w}), N, \mathbf{L}({\sf w})
\rangle$ when the method is called. When the method returns, ${\sf w}
= \langle \mathbf{D}({\sf w}), {\sf nsize}, \mathbf{L'}({\sf w})
\rangle$ where $\mathbf{L'}({\sf w}) = \{(i,w_i) : (i,w_i) \in
\mathbf{L}({\sf w}) \wedge (i < {\sf nsize})\}$. That is, all elements
of ${\sf w}$ with index greater than or equal to the new vector size
(${\sf nsize}$) are dropped.

%\scott{In the context of non-blocking can this operation be deferred?}
%\aydin{why not?}

%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_clear}: Clear a vector}

Removes all the elements (tuples) from a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_clear(GrB_Vector v);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf v}] ({\sf INOUT}) An existing GraphBLAS vector to clear.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output vector 
    {\sf v} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf v}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
\end{itemize}

\paragraph{Description}

Removes all elements (tuples) from an existing vector. After the call to
{\sf GrB\_Vector\_clear(v)}, 
$\mathbf{L}(\vector{v}) = \emptyset$. The size of the vector does not change. 


%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_size}: Size of a vector}

Retrieve the size of a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_size(GrB_Index        *nsize,
                                 const GrB_Vector  v);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf nsize}] ({\sf OUT}) On successful return, is set to the size 
                                   of the vector.
    \item[{\sf v}]     ({\sf IN})  An existing GraphBLAS vector being queried.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]   In blocking or non-blocking mode, the operation 
    completed successfully and the value of {\sf nsize} has been set.

    \item[{\sf GrB\_PANIC}]     Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf v}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf nsize} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Return $\mathbf{size}({\sf v})$ in {\sf nsize}.

%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_nvals}: Number of stored elements in a vector}
\label{Sec:Vector_nvals}

Retrieve the number of stored elements (tuples) in a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_nvals(GrB_Index        *nvals,
                                  const GrB_Vector  v);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf nvals}] ({\sf OUT}) On successful return, this is set to the number of 
                                   stored elements (tuples) in the vector.
    \item[{\sf v}]     ({\sf IN})  An existing GraphBLAS vector being queried.
\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully and the value of {\sf nvals} has been set. 

    \item[{\sf GrB\_PANIC}]    Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf v}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf nvals} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}


Return $\mathbf{nvals}({\sf v})$ in {\sf nvals}. This is the number of stored 
elements in vector {\sf v}, which is the size of $\mathbf{L}(\vector{v})$ (see 
Section~\ref{Sec:Vectors}).

%-----------------------------------------------------------------------------

\subsubsection{{\sf Vector\_build}: Store elements from tuples into a vector \scott{NEW CONTENT}}
\label{Sec:Vector_build}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_build(GrB_Vector             w,
                                  const GrB_Index       *indices,
                                  const <type>          *values,
                                  GrB_Index              n,
                                  const GrB_BinaryOp     dup);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]       ({\sf INOUT}) An existing Vector object to store the result.
    \item[{\sf indices}] ({\sf IN}) Pointer to an array of indices. 
    \item[{\sf values}]  ({\sf IN}) Pointer to an array of scalars of a type that
                                     is compatible with the domain of vector {\sf w}.
    \item[{\sf n}]       ({\sf IN}) The number of entries contained in each array (the same for \arg{indices} and \arg{values}).
    \item[{\sf dup}]     ({\sf IN}) An associative and commutative binary operator 
    to apply when duplicate values for the same location are present in the input
    arrays. All three domains of {\sf dup} must be the same; hence
	    $dup=\langle D_{dup},D_{dup},D_{dup},\oplus \rangle$.
    If {\sf dup} is {\sf GrB\_NULL}, then duplicate locations will result in an error.  \scott{NEW CONTENT}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output vector 
    {\sf w} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  Either {\sf w} has not been 
    initialized by a call to {\sf by GrB\_Vector\_new} or 
    {\sf by GrB\_Vector\_dup}, or
    {\sf dup} has not been initialized by a call to {\sf by GrB\_BinaryOp\_new}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf indices} or {\sf values} 
    pointer is {\sf NULL}.

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}] A value in {\sf indices} is outside 
    the allowed range for {\sf w}.
    
	\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Either the domains of the GraphBLAS 
    binary operator {\sf dup} are not all the same, or the domains of 
    {\sf values} and {\sf w} are incompatible with each other or $D_{dup}$.
	
	\item[{\sf GrB\_OUTPUT\_NOT\_EMPTY}]    Output vector {\sf w} already contains valid tuples (elements).
	In other words, {\sf GrB\_Vector\_nvals(C)} returns a positive value.
    
    \item[{\sf GrB\_INVALID\_VALUE}] {\sf indices} contains a duplicate location
    and {\sf dup} is {\sf GrB\_NULL}. \scott{NEW CONTENT}
\end{itemize}

\paragraph{Description \scott{NEW CONTENT}}

If {\sf dup} is not {\sf GrB\_NULL}, an internal vector 
$\vector{\widetilde{w}} = \langle D_{dup},\mathbf{size}({\sf w}),\emptyset \rangle$ 
is created, which only differs from ${\sf w}$ in its domain; otherwise, 
$\vector{\widetilde{w}} = \langle \mathbf{D}({\sf w}),\mathbf{size}({\sf w}),\emptyset \rangle$.

Each tuple $\{ {\sf indices[k]}, {\sf values[k]}\}$, where $0\leq k < {\sf n}$, is a contribution to the output in the form of 
\[
\vector{\widetilde{w}}({\sf indices[k]}) = 
\begin{cases} 
(D_{dup})\, {\sf values[k]} & \text{ if {\sf dup} $\neq$ {\sf GrB\_NULL}} \\
(\mathbf{D}({\sf w}))\, {\sf values[k]} & \text{ otherwise.} 
\end{cases}
\]

If multiple values for the same location are present in the input arrays and 
{\sf dup} is not {\sf GrB\_NULL}, {\sf dup} is used to reduce the values 
before assignment into $\vector{\widetilde{w}}$ as follows: 
\[
\vector{\widetilde{w}}_{i}
= \bigoplus_{k:\, {\sf indices[k]} = i}  (D_{dup})\, {\sf values[k]}
,\] 
where $\oplus$ is the {\sf dup} binary operator. Finally, the resulting 
$\vector{\widetilde{w}}$ is copied into ${\sf w}$ via typecasting its values to 
$\mathbf{D}({\sf w})$ if necessary.  If $\oplus$ is not associative or not 
commutative, the result is undefined.  

The nonopaque input arrays, {\sf indices} and {\sf values}, must be at least as
large as {\sf n}. 

It is an error to call this function on an output object with existing elements. In other words, 
{\sf GrB\_Vector\_nvals(w)} should evaluate to zero prior to calling this function.

After {\sf GrB\_Vector\_build} returns, it is safe for a programmer to 
modify or delete the arrays {\sf indices} or {\sf values}.


%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_setElement}: Set a single element in a vector}

Set one element of a vector to a given value.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_setElement(GrB_Vector   w,
                                       <type>       val,
                                       GrB_Index    index);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]   ({\sf INOUT}) An existing GraphBLAS vector for which an 
    element is to be assigned.

    \item[{\sf val}]   ({\sf IN}) Scalar value to assign.  The type must
    be compatible with the domain of {\sf w}.

    \item[{\sf index}] ({\sf IN}) The location of the element to be assigned.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on index/dimensions and domains for the input arguments passed successfully. 
    Either way, the output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf w}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf index} specifies a location 
    that is outside the dimensions of {\sf w}.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of {\sf w} and {\sf val}
    are incompatible.
\end{itemize}

\paragraph{Description}

First, the scalar and output vector are tested for domain compatibility as follows:
$\mathbf{D}({\sf val})$ must be compatible with $\mathbf{D}({\sf w})$. Two domains 
are compatible with each other if values from one domain can be cast to values 
in the other domain as per the rules of the C language. In particular, domains 
from Table~\ref{Tab:PredefinedTypes} are all compatible with each other. A domain 
from a user-defined type is only compatible with itself. If any compatibility 
rule above is violated, execution of {\sf GrB\_Vector\_setElement} ends and 
the domain mismatch error listed above is returned.

Then, the {\sf index} parameter is checked for a valid value where the following
condition must hold:
\[
	0\ \leq\ {\sf index}\ <\ \mathbf{size}({\sf w})
\]
If this condition is violated, execution of {\sf GrB\_Vector\_extractElement} 
ends and the invalid index error listed above is returned.

We are now ready to carry out the assignment {\sf val}; that is:
\[
    {\sf w}({\sf index}) = {\sf val}
\]
If a value existed at this location in {\sf w}, it will be overwritten; otherwise,
and new value is stored in {\sf w}.

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.


%-----------------------------------------------------------------------------
\subsubsection{{\sf Vector\_removeElement}: Remove an element from a vector}

Remove (annihilate) one stored element from a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_removeElement(GrB_Vector   w,
                                          GrB_Index    index);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]   ({\sf INOUT}) An existing GraphBLAS vector from which an 
    element is to be removed.

    \item[{\sf index}] ({\sf IN}) The location of the element to be removed.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on index/dimensions and domains for the input arguments passed successfully. 
    Either way, the output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf w}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf index} specifies a location 
    that is outside the dimensions of {\sf w}.
\end{itemize}

\paragraph{Description}

First, the {\sf index} parameter is checked for a valid value where the following
condition must hold:
\[
	0\ \leq\ {\sf index}\ <\ \mathbf{size}({\sf w})
\]
If this condition is violated, execution of {\sf GrB\_Vector\_removeElement} 
ends and the invalid index error listed above is returned.

We are now ready to carry out the removal of a value that may be stored at the 
location specified by {\sf index}.  If a value does not exist at the specified 
location in {\sf w}, no error is reported and the operation has no effect on the 
state of {\sf w}.  In either case, the following will be true on return from the 
method: {\sf index} $\notin~\mathbf{ind}({\sf w})$.

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.

%-----------------------------------------------------------------------------

\subsubsection{{\sf Vector\_extractElement}: Extract a single element from a vector.}
\label{Sec:Vector_extractElement}

Extract one element of a vector into a scalar. 

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_extractElement(<type>           *val,
                                           const GrB_Vector  u,
                                           GrB_Index         index); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf val}]   ({\sf INOUT}) Pointer to a scalar of type that is 
    compatible with the domain of vector {\sf w}. On successful return, this scalar 
    holds the result of the operation. Any previous value in {\sf val} is 
    overwritten.

    \item[{\sf u}]     ({\sf IN}) The GraphBLAS vector from which an element
    is extracted.
    
    \item[{\sf index}] ({\sf IN}) The location in {\sf u} to extract.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully. This indicates that the compatibility tests on 
    dimensions and domains for the input arguments passed successfully, and
    the output scalar, {\sf val}, has been computed and is ready to be used in 
    the next method of the sequence.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
   % \scott{Is this error possible?}
    %\aydin{I think it might be possible. We don't know the internal "extract" algorithm so it might not be an "in-place" algorithm. Better safe than sorry}
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf u}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}]    {\sf val} pointer is {\sf NULL}.

    \item[{\sf GrB\_NO\_VALUE}]  There is no stored value at specified location.
    
    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf index} specifies a location 
    that is outside the dimensions of {\sf w}.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of the vector or scalar
    are incompatible.
\end{itemize}

\paragraph{Description}

First, the scalar and input vector are tested for domain compatibility as follows:
$\mathbf{D}({\sf val})$ must be compatible with $\mathbf{D}({\sf u})$. Two domains 
are compatible with each other if values from one domain can be cast to values 
in the other domain as per the rules of the C language. In particular, domains 
from Table~\ref{Tab:PredefinedTypes} are all compatible with each other. A domain 
from a user-defined type is only compatible with itself. If any compatibility 
rule above is violated, execution of {\sf GrB\_Vector\_extractElement} ends and 
the domain mismatch error listed above is returned.

Then, the {\sf index} parameter is checked for a valid value where the following
condition must hold:
\[
	0\ \leq\ {\sf index}\ <\ \mathbf{size}({\sf u})
\]
If this condition is violated, execution of {\sf GrB\_Vector\_extractElement} 
ends and the invalid index error listed above is returned.

We are now ready to carry out the extract into the output argument, {\sf val};  
that is:
\[
    {\sf val} = {\sf u}({\sf index})
\]
where the following condition must be true:
\[
    {\sf index} \in \mathbf{ind}({\sf u})
\]
If this condition is violated, execution of {\sf GrB\_Vector\_extractElement} 
ends and the "no value" error listed above is returned.

In both {\sf GrB\_BLOCKING} mode {\sf GrB\_NONBLOCKING} mode
if the method exits with return value {\sf GrB\_SUCCESS}, the  new 
contents of {\sf val} are as defined above.  

\comment{In other words, the method
does not return until any operations required to fully compute 
the GraphBLAS vector {\sf u} have completed. 

In {\sf GrB\_NONBLOCKING} mode, if the return value is 
not {\sf GrB\_SUCCESS}, an error in a method occurring earlier in the sequence
may have occurred that prevents completion of the GraphBLAS vector {\sf u}.
The {\sf GrB\_error()} method should be called for additional information 
about these errors.
}

%-----------------------------------------------------------------------------

\subsubsection{{\sf Vector\_extractTuples}: Extract tuples from a vector}
\label{Sec:Vector_extractTuples}

Extract the contents of a GraphBLAS vector into non-opaque data structures.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Vector_extractTuples(GrB_Index            *indices,
                                          <type>               *values,
                                          GrB_Index            *n, 
                                          const GrB_Vector      v);

\end{verbatim}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf indices}] ({\sf OUT}) Pointer to an array of indices that is
                        large enough to hold all of the stored values' indices.
    \item[{\sf values}] ({\sf OUT}) Pointer to an array of scalars of a type 
                        that is large enough to hold all of the stored values
                        whose type is compatible with $\mathbf{D}(\vector{v})$.
    \item[{\sf n}] ({\sf INOUT}) Pointer to a value indicating (on input) the number of
                        elements the {\sf values} and
                        {\sf indices} arrays can hold. Upon return, it will contain the
                        number of values written to the arrays.
    \item[{\sf v}]      ({\sf IN})  An existing GraphBLAS vector.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully. This indicates that the compatibility tests on 
    the input argument passed successfully, and the output arrays, {\sf indices}
    and {\sf values}, have been computed.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    %\scott{Is this error possible?}
    %\aydin{I think here it is really possible. We don't know the internal "extracttuples" algorithm so it might not be an "in-place" algorithm. Better safe than sorry}

    \item[{\sf GrB\_INSUFFICIENT\_SPACE}]  Not enough space in {\sf indices} and 
    {\sf values} (as indicated by the {\sf n} parameter) to hold all of the 
    tuples that will be extacted.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS vector, {\sf v}, has 
    not been initialized by a call to {\sf Vector\_new} or {\sf Vector\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}] {\sf indices}, {\sf values}, or {\sf n}
    pointer is {\sf NULL}.
     
    \item[{\sf GrB\_DOMAIN\_MISMATCH}] The domains of the {\sf v} vector or 
    {\sf values} array are incompatible with one another.
\end{itemize}


\paragraph{Description}


This method will extract all the tuples from the GraphBLAS vector {\sf v}.  
The values associated with those tuples are placed in the
{\sf values} array and the indices are placed in the {\sf indices} array. 
Both {\sf indices} and {\sf values} must be pre-allocated by the user to have enough
space to hold at least {\sf GrB\_Vector\_nvals(v)} elements before calling
this function. 

Upon return of this function, {\sf n} will be set to the number of values (and 
indices) copied.  Also, the entries of {\sf indices} are unique, but not 
necessarily sorted.  Each tuple $(i,v_i)$ in {\sf v} is unzipped and copied 
into a distinct $k$th location in output vectors:

$$ \{{\sf indices[k]}, {\sf values[k]}\} \leftarrow (i,v_i),$$

where $0 \leq k < {\sf GrB\_Vector\_nvals(v)}$. No gaps in
output vectors are allowed; that is, if {\sf indices[k]} and {\sf values[k]} 
exist upon return, so does
{\sf indices[j]} and {\sf values[j]} for all $j$ such that $0 \leq j < k$.

Note that if the value in {\sf n} on input is less than the number of values
contained in the vector {\sf v}, then a {\sf GrB\_INSUFFICIENT\_SPACE} error 
is returned because it is undefined which subset of values would
be extracted otherwise.

In both {\sf GrB\_BLOCKING} mode {\sf GrB\_NONBLOCKING} mode
if the method exits with return value {\sf GrB\_SUCCESS}, the  new 
contents of the arrays {\sf indices} and {\sf values} are as defined above.  

\comment{In 
other words, the method does not return until any operations required to fully 
compute the GraphBLAS vector {\sf v} have completed. 

In {\sf GrB\_NONBLOCKING} mode, if the return value is 
not {\sf GrB\_SUCCESS}, an error in a method occurring earlier in the sequence
may have occurred that prevents completion of the GraphBLAS vector {\sf v}.
The {\sf GrB\_error()} method should be called for additional information 
about these errors.
}


%==============================================================================
\subsection{Matrix Methods}

%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_new}: Create new matrix}

Creates a new matrix with specified domain and dimensions.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_new(GrB_Matrix *A,
                                GrB_Type    d,
                                GrB_Index   nrows,
                                GrB_Index   ncols);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf A}] ({\sf INOUT}) On successful return, contains a handle to 
                                 the newly created GraphBLAS matrix.
    \item[{\sf d}] ({\sf IN})    The type corresponding to the domain of the matrix 
                                 being created. Can be one of the predefined
                                 GraphBLAS types in Table~\ref{Tab:PredefinedTypes}, 
                                 or an existing user-defined GraphBLAS type.
    \item[{\sf nrows}] ({\sf IN}) The number of rows of the matrix being created.
    \item[{\sf ncols}] ({\sf IN}) The number of columns of the matrix being created.
\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf A} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The {\sf GrB\_Type} object has not 
    been initialized by a call to {\sf GrB\_Type\_new} (needed for user-defined types).
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf A} pointer is {\sf NULL}.
    
    \item[{\sf GrB\_INVALID\_VALUE}] {\sf nrows} or {\sf ncols} is zero.
\end{itemize}

\paragraph{Description}

Creates a new matrix $\matrix{A}$ of domain $\mathbf{D}({\sf d})$, size 
{\sf nrows $\times$ ncols}, and empty $\mathbf{L}(\matrix{A})$. The method returns a
handle to the new matrix in {\sf A}.

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created object will be overwritten. 

%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_dup}: Create a copy of a GraphBLAS matrix}

Creates a new matrix with the same domain, dimensions, and contents as 
another matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_dup(GrB_Matrix       *C,
                                const GrB_Matrix  A);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}] ({\sf INOUT}) On successful return, contains a handle to 
                                 the newly created GraphBLAS matrix.
    \item[{\sf A}] ({\sf IN})    The GraphBLAS matrix to be duplicated.
\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf C} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to {\sf Matrix\_new} or {\sf Matrix\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}]   The {\sf C} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Creates a new matrix $\matrix{C}$ of domain $\mathbf{D}({\sf A})$, size 
$\mathbf{nrows}({\sf A}) \times \mathbf{ncols}({\sf A})$, and contents 
$\mathbf{L}({\sf A})$. It returns a handle to it in {\sf C}.

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created object will be overwritten. 

%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_resize}: Resize a matrix}

Changes the dimensions of an existing matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_resize(GrB_Matrix  C,
                                   GrB_Index   nrows,
                                   GrB_Index   ncols);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}] ({\sf INOUT}) An existing Matrix object that is being resized.
    \item[{\sf nrows}] ({\sf IN}) The new number of rows of the matrix. It can be smaller or larger than the current number of rows.
    \item[{\sf ncols}] ({\sf IN}) The new number of columns of the matrix. It can be smaller or larger than the current number of columns.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf C} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf C} pointer is {\sf NULL}.
    
    \item[{\sf GrB\_INVALID\_VALUE}] {\sf nrows} or {\sf ncols} is zero.
\end{itemize}

\paragraph{Description}

Changes the number of rows and columsn of ${\sf C}$ to {\sf nrows} and {\sf ncols}, respectively. The domain
$\mathbf{D}({\sf C})$ of matrix ${\sf C}$ remains the same. The
contents $\mathbf{L}({\sf C})$ are modified as described below.

Let ${\sf C} = \langle \mathbf{D}({\sf C}), M, N, \mathbf{L}({\sf C})
\rangle$ when the method is called. When the method returns {\sf C} is modified to ${\sf C}
= \langle \mathbf{D}({\sf C}), {\sf nrows}, {\sf ncols}, \mathbf{L'}({\sf C})
\rangle$ where $\mathbf{L'}({\sf C}) = \{(i,j,C_{ij}) : (i,j,C_{ij}) \in
\mathbf{L}({\sf C}) \wedge (i < {\sf nrows}) \wedge (j < {\sf ncols})\}$. That is, all elements
of ${\sf C}$ with row index greater than or equal to 
${\sf nrows}$ or column index greater than or equal to ${\sf ncols}$ are dropped.

%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_clear}: Clear a matrix}

Removes all elements (tuples) from a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_clear(GrB_Matrix A);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf A}] ({\sf IN}) An exising GraphBLAS matrix to clear.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf A} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf *A}, has 
    not been initialized by a call to {\sf Matrix\_new} or {\sf Matrix\_dup}.
    
\end{itemize}

\paragraph{Description}

Removes all elements (tuples) from an existing matrix. After the call to
{\sf GrB\_Matrix\_clear(A)},
$\mathbf{L}(\matrix{A}) = \emptyset$. The dimensions of the matrix do not change.


%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_nrows}: Number of rows in a matrix}

Retrieve the number of rows in a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_nrows(GrB_Index        *nrows,
                                  const GrB_Matrix  A);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf nrows}] ({\sf OUT}) On successful return, contains the number of rows in the matrix.
    \item[{\sf A}] ({\sf IN}) An existing GraphBLAS matrix being queried.
\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]   In blocking or non-blocking mode, the operation 
    completed successfully and the value of {\sf nrows} has been set.

    \item[{\sf GrB\_PANIC}]     Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to {\sf Matrix\_new} or {\sf Matrix\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf nrows} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Return $\mathbf{nrows}({\sf A})$ in {\sf nrows} (the number of rows).

%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_ncols}: Number of columns in a matrix}

Retrieve the number of columns in a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_ncols(GrB_Index        *ncols,
                                  const GrB_Matrix  A);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf ncols}] ({\sf OUT}) On successful return, contains the number of columns in the matrix.
    \item[{\sf A}] ({\sf IN}) An existing GraphBLAS matrix being queried.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]   In blocking or non-blocking mode, the operation 
    completed successfully and the value of {\sf ncols} has been set.

    \item[{\sf GrB\_PANIC}]     Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to {\sf Matrix\_new} or {\sf Matrix\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf ncols} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Return $\mathbf{ncols}({\sf A})$ in {\sf ncols} (the number of columns).

%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_nvals}: Number of stored elements in a matrix}
\label{Sec:Matrix_nvals}

Retrieve the number of stored elements (tuples) in a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_nvals(GrB_Index        *nvals,
                                  const GrB_Matrix  A);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf nvals}] ({\sf OUT}) On successful return, contains the number of 
    stored elements (tuples) in the matrix.
    \item[{\sf A}] ({\sf IN}) An existing GraphBLAS matrix being queried.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully and the value of {\sf nvals} has been set. 

    \item[{\sf GrB\_PANIC}]    Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to {\sf Matrix\_new} or {\sf Matrix\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf nvals} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Return $\mathbf{nvals}({\sf A})$ in {\sf nvals}.  This is the number of tuples 
stored in matrix {\sf A}, which is the size of $\mathbf{L}(\matrix{A})$
(see Section~\ref{Sec:Matrices}).

%-----------------------------------------------------------------------------

\subsubsection{{\sf Import\_Matrix}: Import a matrix into a GraphBLAS object}
\label{Sec:Import_Matrix}

\paragraph{\syntax}

\begin{Verbatim}[samepage=true]    
        GrB_Info GrB_Import_Matrix(GrB_Matrix             A,
                                   GrB_Type               d,
                                   GrB_Index              nrows,
                                   GrB_Index              ncols
                                   const <type>          *values,
                                   const GrB_Index       *indptr,
                                   const GrB_Index       *indices,
                                   const GrB_Index        n_values,
                                   const GrB_Index        n_indptr,
                                   const GrB_Index        n_indices,
                                   const GrB_Format       format);
\end{Verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf A}]      ({\sf INOUT}) On a successful return, contains a handle to the newly created GraphBLAS matrix.
    \item[{\sf d}] ({\sf IN})    The type corresponding to the domain of the matrix 
                                 being created. Can be one of the predefined
                                 GraphBLAS types in Table~\ref{Tab:PredefinedTypes}, 
                                 or an existing user-defined GraphBLAS type.
    \item[{\sf nrows}] ({\sf IN}) Integer value holding the number of rows in the matrix specified by \arg{values}, \arg{indptr}, and \arg{indices}.
    \item[{\sf ncols}] ({\sf IN}) Integer value holding the number of columns in the matrix specified by \arg{values}, \arg{indptr}, and \arg{indices}.
    \item[{\sf values}] ({\sf IN}) Pointer to an array of values.  Type must match the type of \arg{d}.
    \item[{\sf indptr}] ({\sf IN}) Pointer to an array of row or column offsets, depending on the value of \arg{format}.  Type must match the type of \arg{d}.
    \item[{\sf indices}] ({\sf IN}) Pointer to an array of indices indicating the row or column indices of the elements in \arg{values}, depending on the value of \arg{format}.  Type must match the type of \arg{d}
    \item[{\sf n\_values}] ({\sf IN}) Integer value holding the number of elements in the array pointed to by \arg{values}.
    \item[{\sf n\_indptr}] ({\sf IN}) Integer value holding the number of elements in the array pointed to by \arg{indptr}.
    \item[{\sf n\_indices}] ({\sf IN}) Integer value holding the number of elements in the array pointed to by \arg{indices}.
    \item[{\sf format}] ({\sf IN}) a value indicating the format of the matrix being imported.
\end{itemize}
                        %\scott{Is {\sf GrB\_NULL} allowed?} \aydin{No, it doesn't make sense}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf A} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  Either {\sf A} has not been 
    initialized by a call to {\sf by GrB\_Matrix\_new} or 
    {\sf by GrB\_Matrix\_dup}, or
    {\sf dup} has not been initialized by a call to {\sf by GrB\_BinaryOp\_new}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf row\_indices}, 
    {\sf col\_indices} or {\sf values} pointer is {\sf NULL}.

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}] A value in {\sf row\_indices} or
    {\sf col\_indices} is outside the allowed range for {\sf C}.

	\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Either the domains of the GraphBLAS 
    binary operator {\sf dup} are not all the same, or the domains of 
    {\sf values} and {\sf C} are incompatible with each other or $D_{dup}$.
	
	\item[{\sf GrB\_OUTPUT\_NOT\_EMPTY}]    Output matrix {\sf C} already contains valid tuples (elements).
	In other words, {\sf GrB\_Matrix\_nvals(C)} returns a positive value.
\end{itemize}

\paragraph{Description}

Creates a new matrix $\matrix{A}$ of domain $\mathbf{D}({\sf d})$ and dimension
{\sf nrows $\times$ ncols}. The new GraphBLAS matrix will be filled with the
contents of the matrix pointed to by \arg{values}, \arg{indptr}, and \arg{indices}.
The method returns a handle to the new matrix in {\sf A}.  The structure of
the matrix being imported is defined by \arg{format}, which must be equal to
one of \arg{GRB\_CSR\_FORMAT}, \arg{GRB\_CSC\_FORMAT}, \arg{GRB\_COO\_FORMAT}, or \arg{GRB\_DENSE\_FORMAT}.

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created object will be overwritten. 

%-----------------------------------------------------------------------------

\subsubsection{{\sf Export\_Matrix}: Export a GraphBLAS matrix to a pre-defined format}
\label{Sec:Export_Matrix}

\paragraph{\syntax}

\begin{Verbatim}[samepage=true]    
        GrB_Info GrB_Export_Matrix(<type>                *values,
                                   GrB_Index             *indptr,
                                   GrB_Index             *indices,
                                   GrB_Format             format,
                                   GrB_Matrix             A);
\end{Verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf values}] ({\sf IN}) Pointer to an array of values.  Type must match the type of \arg{d}.  Must be at least as large as the corresponding value returned from \arg{GrB\_Export\_Matrix\_Size} times \arg{sizeof(<type>)}.
    \item[{\sf indptr}] ({\sf IN}) Pointer to an array of row or column offsets, depending on the value of \arg{format}.  Type must match the type of \arg{d}.  Must be at least as large as the corresponding value returned from \arg{GrB\_Export\_Matrix\_Size} times \arg{sizeof(GrB\_Index)}.
    \item[{\sf indices}] ({\sf IN}) Pointer to an array of indices indicating the row or column indices of the elements in \arg{values}, depending on the value of \arg{format}.  Type must match the type of \arg{d}.  Must be at least as large as the corresponding value returned from \arg{GrB\_Export\_Matrix\_Size} times \arg{sizeof(GrB\_Index)}.
    \item[{\sf format}] ({\sf IN}) a value indicating the format in which the matrix will be exported.
    \item[{\sf A}]      ({\sf IN}) A GraphBLAS matrix object.
\end{itemize}
                        %\scott{Is {\sf GrB\_NULL} allowed?} \aydin{No, it doesn't make sense}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf C} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  Either {\sf C} has not been 
    initialized by a call to {\sf by GrB\_Matrix\_new} or 
    {\sf by GrB\_Matrix\_dup}, or
    {\sf dup} has not been initialized by a call to {\sf by GrB\_BinaryOp\_new}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf row\_indices}, 
    {\sf col\_indices} or {\sf values} pointer is {\sf NULL}.

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}] A value in {\sf row\_indices} or
    {\sf col\_indices} is outside the allowed range for {\sf C}.

	\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Either the domains of the GraphBLAS 
    binary operator {\sf dup} are not all the same, or the domains of 
    {\sf values} and {\sf C} are incompatible with each other or $D_{dup}$.
	
	\item[{\sf GrB\_OUTPUT\_NOT\_EMPTY}]    Output matrix {\sf C} already contains valid tuples (elements).
	In other words, {\sf GrB\_Matrix\_nvals(C)} returns a positive value.
\end{itemize}

\paragraph{Description}

Given a matrix $\matrix{A}$, exports the matrix using a pre-defined
\arg{GrB\_Format} format, which must be equal to one of \arg{GRB\_CSR\_FORMAT},
\arg{GRB\_CSC\_FORMAT}, \arg{GRB\_COO\_FORMAT}, or \arg{GRB\_DENSE\_FORMAT}.
The user-allocated arrays
pointed to by \arg{values}, \arg{indptr}, and \arg{indices} must be at least
large enough to hold the corresponding number of values returned by calling
\arg{GrB\_Export\_Matrix\_Size}.  The value of \arg{format} can be chosen arbitrarily.

%-----------------------------------------------------------------------------

\subsubsection{{\sf Export\_Matrix\_Size}: Return the array sizes necessary to export a GraphBLAS matrix object}
\label{Sec:Export_Matrix_Size}

\paragraph{\syntax}

\begin{Verbatim}[samepage=true]    
        GrB_Info GrB_Export_Matrix_Size(GrB_Index             *n_values,
                                        GrB_Index             *n_indptr,
                                        GrB_Index             *n_indices,
                                        GrB_Format             format,
                                        GrB_Matrix             A);
\end{Verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf values}] ({\sf INOUT}) Pointer to a value of type \arg{GrB\_Index}.
    \item[{\sf indptr}] ({\sf INOUT}) Pointer to a value of type \arg{GrB\_Index}.
    \item[{\sf indices}] ({\sf INOUT}) Pointer to a value of type \arg{GrB\_Index}.
    \item[{\sf format}] ({\sf IN}) a value indicating the format in which the matrix will be exported.
    \item[{\sf A}]      ({\sf IN}) A GraphBLAS matrix object.
\end{itemize}
                        %\scott{Is {\sf GrB\_NULL} allowed?} \aydin{No, it doesn't make sense}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf C} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  Either {\sf C} has not been 
    initialized by a call to {\sf by GrB\_Matrix\_new} or 
    {\sf by GrB\_Matrix\_dup}, or
    {\sf dup} has not been initialized by a call to {\sf by GrB\_BinaryOp\_new}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf row\_indices}, 
    {\sf col\_indices} or {\sf values} pointer is {\sf NULL}.

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}] A value in {\sf row\_indices} or
    {\sf col\_indices} is outside the allowed range for {\sf C}.

	\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Either the domains of the GraphBLAS 
    binary operator {\sf dup} are not all the same, or the domains of 
    {\sf values} and {\sf C} are incompatible with each other or $D_{dup}$.
	
	\item[{\sf GrB\_OUTPUT\_NOT\_EMPTY}]    Output matrix {\sf C} already contains valid tuples (elements).
	In other words, {\sf GrB\_Matrix\_nvals(C)} returns a positive value.
\end{itemize}

\paragraph{Description}

Given a matrix $\matrix{A}$, returns the required capacities of arrays \arg{values},
\arg{indptr}, and \arg{indices} necessary to export the matrix in format \arg{format}.
The output values \arg{n\_values}, \arg{n\_indptr}, and \arg{indices} will
contain the corresponding sizes of the arrays that must be allocated to hold
the exported matrix.  The argument \arg{format} can be chosen arbitrarily by the
user and may be equal to \arg{GRB\_CSR\_FORMAT}, \arg{GRB\_CSC\_FORMAT}, \arg{GRB\_COO\_FORMAT}, or
\arg{GRB\_DENSE\_FORMAT}.

%-----------------------------------------------------------------------------

%-----------------------------------------------------------------------------

\subsubsection{{\sf Export\_Matrix\_Hint}: Provides a hint as to which storage format might be most efficient for exporting a matrix}
\label{Sec:Export_Matrix_Hint}

\paragraph{\syntax}

\begin{Verbatim}[samepage=true]    
        GrB_Info GrB_Export_Matrix_Hint(GrB_Format            *hint,
                                        GrB_Matrix             A);
\end{Verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf hint}] ({\sf INOUT}) Pointer to a value of type \arg{GrB\_Format}.
    \item[{\sf A}]      ({\sf IN}) A GraphBLAS matrix object.
\end{itemize}
                        %\scott{Is {\sf GrB\_NULL} allowed?} \aydin{No, it doesn't make sense}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf C} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  Either {\sf C} has not been 
    initialized by a call to {\sf by GrB\_Matrix\_new} or 
    {\sf by GrB\_Matrix\_dup}, or
    {\sf dup} has not been initialized by a call to {\sf by GrB\_BinaryOp\_new}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf row\_indices}, 
    {\sf col\_indices} or {\sf values} pointer is {\sf NULL}.

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}] A value in {\sf row\_indices} or
    {\sf col\_indices} is outside the allowed range for {\sf C}.

	\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Either the domains of the GraphBLAS 
    binary operator {\sf dup} are not all the same, or the domains of 
    {\sf values} and {\sf C} are incompatible with each other or $D_{dup}$.
	
	\item[{\sf GrB\_OUTPUT\_NOT\_EMPTY}]    Output matrix {\sf C} already contains valid tuples (elements).
	In other words, {\sf GrB\_Matrix\_nvals(C)} returns a positive value.
\end{itemize}

\paragraph{Description}

Given a GraphBLAS matrix \arg{A}, provides a hint as to which format might be most
efficient for exporting the matrix \arg{A}.  GraphBLAS implementations might
return the current storage format of the matrix, or the format to which it could
most efficiently be exported.  However, implementations are free to return any
value for \arg{format}, including \arg{GRB\_CSR\_FORMAT},
\arg{GRB\_CSC\_FORMAT}, \arg{GRB\_COO\_FORMAT}, \arg{GRB\_DENSE\_FORMAT}, and
\arg{GRB\_ANY\_FORMAT}.

%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_build}: Store elements from tuples into a matrix \scott{NEW CONTENT}}
\label{Sec:Matrix_build}

\paragraph{\syntax}

% AYDIN: Avoid page break due to preceding table
\begin{Verbatim}[samepage=true]    
        GrB_Info GrB_Matrix_build(GrB_Matrix             C,
                                  const GrB_Index       *row_indices,
                                  const GrB_Index       *col_indices, 
                                  const <type>          *values,
                                  GrB_Index              n,
                                  const GrB_BinaryOp     dup);
\end{Verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]      ({\sf INOUT}) An existing Matrix object to store the result.
    \item[{\sf row\_indices}] ({\sf IN}) Pointer to an array of row indices. 
    \item[{\sf col\_indices}] ({\sf IN}) Pointer to an array of column indices. 
    \item[{\sf values}] ({\sf IN}) Pointer to an array of scalars of a type that
                                   is compatible with the domain of matrix, {\sf C}.
    \item[{\sf n}]  ({\sf IN}) The number of entries contained in each array (the same for \arg{row\_indices}, \arg{col\_indices}, and \arg{values}).
    \item[{\sf dup}]    ({\sf IN}) An associative and commutative binary operator 
    to apply when duplicate values for the same location are present in the input
    arrays. All three domains of {\sf dup} must be the same; hence
	    $dup=\langle D_{dup},D_{dup},D_{dup},\oplus \rangle$.
    If {\sf dup} is {\sf GrB\_NULL}, then duplicate locations will result in an error. \scott{NEW CONTENT}
\end{itemize}    

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.3in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the API checks 
    for the input arguments passed successfully. Either way, output matrix 
    {\sf C} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  Either {\sf C} has not been 
    initialized by a call to {\sf by GrB\_Matrix\_new} or 
    {\sf by GrB\_Matrix\_dup}, or
    {\sf dup} has not been initialized by a call to {\sf by GrB\_BinaryOp\_new}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf row\_indices}, 
    {\sf col\_indices} or {\sf values} pointer is {\sf NULL}.

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}] A value in {\sf row\_indices} or
    {\sf col\_indices} is outside the allowed range for {\sf C}.

	\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Either the domains of the GraphBLAS 
    binary operator {\sf dup} are not all the same, or the domains of 
    {\sf values} and {\sf C} are incompatible with each other or $D_{dup}$.
	
	\item[{\sf GrB\_OUTPUT\_NOT\_EMPTY}]    Output matrix {\sf C} already contains valid tuples (elements).
	In other words, {\sf GrB\_Matrix\_nvals(C)} returns a positive value.
    
    \item[{\sf GrB\_INVALID\_VALUE}] {\sf indices} contains a duplicate location
    and {\sf dup} is {\sf GrB\_NULL}. \scott{NEW CONTENT}
\end{itemize}

\paragraph{Description \scott{NEW CONTENT}}

If {\sf dup} is not {\sf GrB\_NULL}, an internal matrix 
$\matrix{\widetilde{C}} = \langle D_{dup}, \mathbf{nrows}({\sf C}),
\mathbf{ncols}({\sf C}),\emptyset \rangle$ is created, which only differs from ${\sf C}$ 
in its domain; otherwise,
$\matrix{\widetilde{C}} = \langle \mathbf{D}({\sf C}), \mathbf{nrows}({\sf C}),
\mathbf{ncols}({\sf C}),\emptyset \rangle$. 

Each tuple $\{ {\sf row\_indices[k]}, {\sf col\_indices[k]}, {\sf values[k]}\}$, where $0\leq k < {\sf n}$, is a contribution to the output in the form of 
\[
\matrix{\widetilde{C}}({\sf row\_indices[k]}, {\sf col\_indices[k]}) = 
\begin{cases} 
(D_{dup})\, {\sf values[k]} & \text{ if {\sf dup} $\neq$ {\sf GrB\_NULL}} \\
(\mathbf{D}({\sf C}))\, {\sf values[k]} & \text{ otherwise.} 
\end{cases}
\]

If multiple values for the same location are present in the input arrays and 
{\sf dup} is not {\sf GrB\_NULL}, {\sf dup} is used to reduce the values before 
assignment into $\matrix{\widetilde{C}}$ as follows:
\[
\matrix{\widetilde{C}}_{ij}
= \bigoplus_{k:\, {\sf row\_indices[k]} = i\, \land\, {\sf col\_indices[k]} = j}   (D_{dup})\,{\sf values[k]}
,\] 
where $\oplus$ is the {\sf dup} binary operator. Finally, the resulting 
$\matrix{\widetilde{C}}$ is copied into ${\sf C}$ via typecasting its values to 
$\mathbf{D}({\sf C})$ if necessary.  If $\oplus$ is not associative or not 
commutative, the result is undefined.  

The nonopaque input arrays {\sf row\_indices}, {\sf col\_indices}, and {\sf values} must be at least as large as {\sf n}. 

It is an error to call this function on an output object with existing elements. In other words, 
{\sf GrB\_Matrix\_nvals(C)} should evaluate to zero prior to calling this function.

After {\sf GrB\_Matrix\_build} returns, it is safe for a programmer to 
modify or delete the arrays {\sf row\_indices}, {\sf col\_indices}, or {\sf values}.

%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_setElement}: Set a single element in matrix}

Set one element of a matrix to a given value.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_setElement(GrB_Matrix   C,
                                       <type>       val,
                                       GrB_Index    row_index,
                                       GrB_Index    col_index); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]   ({\sf INOUT}) An existing GraphBLAS matrix for which an 
    element is to be assigned.

    \item[{\sf val}]   ({\sf IN})  Scalar value to assign.  The type must
    be compatible with the domain of {\sf C}.
    
    \item[{\sf row\_index}] ({\sf IN}) Row index of element to be assigned
    \item[{\sf col\_index}] ({\sf IN}) Column index of element to be assigned
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on index/dimensions and domains for the input arguments passed successfully. 
    Either way, the output matrix {\sf C} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf C}, has 
    not been initialized by a call to {\sf Matrix\_new} or {\sf Matrix\_dup}.

    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf row\_index} or {\sf col\_index} is 
    outside the allowable range (i.e., not less than $\mathbf{nrows}({\sf C})$ or
    $\mathbf{ncols}({\sf C})$, respectively).

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of {\sf C} and {\sf val}
    are incompatible.
\end{itemize}

\paragraph{Description}

First, the scalar and output matrix are tested for domain compatibility as follows:  
$\mathbf{D}({\sf val})$ must be compatible with $\mathbf{D}({\sf C})$. Two domains 
are compatible with each other if values from one domain can be cast to values 
in the other domain as per the rules of the C language.  In particular, domains 
from Table~\ref{Tab:PredefinedTypes} are all compatible with each other. A domain 
from a user-defined type is only compatible with itself.  If any compatibility 
rule above is violated, execution of {\sf GrB\_Matrix\_extractElement} ends and
the domain mismatch error listed above is returned.

Then, both index parameters are checked for valid values where following
conditions must hold:
\[
\begin{aligned}
    0\ \leq\ {\sf row\_index} & \ <\ \mathbf{nrows}({\sf C}), \\
    0\ \leq\ {\sf col\_index} & \ <\ \mathbf{ncols}({\sf C})
\end{aligned}
\]
If either of these conditions is violated, execution of 
{\sf GrB\_Matrix\_extractElement} ends and the invalid 
index error listed above is returned. 

We are now ready to carry out the assignment of {\sf val}; that is,
\[
{\sf C}({\sf row\_index},{\sf col\_index}) = {\sf val} 
\]
If a value existed at this location in {\sf C}, it will be overwritten; otherwise,
and new value is stored in {\sf C}.

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of {\sf C} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf C} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.


%-----------------------------------------------------------------------------
\subsubsection{{\sf Matrix\_removeElement}: Remove an element from a matrix}

Remove (annihilate) one stored element from a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_removeElement(GrB_Matrix   C,
                                          GrB_Index    row_index,
                                          GrB_Index    col_index); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]   ({\sf INOUT}) An existing GraphBLAS matrix from which an 
    element is to be removed.

    \item[{\sf row\_index}] ({\sf IN}) Row index of element to be removed
    \item[{\sf col\_index}] ({\sf IN}) Column index of element to be removed
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the compatibility 
    tests on index/dimensions and domains for the input arguments passed successfully. 
    Either way, the output matrix {\sf C} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf C}, has 
    not been initialized by a call to {\sf Matrix\_new} or {\sf Matrix\_dup}.

    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf row\_index} or {\sf col\_index} is 
    outside the allowable range (i.e., not less than $\mathbf{nrows}({\sf C})$ or
    $\mathbf{ncols}({\sf C})$, respectively).
\end{itemize}

\paragraph{Description}

First, both index parameters are checked for valid values where following
conditions must hold:
\[
\begin{aligned}
    0\ \leq\ {\sf row\_index} & \ <\ \mathbf{nrows}({\sf C}), \\
    0\ \leq\ {\sf col\_index} & \ <\ \mathbf{ncols}({\sf C})
\end{aligned}
\]
If either of these conditions is violated, execution of 
{\sf GrB\_Matrix\_removeElement} ends and the invalid 
index error listed above is returned. 

We are now ready to carry out the removal of a value that may be stored at the
location specified by ({\sf row\_index}, {\sf col\_index}).  If a value does not
exist at the specified location in {\sf C}, no error is reported and the 
operation has no effect on the state of {\sf C}.  In either case, the following 
will be true on return from this method: 
({\sf row\_index}, {\sf col\_index}) $\notin~\mathbf{ind}({\sf C})$

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of {\sf C} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf C} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.


%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_extractElement}: Extract a single element from a matrix}
\label{Sec:Matrix_extractElement}

%\scott{Is OUTOFMEMORY error possible (perhaps only in non-blocking)? }
%\scott{still need to deal with notation for type of first parameter.}

Extract one element of a matrix into a scalar. 

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_extractElement(<type>           *val,
                                           const GrB_Matrix  A,
                                           GrB_Index         row_index,
                                           GrB_Index         col_index); 

\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf val}]   ({\sf OUT}) Pointer to a scalar of type that is 
    compatible with the domain of matrix {\sf A}. On successful return, this scalar 
    holds the result of the operation.  Any previous value in {\sf val} is 
    overwritten.

    \item[{\sf A}]     ({\sf IN}) The GraphBLAS matrix from which an element is
    extracted.
    
    \item[{\sf row\_index}] ({\sf IN}) The row index of location in {\sf A} 
    to extract.

    \item[{\sf col\_index}] ({\sf IN}) The column index of location in {\sf A} 
    to extract.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully. This indicates that the compatibility tests on 
    dimensions and domains for the input arguments passed successfully, and
    the output scalar, {\sf val}, has been computed and is ready to be used in 
    the next method of the sequence.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to {\sf Matrix\_new} or {\sf Matrix\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}]    {\sf val} pointer is {\sf NULL}.

    \item[{\sf GrB\_NO\_VALUE}]  There is no stored value at specified location.
    
    \item[{\sf GrB\_INVALID\_INDEX}]  {\sf row\_index} or {\sf col\_index} is 
    outside the allowable range (i.e. less than zero or greater than or equal to  $\mathbf{nrows}({\sf A})$ or
    $\mathbf{ncols}({\sf A})$, respectively).

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of the matrix and scalar
    are incompatible.
\end{itemize}

\paragraph{Description}

First, the scalar and input matrix are tested for domain compatibility as follows:  
$\mathbf{D}({\sf val})$ must be compatible with $\mathbf{D}({\sf A})$. Two domains 
are compatible with each other if values from one domain can be cast to values 
in the other domain as per the rules of the C language.  In particular, domains 
from Table~\ref{Tab:PredefinedTypes} are all compatible with each other. A domain 
from a user-defined type is only compatible with itself.  If any compatibility 
rule above is violated, execution of {\sf GrB\_Matrix\_extractElement} ends and
the domain mismatch error listed above is returned.

Then, both index parameters are checked for valid values where following
conditions must hold:
\[
\begin{aligned}
    0\ \leq\ {\sf row\_index} & \ <\ \mathbf{nrows}({\sf A}), \\
    0\ \leq\ {\sf col\_index} & \ <\ \mathbf{ncols}({\sf A})
\end{aligned}
\]
If either of these conditions is violated, execution of 
{\sf GrB\_Matrix\_extractElement} ends and the invalid 
index error listed above is returned. 

We are now ready to carry out the extract into the output argument, {\sf val}; 
that is,
\[
{\sf val} = {\sf A}({\sf row\_index},{\sf col\_index})
\]
where the following condition must be true:
\[
    ({\sf row\_index},{\sf col\_index}) \ \in \ \mathbf{ind}({\sf A})
\]
If this condition is violated, execution of {\sf GrB\_Matrix\_extractElement} 
ends and the "no value" error listed above is returned.


In both {\sf GrB\_BLOCKING} mode {\sf GrB\_NONBLOCKING} mode
if the method exits with return value {\sf GrB\_SUCCESS}, the  new 
contents of  {\sf val} are as defined above.  

\comment{In other words, the method
does not return until any operations required to fully compute 
the GraphBLAS matrix {\sf A} have completed. 

In {\sf GrB\_NONBLOCKING} mode, if the return value is 
other than  {\sf GrB\_SUCCESS}, an error in a method occurring earlier in the sequence
may have occurred that prevents completion of the GraphBLAS matrix {\sf A}.
The {\sf GrB\_error()} method should be called for additional information 
about such errors.
}

%-----------------------------------------------------------------------------

\subsubsection{{\sf Matrix\_extractTuples}: Extract tuples from a matrix}
\label{Sec:Matrix_extractTuples}

Extract the contents of a GraphBLAS matrix into non-opaque data structures.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Matrix_extractTuples(GrB_Index            *row_indices,
                                          GrB_Index            *col_indices,
                                          <type>               *values, 
                                          GrB_Index            *n, 
                                          const GrB_Matrix      A);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf row\_indices}] ({\sf OUT}) Pointer to an array of row indices
                        that is large enough to hold all of the row indices.
    \item[{\sf col\_indices}] ({\sf OUT}) Pointer to an array of column indices
                        that is large enough to hold all of the column indices. 
    \item[{\sf values}] ({\sf OUT}) Pointer to an array of scalars of a type
                        that is large enough to hold all of the stored values whose
                        type is compatible with $\mathbf{D}(\matrix{A})$.
    \item[{\sf n}] ({\sf INOUT}) Pointer to a value indicating (in input) the number of
                        elements the {\sf values}, {\sf row\_indices}, and
                        {\sf col\_indices} arrays can hold. Upon return, it will contain the
                        number of values written to the arrays.
    \item[{\sf A}]      ({\sf IN}) An existing GraphBLAS matrix.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]  In blocking or non-blocking mode, the operation 
    completed successfully. This indicates that the compatibility tests on 
    the input argument passed successfully, and the output arrays, {\sf indices}
    and {\sf values}, have been computed.

    \item[{\sf GrB\_PANIC}]   Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
	 %   \scott{Is this error possible?} \jose{out-of-memory is always possible -- we don't restrict implementation}

    \item[{\sf GrB\_INSUFFICIENT\_SPACE}]  Not enough space in {\sf row\_indices}, 
    {\sf col\_indices}, and {\sf values} (as indicated by the {\sf n} parameter) 
    to hold all of the tuples that will be extacted.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}]  The GraphBLAS matrix, {\sf A}, has 
    not been initialized by a call to {\sf Matrix\_new} or {\sf Matrix\_dup}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf row\_indices}, {\sf col\_indices}, 
    {\sf values} or {\sf n} pointer is {\sf NULL}.
    
    \item[\sf GrB\_DOMAIN\_MISMATCH] The domains of the {\sf A} matrix and 
    {\sf values} array are incompatible with one another.
\end{itemize}

\paragraph{Description}


This method will extract all the tuples from the GraphBLAS matrix {\sf A}.  
The values associated with those tuples are placed in the
{\sf values} array, the column indices are placed in the {\sf col\_indices} array, 
and the row indices are placed in the {\sf row\_indices} array. 
These output arrays are pre-allocated by the user before calling
this function such that each output array has enough
space to hold at least {\sf GrB\_Matrix\_nvals(A)} elements. 

Upon return of this function, a pair of $\{{\sf row\_indices[k], col\_indices[k]}\}$ are unique for every valid $k$, 
but they are not required to be sorted in any particular order.
Each tuple $(i,j,A_{ij})$ in {\sf A} is unzipped and copied into a distinct $k$th location in output vectors:  

$$\{{\sf row\_indices[k]}, {\sf col\_indices[k]}, {\sf values[k]}\} \leftarrow (i,j,A_{ij}),$$

where $0 \leq k < {\sf GrB\_Matrix\_nvals(v)}$. 
No gaps in output vectors are allowed; that is, if {\sf row\_indices[k]},  {\sf col\_indices[k]}  and {\sf values[k]} exist upon return, 
so does {\sf row\_indices[j]}, {\sf col\_indices[j]} and {\sf values[j]} for all $j$ such that $0 \leq j < k$.

Note that if the value in {\sf n} on input is less than the number of values
contained in the matrix {\sf A}, then a {\sf GrB\_INSUFFICIENT\_SPACE} error 
is returned since it is undefined which subset of values would
be extracted.

In both {\sf GrB\_BLOCKING} mode {\sf GrB\_NONBLOCKING} mode
if the method exits with return value {\sf GrB\_SUCCESS}, the  new 
contents of the arrays {\sf row\_indices}, {\sf col\_indices} and {\sf values} are as defined above.  

\comment{In other words, the method
does not return until any operations required to fully compute 
the GraphBLAS vector {\sf A} have completed. 

In {\sf GrB\_NONBLOCKING} mode, if the return value is 
not {\sf GrB\_SUCCESS}, an error in a method occurring earlier in the sequence
may have occurred that prevents completion of the GraphBLAS vector {\sf A}.
The {\sf GrB\_error()} method should be called for additional information 
about these errors.
}

