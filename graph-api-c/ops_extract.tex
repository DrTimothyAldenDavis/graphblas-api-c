\subsection{{\sf extract}: Selecting Sub-Graphs}
\label{Sec:extract}

Extract a sub-matrix (vector) from a larger matrix (vector). 

If an accumulation function is specified, then that function is
used to combine current elements in the destination with those elements
extracted from the source. If no accumulation function is specified, then
the destination is overwritten with the extracted elements.  \scott{this 
statement should be moved into individual Description sections.}

%--------------------------------------------------------------

\subsubsection{{\sf extract}: Standard vector variant}

Extract a sub-vector from a larger vector. 

In the standard version of {\sf extract}, one index array
specifies which locations in the source vector that are copied to
the destination.  The size of the destination vector is the same size as
the one index array provided.  

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_extract(GrB_Vector             *w,
                             const GrB_Vector        mask,
                             const GrB_BinaryOp      accum,
                             const GrB_Vector        u,
                             const GrB_Index        *indices,
                             const GrB_Index         nindices,
                             const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    extract operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}]  ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector
    ${\sf w}$.  If no mask is desired (\ie, all elements
    of result are copied into the output vector), {\sf GrB\_NULL}
    should be specified. The mask dimensions must match those of the
    vector {\sf w} and the domain of {\sf mask} must be
    of type {\sf bool} or any of the predefined ``built-in'' types in
    Table~\ref{Tab:PredefinedTypes}.


    \item[{\sf accum}]    ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf w} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf u}]       ({\sf IN}) The GraphBLAS vector from which the subset
    is extracted.
    
    \item[{\sf indices}]  ({\sf IN}) The ordered set of indices corresponding to the 
    location of elements from {\sf u} that are extracted.  If all elements of
    {\sf u} are to be extracted in order, {\sf GrB\_ALL} should be specified.
    
    \item[{\sf nindices}] ({\sf IN}) The number of values in {\sf indices} array.
    Must be equal to $\bold{size}({\sf w})$.

    \item[{\sf desc}]     ({\sf IN}) An optional operation descriptor.  If a 
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be used.  Valid 
    fields are as follows: \\
    
    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it. \\
        
        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural 
        complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, operation
	completed successfully. In non-blocking mode, this indicates
	that the consistency tests on dimensions and domains for the
	input arguments passed successfully. Either way, output vector
	{\sf w} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_OUTOFMEM}]        Not enough memory available for operation.
    
    \item[{\sf GrB\_NOOBJECT}]        One or more of the GraphBLAS objects has
    not been initialized by a call to {\sf new}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf w} or {\sf indices} pointer is {\sf NULL}.

    \item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  A value in {\sf indices} references a 
    non-existent element in {\sf u}.
    
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] Mask, vector, or array dimensions are
    incompatible, or ${\sf nindices} \neq \bold{size}({\sf w})$. 
    
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various
	vectors are incompatible with the corresponding domains of the
	accumulating operation or mask.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_extract} computes the result of extracting a subset of
locations from a GraphBLAS vector in a specific order: 
${\sf w} = {\sf u}({\sf indices})$; or, if an optional binary accumulation 
operator ($\odot$) is provided, ${\sf w} = {\sf w} \odot {\sf u}({\sf indices})$.  
More explicitly:
\[
    {\sf w}(i) = {\sf u}({\sf indices}(i)) \mbox{~~or~~} 
    {\sf w}(i) = {\sf w}(i) + {\sf u}({\sf indices}(i))
    \mbox{~~for~~} i \in \left[0..{\sf nindices}\right)
\]  
Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for consistency.
\item[Compute] The indicated computations are carried out.
\item[Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to three argument vectors are used in the {\sf GrB\_extract} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),\bold{L}({\sf w}) = \{(i,w_i) \} \rangle$
	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),\bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)
	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),\bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

The argument vectors and the accumulator 
operator (if provided) are tested for domain consistency as follows:
\begin{enumerate}
	\item The domain of {\sf mask} (if not {\sf GrB\_NULL}) must be from one of the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be 
    compatible with $\bold{D}({\sf u})$.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $D_x$ and $D_z$ of the accumulator operator and 
    $\bold{D}({\sf u})$ must be compatible with $D_y$ of the accumulator operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any consistency rule above is violated, execution of {\sf GrB\_eWiseMult} ends
and the domain mismatch error listed above is returned.

From the argument vectors, the internal vectors and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item	If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \forall i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item	Otherwise, $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf mask}), \{i : ({\sf bool}){\sf mask}(i) = 
        \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is \true, then $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
    
    \item The index array, $\array{\widetilde{I}}$, is computed from 
    argument {\sf indices} as follows:
	\begin{enumerate}
		\item	If ${\sf indices} = {\sf GrB\_ALL}$, then $\array{\widetilde{I}} = 
        \langle {\sf nindices}, \{(i, i), \forall i : 0 \leq i < 
        {\sf nindices} \} \rangle$.

		\item	Otherwise, $\array{\widetilde{I}} = 
        \langle {\sf nindices}, \{(i, {\sf indices}(i)), \forall i : 0 \leq i < 
        {\sf nindices} \} \rangle$.
    \end{enumerate}
\end{enumerate}

The internal vectors and masks are checked for shape consistency. The following 
conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$
    \item ${\sf nindices} = \bold{size}(\vector{\widetilde{w}})$.
\end{enumerate}
If any consistency rule above is violated, execution of {\sf GrB\_extract} ends and 
the dimension mismatch error listed above is returned.

The values in the index array are checked for valid range.  The following
conditions must hold:
\begin{enumerate}
	\item $0 \leq {\sf indices}(i) < \bold{size}(\vector{\widetilde{u}})
    ~ \forall ~ i ~ : ~ 0 \leq i < {\sf nindices}$.
\end{enumerate}
If any consistency rule above is violated, execution of {\sf GrB\_extract} ends and 
the index out-of-bounds error listed above is returned.

We are now ready to carry out the extract and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
	\item $\vector{\widetilde{t}}$: The vector holding the extraction from
    $\vector{\widetilde{u}}$.
	\item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulator.
\end{itemize}

The intermediate vector, $\vector{\widetilde{t}}$, is created as follows:
\[ \vector{\widetilde{t}} = \langle
\bold{D}({\sf u}), \bold{size}(\vector{\widetilde{w}}),
\bold{L}(\vector{\widetilde{t}}) =
\{(i,\vector{\widetilde{u}}(\array{\widetilde{I}}(i))) \forall i, 0 \leq i < {\sf nindices} : 
\vector{\widetilde{u}}(\array{\widetilde{I}}(i)) \neq \emptyset \} \rangle \]
\scott{I need help with the notation here.  This is NOT $\bold{L}(\vector{t}) =
(i, \vector{\widetilde{u}}(\array{\widetilde{I}}(i))) : i \in \bold{ind}(
\vector{\widetilde{u}}) \cap {\sf indices}$}.

The intermediate vector $\vector{\widetilde{z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\vector{\widetilde{z}} = \vector{\widetilde{t}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then vector $\vector{\widetilde{z}}$ is defined as 
        \[ \langle D_z, \bold{size}(\vector{\widetilde{w}}), \bold{L}(\vector{\widetilde{z}})
		= \{(i,z_{i})  \forall (i) \in \bold{ind}(\vector{\widetilde{w}}) \cup 
        \bold{ind}(\vector{\widetilde{t}}) \} \rangle.\]
    The values of the elements of $\vector{\widetilde{z}}$ are computed based on the relationships between the sets of indices in $\vector{\widetilde{w}}$ and $\vector{\widetilde{t}}$.
\[
z_{i} = \vector{\widetilde{w}}(i) \odot \vector{\widetilde{t}}(i), \forall i \in  (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}})),
\]
\[
z_{i} = \vector{\widetilde{w}}(i), \forall  i \in  (\bold{ind}(\vector{\widetilde{w}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}}))),
\]
\[
z_{i} = \vector{\widetilde{t}}(i), \forall  i \in  (\bold{ind}(\vector{\widetilde{t}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\vector{\widetilde{z}}$ 
vector are written into the final result vector, $\vector{w}$. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is \true, then any values in $\vector{w}$ 
on input to {\sf GrB\_eWiseMult()} are deleted and the new output vector $\vector{w}$ is,
\[ \bold{L}({\sf w}) = \{(i,z_{i}) : i \in (\bold{ind}(\vector{\widetilde{z}}) 
\cap \bold{ind}(\vector{\widetilde{m}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not given or is equal to any 
value other than \true, the elements of $\vector{\widetilde{z}}$ indicated by 
the mask are copied into the result vector, $\vector{w}$, and elements of 
$\vector{w}$ that fall outside the set indicated by the mask are unchanged:
\[ \bold{L}({\sf w}) = \{(i,w_{i}) : i \in (\bold{ind}(\vector{\sf w}) 
\cap \bold{ind}(\neg \vector{\widetilde{m}})) \} \cup \{(i,z_{i}) : i \in 
(\bold{ind}(\vector{\widetilde{z}}) \cap \bold{ind}(\vector{\widetilde{m}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.


%=======================================================================
\paragraph{OLD Description}

Vectors $\vector{u}$ and $\vector{m}$ are computed from input
parameters {\sf u} and {\sf mask}, respectively, as specified by
descriptor {\sf desc}.  If either $\vector{u}$ or $\vector{m}$
cannot be computed from the input parameters, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that all indices in array
{\sf indices} are valid. That is, they must fall within the range of allowed
indices for vector $\vector{u}$ ($0 \leq {\sf indices}[i] < \bold{n}(\vector{u})
\forall i = 0,\ldots,{\sf nindices}-1$).  Otherwise, the method returns {\sf
GrB\_INDEX\_OUTOFBOUNDS}.

A new vector $\vector{w} = \langle \bold{D}({\sf w}),{\sf n},
\bold{L}(\vector{w}) = \{ (i,w_i), i = 0,\ldots,{\sf nindices}-1 : {\sf indices}[i]
\in \bold{i}(\vector{u}) \wedge \vector{m}[i] = \true \} \rangle$
is created.  The value $w_i$ is set to $\vector{u}[{\sf indices}[i]]$. If
casting from $\bold{D}(\vector{u})$ to $\bold{D}(\vector{w})$ is not
allowed, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

Finally, output parameter {\sf w} is computed from vector $\vector{w}$ as
specified by descriptor {\sf desc} and accumulation function {\sf accum}.


%--------------------------------------------------------------

\subsubsection{{\sf extract}: Standard matrix variant}

For matrices, the destination matrix has
the same number of rows as the size of the row index array and the same
number of columns as the size of the column index array.

In the standard version of {\sf extract}, GraphBLAS index arrays
specify the elements in the source vector/matrix that are copied to
the destination. \scott{this statement goes with the next two subsections only.}


\paragraph{\syntax}

\begin{verbatim}                 
        GrB_Info GrB_extract(GrB_Matrix                *C,
                             const GrB_Matrix           Mask,
                             const GrB_BinaryFunction   accum,
                             const GrB_Matrix           A,
                             const GrB_Index           *rowIDs,
                             const GrB_Index            nrows,
                             const GrB_Index           *colIDs,
                             const GrB_Index            ncols,
                             GrB_Descriptor const       desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf C}]     ({\sf INOUT}) The matrix to store the extracted subgraph.

    \item[{\sf Mask}]  ({\sf IN}) Output mask. The mask
    specifies which elements of {\sf C} can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  ({\sf IN})  Operator used for accumulating entries into existing {\sf C} entries. 
			If no accumulation is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf A}]      ({\sf IN})  The matrix from which to extract the subgraph.
    \item[{\sf rowIDs}] ({\sf IN})     The set of row indices specifying rows from source that
                              are extracted. Can
                              be set to {\sf GrB\_ALL} if all rows are
                              to be extracted.
    \item[{\sf nrows}]  ({\sf IN}) The number of indices in array {\sf rowIDs}.
    \item[{\sf colIDs}] ({\sf IN}) The set of column indices specifying
                              columns from source that are extracted. Can
                              be set to {\sf GrB\_ALL} if all columns are
                              to be extracted.
    \item[{\sf ncols}]  ({\sf IN}) The number of indices in array {\sf colIDs}.

    \item[{\sf desc}]   ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C} is cleared (all elements removed) before result is stored in it. \\
    {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf Mask}. \\
    {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Apply transpose to {\sf A} before extract.) \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]    not enough memory available for operation.
\item[{\sf GrB\_NOOBJECT}]   one or more of the GraphBLAS objects has
                             not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf C}, {\sf rowIDs} or {\sf colIDs} pointer is {\sf NULL}.

\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]
        A value in {\sf rowIDs} references a non-existent row in {\sf A}, or
        the value in {\sf colIDs} references a non-existent column in {\sf A}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf rowIDs} (namely {\sf nrows}) is not equal to the number of rows in {\sf C}, or
        the size of {\sf colIDs} (namely {\sf ncols}) is not equal to the number of columns in {\sf C}, or
        the dimensions of the mask (if specified) do not match {\sf C}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between $\bold{D}({\sf A})$ and $\bold{D}({\sf C})$, 
                                      and/or the domains of the 
                                      {\sf accum} operation (if used), or if $\bold{D}(\sf Mask)$ is incorrect.
\end{itemize}


\paragraph{Description}

Matrices $\matrix{A}$ and $\matrix{Mask}$ are computed from input
parameters {\sf A} and {\sf Mask}, respectively, as specified by
descriptor {\sf desc}.  If either $\matrix{A}$ or $\matrix{Mask}$
cannot be computed from the input parameters, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that all indices in arrays
{\sf rows} and {\sf cols} are valid. That is, they must fall within the range of allowed
indices for matrix $\matrix{A}$ ($0 \leq {\sf rowIDs}[i] < \bold{m}(\matrix{A})
\forall i = 0,\ldots,{\sf nrows}-1$ and
$0 \leq {\sf colIDs}[j] < \bold{n}(\matrix{A}) \forall j = 0,\ldots,{\sf ncols}-1$).  Otherwise, the method returns {\sf
GrB\_INDEX\_OUTOFBOUNDS}.

A new matrix $\matrix{C} = \langle \bold{D}({\sf C}),{\sf nrows},{\sf ncols},
\bold{L}(\vector{C}) = \{ (i,j,C_{ij}), i = 0,\ldots,{\sf nrows}-1, j = 0, \ldots,{\sf ncols}-1 : {\sf rowIDs}[i]
\in \bold{i}(\matrix{A}) \wedge {\sf colIDs}[j] \in \bold{j}(\matrix{A}) \wedge \vector{Mask}[i,j] = \true \} \rangle$ is created. 
\scott{The use of $\bold{i}(\matrix{A})$ and $\bold{j}(\matrix{A})$ here is not correct.  They give the non-empty rows and columns of the matrix but not an indication if a value is stored at the intersection of this row and column.} 
The value $C_{ij}$ is set to $\matrix{A}[{\sf rowIDs}[i],{\sf colIDs}[j]]$. If
casting from $\bold{D}(\vector{A})$ to $\bold{D}(\vector{C})$ is not
allowed, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

Finally, output parameter {\sf C} is computed from matrix $\matrix{C}$ as
specified by descriptor {\sf desc} and accumulation function {\sf accum}.

%-----------------------------------------------------------------------------
\subsubsection{{\sf extract}: Column (and row) variant}

Extract from one column of a matrix into a vector.  Note that with the transpose
descriptor for the source matrix, elements of an arbitrary row of the matrix
can be extracted with this function as well.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_extract(GrB_Vector             *w,
                             const GrB_Vector        mask,
                             const GrB_BinaryOp      accum,
                             const GrB_Matrix        A,
                             const GrB_Index        *rowIDs,
                             GrB_Index               nrows,
                             GrB_Index               colID,
                             const GrB_Descriptor    desc); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf w}]      ({\sf INOUT})  The vector into which to place the extracted values.

    \item[{\sf mask}]   ({\sf IN}) Output mask vector. The mask
    specifies which elements of {\sf w} can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  ({\sf IN})  Operator used for accumulating entries into existing {\sf w} entries. 
			If no accumulation is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf A}]      ({\sf IN}) ) The matrix from which to extract the column.

    \item[{\sf rowIDs}] ({\sf IN})   An array of row indices to extract. Can
                              be set to a special array, {\sf GrB\_ALL}, if all elements
                              are to be extracted from the column.
    \item[{\sf nrows}]  ({\sf IN}) The number of indices in array {\sf rowIDs}.
    \item[{\sf colID}]  ({\sf IN}) The index of the column to extract.

    \item[{\sf desc}]   ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\ ~ \\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w} is cleared (all elements removed) before result is stored in it. \\
    {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN} & Apply transpose to {\sf A} before extract. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]    not enough memory available for operation.
\item[{\sf GrB\_NOOBJECT}]   one or more of the GraphBLAS objects has
                             not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf w} or {\sf rowIDs} pointer is {\sf NULL}.

\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  The indexes specify a position that outside the dimensions of src.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
       The size of {\sf rowIDs} is greater than the size of {\sf w} , 
       or the dimensions of the mask (if specified) do not match {\sf w}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between $\bold{D}(\sf A)$, 
                                      $\bold{D}({\sf w})$, and/or the domains of the 
                                      {\sf accum} operation (if used), or if $\bold{D}(\sf mask)$ is incorrect.
\end{itemize}

\paragraph{Description}

Matrix $\matrix{A}$ and vector $\vector{mask}$ are computed from input
parameters {\sf A} and {\sf mask}, respectively, as specified by
descriptor {\sf desc}.  If either $\matrix{A}$ or $\vector{mask}$
cannot be computed from the input parameters, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that all indices in array
{\sf rowIDs} and index {\sf colID} are valid. That is, they must fall within the range of allowed
indices for matrix $\matrix{A}$ ($0 \leq {\sf rowIDs}[i] < \bold{n}(\matrix{A})
\forall i = 0,\ldots,{\sf nrows}-1$ and
$0 \leq {\sf colID} < \bold{n}(\matrix{A})$).  Otherwise, the method returns {\sf
GrB\_INDEX\_OUTOFBOUNDS}.

A new vector $\vector{w} = \langle \bold{D}({\sf w}),{\sf nrows},
\bold{L}(\vector{w}) = \{ (i,w_{i}), i = 0,\ldots,{\sf nrows}-1 : {\sf rowIDs}[i]
\in \bold{i}(\matrix{A}) \wedge {\sf colID} \in \bold{j}(\matrix{A}) \wedge \vector{mask}[i] = \true \} \rangle$
is created.  The value $w_{i}$ is set to $\matrix{A}[{\sf rowIDs}[i],{\sf colID}]$. If
casting from $\bold{D}(\matrix{A})$ to $\bold{D}(\vector{w})$ is not
allowed, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

Finally, output parameter {\sf w} is computed from vector $\vector{w}$ as
specified by descriptor {\sf desc} and accumulation function {\sf accum}.

%-----------------------------------------------------------------------------
\subsubsection{{\sf extract}: Single element vector variant}
\label{Sec:extract_single_element_vec}

\scott{(1) The descriptor is not necessary. (2) There is no masking. (3) Accumulation
with the scalar is much less useful.  I argue that this should be moved to Vector 
methods: Vector\_getElement or Vector\_getValue.}

Extract one element of a vector into a scalar. 

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_extract(<type>                 *val,
                             const GrB_BinaryOp      accum,
                             const GrB_Vector        u,
                             GrB_Index               index,
                             const GrB_Descriptor    desc,
                             char                   *err); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf val}]   ({\sf INOUT}) The scalar into which to assign the extracted value.
    \item[{\sf accum}] ({\sf IN}) Operator used for accumulation into {\sf val}. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.
    \item[{\sf u}]     ({\sf IN})  The vector from which to extract the scalar.
    \item[{\sf index}] ({\sf IN}) The index of location in {\sf u} to extract

    \item[{\sf desc}]  ({\sf IN}) Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\ ~ \\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf ---} & {\sf ---} & {\sf ---} & There are no valid descriptor fields for this operation. \\
    \end{tabular}
    \item[{\sf err}]   ({\sf INOUT?})  A null terminated string containing additional error
                         information on computations within the sequence 
                         terminated by this method. 

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]          Operation completed successfully.
\item[{\sf GrB\_PANIC}]            Unknown internal error.
\item[{\sf GrB\_NOOBJECT}]   one or more of the GraphBLAS objects has
                             not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf val} or {\sf err???} pointer is {\sf NULL}.
\item[{\sf GrB\_NOVALUE}]        No stored value at specified location.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  Index {\sf index} is out of 
                                      bounds of the vector. 
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between $\bold{D}(\sf u)$ and type of {\sf val},
                                      and/or the domains of the 
                                      {\sf accum} operation (if used).
\end{itemize}

\paragraph{Description}

If $({\sf index},u_{\sf index}) \notin \bold{L}({\sf u})$, the method returns {\sf GrB\_NOVALUE}.
Otherwise, if ${\sf accum} = {\sf GrB\_NULL}$, then ${\sf val} \leftarrow {\sf u}[{\sf index}]$.
If an accumulation function is provided, then ${\sf val} \leftarrow {\sf accum}({\sf val},{\sf u}[{\sf index}])$.
If computing the new value of {\sf val} requires casting and that is not allowed by the descriptor,
the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

%--------------------------------------------------------------

\subsubsection{{\sf extract}: Single element matrix variant}
\label{Sec:extract_single_element_mat}

\scott{(1) The descriptor is not necessary. (2) There is no masking. (3) Accumulation
with the scalar is much less useful.  I argue that this should be moved to Matrix 
methods: Matrix\_getElement or Matrix\_getValue.}

Extract one element of a matrix into a scalar. 

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_extract(<type>                 *val,
                             const GrB_BinaryOp      accum,
                             const GrB_Matrix        A,
                             GrB_Index               rowID,
                             GrB_Index               colID,
                             const GrB_Descriptor    desc,
                             char                   *err); 

\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf val}]   ({\sf INOUT? OUT?}) The scalar into which to assign the extracted value.
    \item[{\sf accum}] ({\sf IN}) Operator used for accumulation into {\sf val}. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.
    \item[{\sf A}]     ({\sf IN}) The matrix from which to extract the scalar.
    \item[{\sf rowID}] ({\sf IN}) The row index of location to extract.
    \item[{\sf colID}] ({\sf IN}) The column index of location to extract.

    \item[{\sf desc}]  ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\ ~ \\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf ---} & {\sf ---} & {\sf ---} & \scott{An argument can be made that are no valid descriptor fields for this operation.  Transpose of A is not necessary, just switch rowID and colID on call.} \\
    {\sf A}   & {\sf GrB\_INP0} & {\sf GrB\_TRAN} &  Transpose {\sf A} before extracting element \\
    \end{tabular}
    \item[{\sf err}]   ({\sf INOUT?}) A null terminated string containing additional error
                         information on computations within the sequence 
                         terminated by this method. 

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_NOOBJECT}]   one or more of the GraphBLAS objects has
                             not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf val} or {\sf err???} pointer is {\sf NULL}.
\item[{\sf GrB\_NOVALUE}]             There is no value stored at the specified location.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  Either the row or the column index,
                                      {\sf rowID} or {\sf colID}, is out of matrix bounds.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between the type of $(\sf val)$, 
                                      $\bold{D}({\sf A})$, and/or the domains of the 
                                      {\sf accum} operation (if used).
\end{itemize}

\paragraph{Description}

A matrix $\matrix{A}$ is computed from input parameter {\sf A} as specified by descriptor {\sf desc}.
If $\matrix{A}$ cannot be computed, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

If $({\sf rowID},{\sf colID}, A_{{\sf rowID},{\sf colID}}) \notin \bold{L}(\matrix{A})$, 
the method returns {\sf GrB\_NOVALUE}.  Otherwise, if 
${\sf accum} = {\sf GrB\_NULL}$, then ${\sf val} \leftarrow \matrix{A}[{\sf rowID},{\sf colID}]$.
If an accumulation function is provided, then 
${\sf val} \leftarrow {\sf accum}({\sf val},\matrix{A}[{\sf rowID},{\sf colID}])$.
If computing the new value of {\sf val} requires casting and that is not allowed,
the method returns {\sf GrB\_DOMAIN\_MISMATCH}.
