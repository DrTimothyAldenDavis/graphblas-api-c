\subsection{{\sf extract}: Selecting Sub-Graphs}
\label{Sec:extract}

Extract a sub-matrix (vector) from a larger matrix (vector). 

In the standard version of {\sf extract}, GraphBLAS index arrays
specify the elements in the source vector/matrix that are copied to
the destination. \scott{this statement goes with the next two subsections only.}

If an accumulation function is specified, then that function is
used to combine current elements in the destination with those elements
extracted from the source. If no accumulation function is specified, then
the destination is overwritten with the extracted elements.  \scott{this 
statement should be moved into individual Description sections.}

%--------------------------------------------------------------

\subsubsection{{\sf extract}: Standard vector variant}

For vectors, only one index array is used to specify
elements, and for matrices two index arrays (for row and column indices)
are needed.  The size of the destination vector is the same size as
the one index array provided.  

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_extract(GrB_Vector             *u,
                             const GrB_Vector        mask,
                             const GrB_BinaryOp      accum,
                             const GrB_Vector        v,
                             const GrB_Index        *indices,
                             const GrB_Index         n,
                             const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf u}]   ({\sf GrB\_OUTP}) The vector to store the extracted subgraph.

    \item[{\sf mask}] ({\sf GrB\_MASK}) Output mask. The mask
    specifies which elements of {\sf dst} can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Operator used for accumulating entries into existing {\sf u} entries. 
			If no accumulation is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf v}]   ({\sf GrB\_INP0}) The vector from which to extract the subgraph.
    \item[{\sf indices}]     The set of element indices specifying elements from source that
                              are extracted. Can
                              be set to {\sf GrB\_ALL} if all elements are
                              to be extracted.
    \item[{\sf n}]     The number of indices in array {\sf indices}.

    \item[{\sf desc}]   Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
    {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf u})$ must equal $\bold{D}({\sf v})$
                                          when {\sf accum} is {\sf GrB\_NULL}; otherwise, 
                                          $\bold{D}({\sf u})$ must equal both 
                                          $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
    {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf mask})$ must equal {\sf GrB\_BOOL}. \\
    {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf v})$ must equal $\bold{D}({\sf u})$
                                          when {\sf accum} is {\sf GrB\_NULL}; otherwise, 
                                          $\bold{D}({\sf v})$ must equal $\bold{D}_2({\sf accum})$. 
                                          \scott{i.e., there are two ways to specify the former}\\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]    not enough memory available for operation.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]
        A value in {\sf indices} references a non-existent element in {\sf v}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf indices} is not equal to the size of {\sf u}, or
        the dimensions of the mask (if specified) do not match {\sf u}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between $\bold{D}({\sf v})$ and $\bold{D}({\sf u})$, and/or the domains of the 
                                     {\sf accum} operation (if used) when {\sf NOCAST} has
                                      been specified or if $\bold{D}(\sf mask)$ is incorrect.
\end{itemize}

\paragraph{Description}

Vectors $\vector{v}$ and $\vector{mask}$ are computed from input
parameters {\sf v} and {\sf mask}, respectively, as specified by
descriptor {\sf desc}.  If either $\vector{v}$ or $\vector{mask}$
cannot be computed from the input parameters, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that all indices in array
{\sf indices} are valid. That is, they must fall within the range of allowed
indices for vector $\vector{v}$ ($0 \leq {\sf indices}[i] < \bold{n}(\vector{v})
\forall i = 0,\ldots,{\sf n}-1$).  Otherwise, the method returns {\sf
GrB\_INDEX\_OUTOFBOUNDS}.

A new vector $\vector{u} = \langle \bold{D}({\sf u}),{\sf n},
\bold{L}(\vector{u}) = \{ (i,u_i), i = 0,\ldots,{\sf n}-1 : {\sf indices}[i]
\in \bold{i}(\vector{v}) \wedge \vector{mask}[i] = \true \} \rangle$
is created.  The value $u_i$ is set to $\vector{v}[{\sf indices}[i]]$. If
casting from $\bold{D}(\vector{v})$ to $\bold{D}(\vector{u})$ is not
allowed, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

Finally, output parameter {\sf u} is computed from vector $\vector{u}$ as
specified by descriptor {\sf desc} and accumulation function {\sf accum}.


%--------------------------------------------------------------

\subsubsection{{\sf extract}: Standard matrix variant}

For matrices, the destination matrix has
the same number of rows as the size of the row index array and the same
number of columns as the size of the column index array.

\paragraph{\syntax}

\begin{verbatim}                 
        GrB_info GrB_extract(GrB_Matrix                *C,
                             const GrB_Matrix           Mask,
                             const GrB_BinaryFunction   accum,
                             const GrB_Matrix           A,
                             const GrB_Index           *rows,
                             const GrB_Index            m,
                             const GrB_Index           *cols,
                             const GrB_Index            n,
                             GrB_Descriptor const       desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf C}]   ({\sf GrB\_OUTP}) The matrix to store the extracted subgraph.

    \item[{\sf Mask}] ({\sf GrB\_MASK}) Output mask. The mask
    specifies which elements of {\sf dst} can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Operator used for accumulating entries into existing {\sf C} entries. 
			If no accumulation is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf A}]   ({\sf GrB\_INP0}) The matrix from which to extract the subgraph.
    \item[{\sf rows}]     The set of row indices specifying rows from source that
                              are extracted. Can
                              be set to {\sf GrB\_ALL} if all rows are
                              to be extracted.
    \item[{\sf m}]     The number of indices in array {\sf rows}.
    \item[{\sf cols}]   The set of column indices specifying
                              columns from source that are extracted. Can
                              be set to {\sf GrB\_ALL} if all columns are
                              to be extracted.
    \item[{\sf n}]     The number of indices in array {\sf cols}.

    \item[{\sf desc}]   Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
      {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf C})$ must equal $\bold{D}({\sf A})$ when
                                          {\sf accum} is {\sf GrB\_NULL}; otherwise $\bold{D}({\sf C})$
                                          must equal both $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
    {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf Mask})$ must equal {\sf GrB\_BOOL}. \\
    {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf Mask}. \\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf A})$ must equal $\bold{D}({\sf C})$
                                          when {\sf accum} is {\sf GrB\_NULL}; otherwise,
                                          $\bold{D}({\sf A})$ must equal $\bold{D}_2({\sf accum})$.
                                          \scott{i.e., there are two ways to specify the former.}\\
    {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Apply transpose to {\sf A} before extract.) \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]    not enough memory available for operation.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]
        A value in {\sf rows} references a non-existent row in {\sf A}, or
        the value in {\sf cols} references a non-existent column in {\sf A}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf rows} is not equal to the number of rows in {\sf C}, or
        the size of {\sf cols} is not equal to the number of columns in {\sf C}, or
        the dimensions of the mask (if specified) do not match {\sf C}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between $\bold{D}({\sf A})$ and $\bold{D}({\sf C})$, 
                                      and/or the domains of the 
                                      {\sf accum} operation (if used) when {\sf NOCAST} has
                                      been specified or if $\bold{D}(\sf Mask)$ is incorrect.
\end{itemize}


\paragraph{Description}

Matrices $\matrix{A}$ and $\matrix{Mask}$ are computed from input
parameters {\sf A} and {\sf Mask}, respectively, as specified by
descriptor {\sf desc}.  If either $\matrix{A}$ or $\matrix{Mask}$
cannot be computed from the input parameters, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that all indices in arrays
{\sf rows} and {\sf cols} are valid. That is, they must fall within the range of allowed
indices for matrix $\matrix{A}$ ($0 \leq {\sf rows}[i] < \bold{m}(\matrix{A})
\forall i = 0,\ldots,{\sf m}-1$ and
$0 \leq {\sf cols}[j] < \bold{n}(\matrix{A}) \forall j = 0,\ldots,{\sf n}-1$).  Otherwise, the method returns {\sf
GrB\_INDEX\_OUTOFBOUNDS}.

A new matrix $\matrix{B} = \langle \bold{D}({\sf C}),{\sf m},{\sf n},
\bold{L}(\vector{B}) = \{ (i,j,B_{ij}), i = 0,\ldots,{\sf m}-1, j = 0, \ldots,{\sf n}-1 : {\sf rows}[i]
\in \bold{i}(\matrix{A}) \wedge {\sf cols}[j] \in \bold{j}(\matrix{A}) \wedge \vector{Mask}[i,j] = \true \} \rangle$
is created.  The value $B_{ij}$ is set to $\matrix{A}[{\sf rows}[i],{\sf cols}[j]]$. If
casting from $\bold{D}(\vector{A})$ to $\bold{D}(\vector{B})$ is not
allowed, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

Finally, output parameter {\sf C} is computed from matrix $\matrix{B}$ as
specified by descriptor {\sf desc} and accumulation function {\sf accum}.

%-----------------------------------------------------------------------------
\subsubsection{{\sf extract}: Column (and row) variant}

Extract from one column of a matrix into a vector.  Note that with the transpose
descriptor for the source matrix, elements of an arbitrary row of the matrix
can be extracted with this function as well.

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_extract(GrB_Vector             *u,
                             const GrB_Vector        mask,
                             const GrB_BinaryOp      accum,
                             const GrB_Matrix        A,
                             const GrB_Index        *rows,
                             GrB_Index               m,
                             GrB_Index               col,
                             const GrB_Descriptor    desc); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf u}]   ({\sf GrB\_OUTP}) The vector into which to place the extracted values.

    \item[{\sf mask}] ({\sf GrB\_MASK}) Output mask vector. The mask
    specifies which elements of {\sf u} can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Operator used for accumulating entries into existing {\sf u} entries. 
			If no accumulation is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf A}]      ({\sf GrB\_INP0}) The matrix from which to extract the column.

    \item[{\sf rows}]   An array of row indices to extract. Can
                              be set to a special array, {\sf GrB\_ALL}, if all elements
                              are to be extracted from the column.
    \item[{\sf m}]      The number of indices in array {\sf rows}.
    \item[{\sf col}]    The index of the column to extract.

    \item[{\sf desc}]   Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
    {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf u})$ must equal $\bold{D}({\sf A})$ when
                                          {\sf accum} is {\sf GrB\_NULL}; otherwise $\bold{D}({\sf u})$
                                          must equal both $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
    {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf mask})$ must equal {\sf GrB\_BOOL}. \\
    {\sf GrB\_MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf A})$ must equal $\bold{D}({\sf u})$ 
                                          when {\sf accum} is {\sf GrB\_NULL}; otherwise,
                                          $\bold{D}({\sf A})$ must equal $\bold{D}_2({\sf accum})$.
                                          \scott{i.e., there are two ways to specify the former.}\\
    {\sf GrB\_INP0} & {\sf GrB\_TRAN} & Apply transpose to {\sf A} before extract. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  The indexes specify a position that outside the dimensions of src.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
       The size of {\sf rows} is greater than the size of {\sf u} , 
       or the dimensions of the mask (if specified) do not match {\sf u}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between $\bold{D}(\sf A)$, 
                                      $\bold{D}({\sf u})$, and/or the domains of the 
                                      {\sf accum} operation (if used) when {\sf NOCAST} has
                                      been specified or if $\bold{D}(\sf mask)$ is incorrect.
\end{itemize}

\paragraph{Description}

Matrix $\matrix{A}$ and vector $\vector{mask}$ are computed from input
parameters {\sf A} and {\sf mask}, respectively, as specified by
descriptor {\sf desc}.  If either $\matrix{A}$ or $\vector{mask}$
cannot be computed from the input parameters, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that all indices in array
{\sf rows} and index {\sf col} are valid. That is, they must fall within the range of allowed
indices for matrix $\matrix{A}$ ($0 \leq {\sf rows}[i] < \bold{m}(\matrix{A})
\forall i = 0,\ldots,{\sf m}-1$ and
$0 \leq {\sf col} < \bold{n}(\matrix{A})$).  Otherwise, the method returns {\sf
GrB\_INDEX\_OUTOFBOUNDS}.

A new vector $\vector{u} = \langle \bold{D}({\sf u}),{\sf m},
\bold{L}(\vector{u}) = \{ (i,v_{i}), i = 0,\ldots,{\sf m}-1 : {\sf rows}[i]
\in \bold{i}(\matrix{A}) \wedge {\sf col} \in \bold{j}(\matrix{A}) \wedge \vector{mask}[i] = \true \} \rangle$
is created.  The value $v_{i}$ is set to $\matrix{A}[{\sf rows}[i],{\sf col}]$. If
casting from $\bold{D}(\matrix{A})$ to $\bold{D}(\vector{u})$ is not
allowed, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

Finally, output parameter {\sf u} is computed from vector $\vector{u}$ as
specified by descriptor {\sf desc} and accumulation function {\sf accum}.

%-----------------------------------------------------------------------------
\subsubsection{{\sf extract}: Single element vector variant}
\label{Sec:extract_single_element_vec}

Extract one element of a vector into a scalar. 

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_extract(<type>                 *dst,
                             const GrB_BinaryOp      accum,
                             const GrB_Vector        v,
                             GrB_Index               index,
                             const GrB_Descriptor    desc,
                             char                   *err); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf dst}]   ({\sf GrB\_OUTP}) The scalar into which to assign the extracted value.  The specific type should be in domain $\bold{D}({\sf v})$ if {\sf NOCAST} is specified in {\sf desc}.
    \item[{\sf accum}] Operator used for accumulation into dst. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.
    \item[{\sf v}]   ({\sf GrB\_INP0}) The vector from which to extract the scalar.
    \item[{\sf index}]   The index of location to extract

    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
    {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf dst})$ must equal $\bold{D}({\sf v})$ when
                                          {\sf accum} is {\sf GrB\_NULL}; otherwise $\bold{D}({\sf dst})$
                                          must equal both $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf v})$ must equal $\bold{D}({\sf dst})$ 
                                          when {\sf accum} is {\sf GrB\_NULL}; otherwise,
                                          $\bold{D}({\sf v})$ must equal $\bold{D}_2({\sf accum})$.
                                          \scott{i.e., there are two ways to specify the former.}\\
    \end{tabular}
    \item[{\sf err}]     A null terminated string containing additional error
                         information on computations within the sequence 
                         terminated by this method. 

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]          Operation completed successfully.
\item[{\sf GrB\_PANIC}]            Unknown internal error.
\item[{\sf GrB\_NOVALUE}]        No stored value at specified location.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  Index {\sf index} is out of 
                                      bounds of the vector. 
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between $\bold{D}(\sf v)$ and type of {\sf dst},
                                      and/or the domains of the 
                                      {\sf accum} operation (if used) when {\sf NOCAST} has
                                      been specified.
\end{itemize}

\paragraph{Description}

If $({\sf index},u_{\sf index}) \notin \bold{L}({\sf u})$, the method returns {\sf GrB\_NOVALUE}.
Otherwise, if ${\sf accum} = {\sf GrB\_NULL}$, then ${\sf dst} \leftarrow {\sf v}[{\sf index}]$.
If an accumulation function is provided, then ${\sf dst} \leftarrow {\sf accum}({\sf dst},{\sf v}[{\sf index}])$.
If computing the new value of {\sf dst} requires casting and that is not allowed by the descriptor,
the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

%--------------------------------------------------------------

\subsubsection{{\sf extract}: Single element matrix variant}
\label{Sec:extract_single_element_mat}

Extract one element of a matrix into a scalar. 

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_extract(<type>                 *dst,
                             const GrB_BinaryOp      accum,
                             const GrB_Matrix        A,
                             GrB_Index               i,
                             GrB_Index               j,
                             const GrB_Descriptor    desc,
                             char                   *err); 

\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf dst}]   ({\sf GrB\_OUTP}) The scalar into which to assign the extracted value.  The specific type should be in domain $\bold{D}({\sf A})$ if {\sf NOCAST} is specified in {\sf desc}.
    \item[{\sf accum}] Operator used for accumulation into dst. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.
    \item[{\sf A}]     ({\sf GrB\_INP0}) The matrix from which to extract the scalar.
    \item[{\sf i}]     The row index of location to extract.
    \item[{\sf j}]     The column index of location to extract.

    \item[{\sf desc}]   Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
    {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf dst})$ must equal $\bold{D}({\sf A})$ when
                                          {\sf accum} is {\sf GrB\_NULL}; otherwise $\bold{D}({\sf dst})$
                                          must equal both $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf A})$ must equal $\bold{D}({\sf dst})$ 
                                          when {\sf accum} is {\sf GrB\_NULL}; otherwise,
                                          $\bold{D}({\sf A})$ must equal $\bold{D}_2({\sf accum})$.
                                          \scott{i.e., there are two ways to specify the former.}\\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf A})$ must equal type of ${\sf dst}$ \\
    {\sf GrB\_INP0} & {\sf GrB\_TRAN} &  Transpose {\sf A} before extracting element \\
    \end{tabular}
    \item[{\sf err}]     A null terminated string containing additional error
                         information on computations within the sequence 
                         terminated by this method. 

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_NOVALUE}]             There is no value stored at the specified location.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  Either the row or the column index,
                                      {\sf i} or {\sf j}, is out of matrix bounds.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between the type of $(\sf dst)$, 
                                      $\bold{D}({\sf A})$, and/or the domains of the 
                                      {\sf accum} operation (if used) when {\sf NOCAST} has
                                      been specified.
\end{itemize}

\paragraph{Description}

A matrix $\matrix{A}$ is computed from input parameter {\sf A} as specified by descriptor {\sf desc}.
If $\matrix{A}$ cannot be computed, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

If $({\sf i},{\sf j}, A_{{\sf i},{\sf j}}) \notin \bold{L}(\matrix{A})$, 
the method returns {\sf GrB\_NOVALUE}.  Otherwise, if 
${\sf accum} = {\sf GrB\_NULL}$, then ${\sf dst} \leftarrow \matrix{A}[{\sf i},{\sf j}]$.
If an accumulation function is provided, then 
${\sf dst} \leftarrow {\sf accum}({\sf dst},\matrix{A}[{\sf i},{\sf j}])$.
If computing the new value of {\sf dst} requires casting and that is not allowed 
by the descriptor, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.
