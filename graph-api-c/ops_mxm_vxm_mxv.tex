\comment{
\pagebreak
\subsection{{\sf mxm}: (simple) Matrix-matrix multiply}

Multiplies a matrix with another matrix on a semiring. The result is a matrix.
This is the simple version: no mask, no accumulate, no user-defined types.
Descriptor only controls transposition of inputs.
Blocking mode only.

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_mxm(GrB_Matrix              *C,
                         const GrB_Semiring       op,
                         const GrB_Matrix         A, 
                         const GrB_Matrix         B,
                         const GrB_Descriptor     desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    An existing matrix (of dimensions $m \times n$) to store the result. 

    \item[{\sf op}]   Semiring used in the matrix-matrix multiply: ${\sf op}=\langle D_1,D_2,D_3,\oplus,\otimes,0 \rangle$.
    \item[{\sf A}]    The left-hand matrix to be multiplied.  
    \item[{\sf B}]    The right-hand matrix to be multiplied. 

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    used. Valid fields are as follows: \\ ~\\
    \begin{tabular}{lllp{2.75in}}
    Var. & Field  & Value & Description \\
    \hline
    {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A} for operation. \\
    {\sf B}    & {\sf GrB\_INP1} & {\sf GrB\_TRAN}   & Use transpose of {\sf B} for operation. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] matrix dimensions are incompatible
\end{itemize}

\raggedbottom
\pagebreak

\paragraph{Description}

Matrix $\matrix{A}$ is computed from input parameter {\sf A} as follows:
\begin{enumerate}
\item	If {\sf desc[GrB\_INP0].GrB\_TRAN} is \false, then $\matrix{A} = \langle \bold{D}({\sf A}), \bold{m}({\sf A}), \bold{n}({\sf A}),
        \bold{L}(\matrix{A}) = \{(i,j,A_{ij}) : (i,j,A_{ij}) \in \bold{L}({\sf A})\} \rangle$.
\item	If {\sf desc[GrB\_INP0].GrB\_TRAN} is \true,  then $\matrix{A} = \langle \bold{D}({\sf A}), \bold{n}({\sf A}), \bold{m}({\sf A}), 
        \bold{L}(\matrix{A}) = \{(j,i,A_{ij}) : (i,j,A_{ij}) \in \bold{L}({\sf A})\} \rangle$.
\end{enumerate}

Matrix $\matrix{B}$ is computed from input parameter {\sf B} as follows:
\begin{enumerate}
\item	If {\sf desc[GrB\_INP1].GrB\_TRAN} is \false, then $\matrix{B} = \langle \bold{D}({\sf B}), \bold{m}({\sf B}), \bold{n}({\sf B}),
        \bold{L}(\matrix{B}) = \{(i,j,B_{ij}) : (i,j,B_{ij}) \in \bold{L}({\sf B})\} \rangle$.
\item	If {\sf desc[GrB\_INP1].GrB\_TRAN} is \true,  then $\matrix{B} = \langle \bold{D}({\sf B}), \bold{n}({\sf B}), \bold{m}({\sf B}), 
        \bold{L}(\matrix{B}) = \{(j,i,B_{ij}) : (i,j,B_{ij}) \in \bold{L}({\sf B})\} \rangle$.
\end{enumerate}

If $\bold{n}(\matrix{A}) \neq \bold{m}(\matrix{B})$, the method exits with return code {\sf GrB\_DIMENSION\_MISMATCH}.

A new matrix $\matrix{C} = \langle \bold{D}_3({\sf op}),
\bold{m}(\matrix{A}), \bold{n}(\matrix{B}), \bold{L}(\vector{C}) =
\{(i,j,C_{ij}) : \vector{i}(\matrix{A}(i,:)) \cap
\vector{i}(\matrix{B}(:,j)) \neq \emptyset \} \rangle$ is created.
The value of each of its elements is computed by 
\[ 
C_{ij} = \bigoplus_{k
\in \vector{i}(\matrix{A}(i,:)) \cap \vector{i}(\matrix{B}(:,j))}
(((D_1)\matrix{A}(i,k)) \otimes ((D_2)\matrix{B}(k,j))),
\]
where $\oplus$
and $\otimes$ are the additive and multiplicative operators of
semiring {\sf op}, respectively.  

If $\bold{m}(\matrix{C}) \neq \bold{m}({\sf C})$ or $\bold{n}(\matrix{C}) \neq \bold{n}({\sf C})$,
the method exits with return code {\sf GrB\_DIMENSION\_MISMATCH}.
Otherwise, set $\bold{L}({\sf C}) = \{(i,j,(\bold{D}({\sf C}))C_{ij}) : (i,j,C_{ij}) \in \bold{L}(\matrix{C}) \}$, and return {\sf GrB\_SUCCESS}.

}
\raggedbottom
\pagebreak
%-----------------------------------------------------------------------------
\subsection{{\sf mxm}: Matrix-matrix multiply}

Multiplies a matrix with another matrix on a semiring. The result is a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_mxm(GrB_Matrix              *C,
                         const GrB_Matrix         Mask,
                         const GrB_BinaryOp       accum,
                         const GrB_Semiring       op,
                         const GrB_Matrix         A, 
                         const GrB_Matrix         B,
                         const GrB_Descriptor     desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS matrix. On
    input, the matrix provides values that may be accumulated with the
    result of the matrix product.   On output, the matrix holds the
    results of this operation.

    \item[{\sf Mask}] ({\sf IN}) A ``write'' mask that controls which
    results from this operation are stored into the output matrix
    ${\sf C}$ (optional).  If no mask is desired (\ie, all elements
    of result are copied into the output matrix), {\sf GrB\_NULL}
    should be specified. The Mask dimensions must match those of the
    matrix {\sf C} and the domain of the {\sf Mask} matrix must be
    of type {\sf bool} or any of the predefined ``built-in'' types in
    Table~\ref{Tab:PredefinedTypes}.

    \item[{\sf accum}] ({\sf IN}) Operator used for accumulating entries
    into existing \matrix{\sf C} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}] ({\sf IN}) Semiring used in the matrix-matrix
    multiply: ${\sf op}=\langle D_1,D_2,D_3,\oplus,\otimes,0 \rangle$.

    \item[{\sf A}] ({\sf IN}) The GraphBLAS matrix holding the values
    for the left-hand matrix in the multiplication.

    \item[{\sf B}] ({\sf IN}) The GraphBLAS matrix holding the values
    for the right-hand matrix in the multiplication.

    \item[{\sf desc}] ({\sf IN}) Operation descriptor (optional). If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    used. Valid fields are as follows: 

    \begin{tabular}{lllp{2.75in}}
    Argument   & Field           & Value               & Description \\ \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE}  & Output matrix {\sf C} is cleared (all elements removed) before result is stored in it. \\
    {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}     & Use the structural complement of {\sf Mask}. \\
    {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}     & Use transpose of {\sf A} for operation. \\
    {\sf B}    & {\sf GrB\_INP1} & {\sf GrB\_TRAN}     & Use transpose of {\sf B} for operation. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]

	\item[{\sf GrB\_SUCCESS}]	      In blocking mode, operation
	completed successfully. In non-blocking mode, this indicates
	that the consistency tests on dimensions and domains for the
	input arguments passed successfully. Either way, output matrix
	{\sf C} is ready to be used in the next method of the sequence.

	\item[{\sf GrB\_PANIC}]		      Unknown internal error

	\item[{\sf GrB\_OUTOFMEM}]	      Not enough memory available
	for operation

	\item[{\sf GrB\_DIMENSION\_MISMATCH}] Matrix dimensions are
	incompatible.

	\item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various
	matrices are incompatible with the corresponding domains of the
	accumulating operation, semiring, or mask.

\end{itemize}

\comment{
\paragraph{Description}

Matrices $\matrix{A}, \matrix{B}$, and $\matrix{Mask}$ are computed from
input parameters {\sf A}, {\sf B} and {\sf Mask}, respectively, as specified
by descriptor {\sf desc}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting and transposing, can be performed.)  $\bold{D}(\matrix{A}) =
\bold{D}_1({\sf op})$ and $\bold{D}(\matrix{B}) = \bold{D}_2({\sf op})$.
$\bold{D}(\matrix{Mask}) = {\sf GrB\_BOOL}$.  If {\sf Mask} is {\sf GrB\_NULL} or omitted,
then $\matrix{Mask}$ is a Boolean matrix of the same dimensions as $\matrix{C}$
and with all elements set to {\sf true}.

If either $\matrix{A}, \matrix{B}$, and $\matrix{Mask}$  cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that dimensions of $\matrix{A}$, $\matrix{B}$
and $\matrix{C}$ are compatible, considering possible transpositions.  If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A consistency check is performed to verify the dimensions of $\matrix{C}$
and $\matrix{Mask}$ agree.  If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A new matrix $\matrix{C} = \langle \bold{D}_3({\sf op}),
\bold{m}(\matrix{A}), \bold{n}(\matrix{B}), \bold{L}(\vector{C}) = \{(i,j,C_{ij}) : \matrix{Mask}(i,j)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $C_{ij} = \bigoplus_{k \in \vector{i}(\matrix{A}(i,:)) \cap
\vector{i}(\matrix{B}(:,j))} (\matrix{A}(i,j) \otimes \matrix{B}(k,j))$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operators of semiring {\sf op}, respectively.  If $\vector{i}(\matrix{A}(i,:)) \cap \vector{i}(\matrix{B}(:,j)) = \emptyset $ then the tuple $(i,j,C_{ij})$
is not included in $\bold{L}(\matrix{C})$.

Finally, output parameter {\sf C} is computed from matrix $\matrix{C}$
as specified by descriptor {\sf desc}. (In the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{m}({\sf C}) = \bold{m}(\matrix{C})$ and $\bold{n}({\sf C}) = \bold{n}(\matrix{C})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.
}

\paragraph{Description}

{\sf GrB\_mxm} computes the matrix product $\matrix{\sf C} = \matrix{\sf
A} \otimes . \oplus \matrix{\sf B}$ or, if an optional binary accumulation
operator ($\odot$) is provided, $\matrix{\sf C} = \matrix{\sf C} \odot
\matrix{\sf A} \otimes . \oplus \matrix{\sf B}$.  (Matrices {\sf A}
and {\sf B} can be optionally transposed.)  Logically, this operation
occurs in three steps:
\begin{enumerate}
\item The internal matrices and mask used in the computation are formed and their domains/dimensions are tested for consistency.
\item The indicated computations are carried out.
\item The result is written into the output matrix, possibly under control of a mask.
\end{enumerate}

Up to four argument matrices are used in the {\sf GrB\_mxm} operation:
\begin{enumerate}
\item $\matrix{\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}(\matrix{\sf C}),\bold{ncols}(\matrix{\sf C}),\bold{L}(\matrix{\sf C}) = \{(i,j,C_{ij}) \} \rangle$
\item $\matrix{\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}(\matrix{\sf Mask}),\bold{ncols}(\matrix{\sf Mask}),\bold{L}(\matrix{\sf Mask}) = \{(i,j,{\sf Mask}_{ij}) \} \rangle$ (optional)
\item $\matrix{\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}(\matrix{\sf A}), \bold{ncols}(\matrix{\sf A}),\bold{L}(\matrix{\sf A}) = \{(i,j,A_{ij}) \} \rangle$
\item $\matrix{\sf B} = \langle \bold{D}({\sf B}),\bold{nrows}(\matrix{\sf B}), \bold{ncols}(\matrix{\sf B}),\bold{L}(\matrix{\sf B}) = \{(i,j,B_{ij}) \} \rangle$
\end{enumerate}

The argument matrices, the semiring, and the accumulator operator (if provided) are tested for domain consistency
as follows:
\begin{enumerate}

	\item The domain of {\sf Mask} (if not {\sf GrB\_NULL}) must be from one of the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item $\bold{D}(\matrix{\sf A})$ must be compatible with $D_1$ of the semiring.

	\item $\bold{D}(\matrix{\sf B})$ must be compatible with $D_2$ of the semiring.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}(\matrix{\sf C})$ must be compatible with $D_3$ of the semiring.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}(\matrix{\sf C})$ must be compatible with $D_x$ and $D_z$ of the 
	accumulator operator and $D_3$ of the semiring must be compatible with $D_y$ of the accumulator operator.

\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast to values in the other domain as per the rules of the C language.
In particualr, domains from Table~\ref{Tab:PredefinedTypes} are all compatible with each other. A domain from a user-defined type is only compatible with itself.
If any consistency rule above is violated, execution of {\sf GrB\_mxm} ends and the domain mismatch error listed above is returned.

From the argument matrices, the internal matrices and mask used in the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}

	\item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

	\item Two-dimensional mask $\matrix{\widetilde{Mask}}$ is computed from argument {\sf Mask} as follows:
	\begin{enumerate}

		\item	If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{Mask}} = \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < \bold{ncols}({\sf C}) \} \rangle$.

		\item	Otherwise, $\matrix{\widetilde{Mask}} = \langle \bold{nrows}({\sf Mask}), \bold{ncols}({\sf Mask}), \{(i,j) : ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is \true, then $\matrix{\widetilde{Mask}} \leftarrow \neg \matrix{\widetilde{Mask}}$.

	\end{enumerate}

	\item Matrix $\matrix{\widetilde{A}} \leftarrow {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$.

	\item Matrix $\matrix{\widetilde{B}} \leftarrow {\sf desc[GrB\_INP1].GrB\_TRAN} \ ? \ {\sf B}^T : {\sf B}$.
\end{enumerate}

The internal matrices and masks are checked for shape consistency. The following conditions must hold:
\begin{enumerate}
	
	\item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{Mask}})$.

	\item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{Mask}})$.

	\item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{A}})$.

	\item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{B}})$.

	\item $\bold{ncols}(\matrix{\widetilde{A}}) = \bold{nrows}(\matrix{\widetilde{B}})$.

\end{enumerate}
If any consistency rule above is violated, execution of {\sf GrB\_mxm} ends and the dimension mismatch error listed above is returned.

%
%  TGM:   We need to help the reader follow the flow of this description. 
%

We are now ready to carry out the matrix multiplication and any additional associated operations.    We describe
this in terms of two intermediate matrices:
\begin{itemize}
\item $\matrix{\widetilde{T}}$: The matrix holding the product of matrices $\matrix{\widetilde{A}}$ and $\matrix{\widetilde{B}}$.
\item $\matrix{\widetilde{Z}}$: The matrix holding the result after application of the (optional) accumulator.
\end{itemize}

The intermediate matrix $\matrix{\widetilde{T}} = \langle
D_3, \bold{nrows}(\matrix{\widetilde{A}}),
\bold{ncols}(\matrix{\widetilde{B}}), \bold{L}(\vector{T}) =
\{(i,j,T_{ij}) : \bold{ind}(\matrix{\widetilde{A}}(i,:)) \cap
\bold{ind}(\matrix{\widetilde{B}}(:,j)) \neq \emptyset \} \rangle$
is created.  The value of each of its elements is computed by \[T_{ij}
= \bigoplus_{k \in \bold{ind}(\matrix{\widetilde{A}}(i,:)) \cap
\bold{ind}(\matrix{\widetilde{B}}(:,j))} (\matrix{\widetilde{A}}(i,k)
\otimes \matrix{\widetilde{B}}(k,j)),\] where $\oplus$ and $\otimes$
are the additive and multiplicative operators of semiring {\sf op},
respectively.

The intermediate  matrix $\matrix{\widetilde{Z}}$ is created as follows:
If ${\sf accum} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{Z}} = \matrix{\widetilde{T}}$.
If \[ {\sf accum} = \langle D_x, D_y, D_z, \odot \rangle, \] then matrix $\matrix{\widetilde{Z}}$ is defined as $\langle D_z, \bold{nrows}(\matrix{\widetilde{C}}), \bold{ncols}(\matrix{\widetilde{C}}), \bold{L}(\matrix{\widetilde{Z}}) 
		= \{(i,j,Z_{ij})  \forall (i,j) \in \bold{ind}(\matrix{\widetilde{C}}) \cup \bold{ind}(\matrix{\widetilde{T}}) \} \rangle$.  
The values of the elements of $\matrix{\widetilde{Z}}$ are computed based on the relationships between the sets of indices in $\matrix{\widetilde{C}}$ and $\matrix{\widetilde{T}}$.
\[
Z_{ij} = \matrix{\widetilde{C}}(i,j) \odot \matrix{\widetilde{T}}(i,j), \ \mbox{if}\  (i,j) \in  (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}})),
\]
\[
Z_{ij} = \matrix{\widetilde{C}}(i,j) \ \mbox{if}\  (i,j) \in  (\bold{ind}(\matrix{\widetilde{C}}) - (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}}))),
\]
\[
Z_{ij} = \matrix{\widetilde{T}}(i,j) \ \mbox{if}\  (i,j) \in  (\bold{ind}(\matrix{\widetilde{T}}) - (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}}))).
\]
where the difference operator in the previous expressions refers to set difference.

Finally, the set of output values that make up the $\matrix{\widetilde{Z}}$ matrix are written into the final result matrix, $\matrix{C}$. 
This is carried out under the influence of the mask which acts as a ``write mask''.
If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is \true, then any values in $\matrix{C}$ on input to {\sf GrB\_mxm()} are deleted and the new
output matrix $\matrix{C}$ is,
\[ \bold{L}({\sf C}) = \{(i,j,Z_{ij}) : (i,j) \in (\bold{L}(\matrix{\widetilde{Mask}}) \cap \bold{ind}(\matrix{\widetilde{Z}})) \}. \]
If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not given or is equal to any value other than \true, the elements of $\matrix{\widetilde{Z}}$ indicated by the mask
are copied into the result matrix, $\matrix{C}$ and elements of $\matrix{C}$  that fall outside the set indicated by the mask are unchanged:
\[ \bold{L}({\sf C}) = \{(i,j,C_{ij}) : (i,j) \in (\bold{ind}(\matrix{\sf C}) \cap \bold{L}(\neg \matrix{\widetilde{Mask}})) \} \cup \{(i,j,Z_{ij}) : (i,j) \in (\bold{L}(\matrix{\widetilde{Mask}}) \cap \bold{ind}(\matrix{\widetilde{Z}})) \}. \]

In {\sf GrB\_Blocking} mode, the method exits with return value {\sf GrB\_SUCCESS} and the new content of matrix {\sf C} is as defined above and fully computed.
In {\sf GrB\_NonBlocking} mode, the method exits with return value {\sf GrB\_SUCCESS} and the new content of matrix {\sf C} is as defined above but may not be fully computed. (It can be used in the next GraphBLAS method call in a sequence.)

\raggedbottom
\pagebreak
\comment{
\paragraph{Alternate Description (WORK IN PROGRESS)}

A consistency check is performed to verify that dimensions of {\sf A}, {\sf B}, {\sf C}
and {\sf Mask} are compatible, considering possible transpositions of {\sf A} and 
{\sf B}.  As an example without transposes, it is verified that 
$\bold{m}({\sf C}) = \bold{m}(\sf A)$ and $\bold{n}({\sf C}) = \bold{n}(\sf B)$. 
A consistency check is also performed to verify that the dimensions of $\sf C$ and 
$\sf Mask$ are the same.  Note, if {\sf Mask} is {\sf GrB\_NULL} or omitted,
then $\matrix{Mask}$ is a Boolean matrix of the same dimensions as $\sf C$
and with all elements set to {\sf true}. If either consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A check is also performed to verify that the domains of the matrices are consistent
with the operations to be performed.  Matrices $\matrix{A}, \matrix{B}$, and 
$\matrix{Mask}$ are computed from input parameters {\sf A}, {\sf B} and {\sf Mask},
respectively, where additional preprocessing such as casting, transposition, and
structural complement could be performed as specified by descriptor, {\sf desc}.
Note that at this point, $\bold{D}(\matrix{A}) = \bold{D}_1({\sf op})$ and 
$\bold{D}(\matrix{B}) = \bold{D}_2({\sf op})$.  Also, $\bold{D}(\matrix{Mask}) = 
{\sf GrB\_BOOL}$.  The operation is aborted and the method returns a {\sf GrB\_DOMAIN\_MISMATCH}
in the following situations:
\begin{itemize}
\item $\bold{D}({\sf A})$ does not equal $\bold{D}_1({\sf op})$ and the descriptor prohibits casting of {\sf GrB\_INP0},
\item $\bold{D}({\sf B})$ does not equal $\bold{D}_2({\sf op})$ and the descriptor prohibits casting of {\sf GrB\_INP1},
\item $\bold{D}({\sf Mask})$ does not equal ${\sf GrB\_BOOL}$ and the descriptor prohibits casting of {\sf GrB\_MASK} (Mask is not {\sf GrB\_NULL},
\item If accumulation operator is NOT present:
        \begin{itemize}
        \item $\bold{D}({\sf C})$ does not equal $\bold{D}_3({\sf op})$ and the descriptor prohibits casting of {\sf GrB\_OUTP},
        \end{itemize}
\item If accumulation operator is present:
        \begin{itemize}
        \item $\bold{D}({\sf C})$ does not equal $\langle \bold{D}_3({\sf accum})$ and the descriptor prohibits casting of {\sf GrB\_OUTP}
        \item $\bold{D}({\sf C})$ does not equal $\langle \bold{D}_1({\sf accum})$ and the descriptor prohibits casting of {\sf GrB\_OUTP}
        \item $\bold{D}_3({\sf op})$ does not equal $\langle \bold{D}_2({\sf accum})$
        \end{itemize}
\item Casting is allowed and necessary, for any argument but there is no "defined cast operation" between the two domains.
\end{itemize}



A new matrix $\matrix{C} = \langle \bold{D}_3({\sf op}),
\bold{m}(\matrix{A}), \bold{n}(\matrix{B}), \bold{L}(\vector{C}) = \{(i,j,C_{ij}) : \matrix{Mask}(i,j)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $C_{ij} = \bigoplus_{k \in \vector{i}(\matrix{A}(i,:)) \cap
\vector{i}(\matrix{B}(:,j))} (\matrix{A}(i,j) \otimes \matrix{B}(k,j))$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operators of semiring {\sf op}, respectively.  If $\vector{i}(\matrix{A}(i,:)) \cap \vector{i}(\matrix{B}(:,j)) = \emptyset $ then the tuple $(i,j,C_{ij})$
is not included in $\bold{L}(\matrix{C})$.

Finally, output parameter {\sf C} is computed from matrix $\matrix{C}$. In the 
simplest case this is just a copy, but the {\sf accum} and {\sf desc} parameters can
specify additional postprocessing, including casting and accumulation of result
values.
}

%-----------------------------------------------------------------------------

\subsection{{\sf vxm}: Vector-matrix multiply}

Multiplies a vector by a matrix on an semiring. The result is a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_vxm(GrB_Vector            *u,
                         const GrB_Vector       mask,
                         const GrB_BinaryOp     accum,
                         const GrB_Semiring     op,
                         const GrB_Vector       v, 
                         const GrB_Matrix       A,
                         const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf u}]    ({\sf GrB\_OUTP}) An existing vector to store the result.

    \item[{\sf mask}] ({\sf GrB\_MASK}) Output mask vector . The mask
    specifies which elements of the result vector can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Operator used for accumulating entries into existing
                        \vector{u} entries. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]   Semiring used in the vector-matrix multiply.
    \item[{\sf v}]    ({\sf GrB\_INP0}) The left-hand vector to be multiplied.
    \item[{\sf A}]    ({\sf GrB\_INP1}) The right-hand matrix to be multiplied.

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted. Valid fields are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
    {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf u})$ must equal $\bold{D}_3({\sf op})$
                                          when {\sf accum} is {\sf GrB\_NULL}; otherwise, $\bold{D}({\sf u})$
                                          must equal both $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$.\\
    {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf mask})$ must equal {\sf GrB\_BOOL}. \\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf v})$ must equal $\bold{D}_1({\sf op})$. \\
    {\sf GrB\_INP1} & {\sf GrB\_TRAN}   & Use transpose of {\sf A} for operation. \\
    {\sf GrB\_INP1} & {\sf GrB\_NOCAST} & $\bold{D}({\sf A})$ must equal $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among vectors, matrix dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of vectors, matrix, and/or semiring, for which the descriptor did not explicitly allow casting.
\end{itemize}

\paragraph{Description}

Vectors $\vector{v}, \vector{mask}$ and matrix $\matrix{A}$ are computed from
input parameters {\sf v}, {\sf mask} and {\sf A}, respectively, as specified
by descriptor {\sf desc}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting and transposition, can be performed.)  $\bold{D}(\vector{v}) =
\bold{D}_1({\sf op})$ and $\bold{D}(\matrix{A}) = \bold{D}_2({\sf op})$.
$\bold{D}(\vector{mask}) = {\sf GrB\_BOOL}$.  If {\sf mask} is {\sf GrB\_NULL}
then $\vector{mask}$ acts as a Boolean vector of size $\bold{n}(\vector{A})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{mask}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{m}(\matrix{A})$ and $\bold{n}(\vector{m}) =
\bold{n}(\vector{v})$. If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A new vector $\vector{u} = \langle \bold{D}_3({\sf op}),
\bold{n}(\matrix{A}), \bold{L}(\vector{u}) = \{(i,u_i) : \vector{mask}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $u_i = \bigoplus_{j \in \vector{i}(\vector{v}) \cap
\vector{i}(\matrix{A}(:,i))} (\vector{v}(j) \otimes \matrix{A}(j,i))$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operator of semiring {\sf op}, respectively.  If $\vector{i}(\vector{v})
\cap \vector{i}(\matrix{A}(:,i)) = \emptyset$ then the pair $(i,u_i)$
is not present in $\bold{L}(\vector{u})$.

Finally, output parameter {\sf u} is computed from vector $\vector{u}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf u}) = \bold{n}(\vector{u})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.

\scott{We need a more explicit discussion/specification regarding
masks and accumulation and their interaction (perhaps the diagram Manoj
projected at the SC15 BoF.} \jose{Agree. Need to find the proper place
for it.}

%-----------------------------------------------------------------------------

\subsection{{\sf mxv}: Matrix-vector multiply}

Multiplies a matrix by a vector within a semiring. The result is a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_mxv(GrB_Vector            *u,
                         const GrB_Vector       mask,
                         const GrB_BinaryOp     accum,
                         const GrB_Semiring     op, 
                         const GrB_Matrix       A,
                         const GrB_Vector       v,
                         const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf u}]    ({\sf GrB\_OUTP}) An existing vector to store the result.
    
    \item[{\sf mask}] ({\sf GrB\_MASK}) Output mask vector . The mask
    specifies which elements of the result vector can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

	\item[{\sf accum}]  Operator used for accumulating entries into existing
                        \vector{u} entries. If no accumulation is desired,
	                    {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]   Semiring used in the matrix-vector multiply.
    \item[{\sf A}]    ({\sf GrB\_INP0}) The left-hand matrix to be multiplied.
    \item[{\sf v}]    ({\sf GrB\_INP1}) The right-hand vector to be multiplied.

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used. Valid fields are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
    {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf u})$ must equal $\bold{D}_3({\sf op})$
                                          when {\sf accum} is {\sf GrB\_NULL}; otherwise, $\bold{D}({\sf u})$
                                          must equal both $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$.\\
    {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf mask})$ must equal {\sf GrB\_BOOL}. \\
    {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A} for operation. \\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf A})$ must equal $\bold{D}_1({\sf op})$. \\
    {\sf GrB\_INP1} & {\sf GrB\_NOCAST} & $\bold{D}({\sf v})$ must equal $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among vectors, matrix dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of vectors, matrix, and/or semiring, for which the descriptor did not explicitly allow casting.
\end{itemize}


\paragraph{Description}

Vectors $\vector{v}, \vector{mask}$ and matrix $\matrix{A}$ are computed from
input parameters {\sf v}, {\sf mask} and {\sf A}, respectively, as specified
by descriptor {\sf desc}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting and transposition, can be performed.)  $\bold{D}(\vector{v}) =
\bold{D}_1({\sf op})$ and $\bold{D}(\matrix{A}) = \bold{D}_2({\sf op})$.
$\bold{D}(\vector{mask}) = {\sf GrB\_BOOL}$.  If {\sf mask} is {\sf GrB\_NULL} or omitted,
then $\vector{mask}$ is a Boolean vector of size $\bold{m}(\vector{A})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{mask}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{n}(\matrix{A})$ and $\bold{n}(\vector{mask}) =
\bold{n}(\vector{u}) = \bold{m}(\matrix{A})$. If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A new vector $\vector{u} = \langle \bold{D}_3({\sf op}),
\bold{m}(\matrix{A}), \bold{L}(\vector{u}) = \{(i,u_i) : \vector{mask}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $u_i = \bigoplus_{j \in \vector{i}(\vector{v}) \cap
\vector{i}(\matrix{A}(i,:))} (\matrix{A}(i,j)) \otimes \vector{v}(j)$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operators of semiring {\sf op}, respectively.  If $\vector{i}(\vector{v})
\cap \vector{i}(\matrix{A}(i,:)) = \emptyset$ then the pair $(i,u_i)$
is not included in $\bold{L}(\vector{u})$.

Finally, output parameter {\sf u} is computed from vector $\vector{u}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf u}) = \bold{n}(\vector{u})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.
