\subsection{{\sf mxm}: Matrix-matrix multiply}

Multiplies a matrix with another matrix on a semiring. The result is a matrix.

\paragraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_mxm(GrB_Matrix              *C,
                         const GrB_Matrix         Mask,
                         const GrB_BinaryFunction accum,
                         const GrB_Semiring       op,
                         const GrB_Matrix         A, 
                         const GrB_Matrix         B
                      [, const GrB_Descriptor     desc])
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf OUTP}) An existing matrix (of dimensions $m \times n$) to store the result. 

    \item[{\sf Mask}] ({\sf MASK}) Output mask matrix of dimensions $m \times n$. 
    The mask specifies which elements of the result matrix,{\sf C}, can be modified. 
    If no mask is necessary (\ie, compute all elements of result
    matrix), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Function used for accumulating entries into existing
    \matrix{C} entries. If no accumulation is desired,
    {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]   Semiring used in the matrix-matrix multiply: ${\sf op}=\langle D_1,D_2,D_3,\oplus,\otimes,0 [,1] \rangle$.
    \item[{\sf A}]    ({\sf ARG0}) The left-hand matrix to be multiplied.  
    \item[{\sf B}]    ({\sf ARG1}) The right-hand matrix to be multiplied. 

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted. Valid fields are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf OUTP} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}_3({\sf op})$ to $\bold{D}(\matrix{C})$.\\
    {\sf OUTP} & {\sf GrB\_FIXED\_STRUCTURE} & No changes to size and indices of $\bold{L}({\sf C})$, only values. \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf Mask}. \\
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf Mask})$ to {\sf bool} domain. \\
    {\sf ARG0} & {\sf GrB\_TRAN} & Use transpose of {\sf A} for operation. \\
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}(\matrix{A})$ to $\bold{D}_1({\sf op})$. \\
    {\sf ARG1} & {\sf GrB\_TRAN} & Use transpose of {\sf B} for operation. \\
    {\sf ARG1} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}(\matrix{B})$ to $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among matrix dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of matrix, and/or semiring, for which the descriptor did not allow casting.
\item[{\sf GrB\_STRUCTURE\_MISMATCH}] output parameter has fixed structure, but that is incompatible with result of computation.
\end{itemize}


\paragraph{Description}

Matrices $\matrix{A}, \matrix{B}$, and $\matrix{Mask}$ are computed from
input parameters {\sf A}, {\sf B} and {\sf Mask}, respectively, as specified
by descriptor {\sf desc}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting and transposing, can be performed.)  $\bold{D}(\matrix{A}) =
\bold{D}_1({\sf op})$ and $\bold{D}(\matrix{B}) = \bold{D}_2({\sf op})$.
$\bold{D}(\matrix{Mask}) = {\sf GrB\_BOOL}$.  If {\sf Mask} is {\sf GrB\_NULL} or omitted,
then $\matrix{Mask}$ is a Boolean matrix of the same dimensions as $\matrix{C}$
and with all elements set to {\sf true}.

If either $\matrix{A}, \matrix{B}$, and $\matrix{Mask}$  cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that dimensions of $\matrix{A}$, $\matrix{B}$
and $\matrix{C}$ are compatible, considering possible transpositions.  If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A consistency check is performed to verify the dimensions of $\matrix{C}$
and $\matrix{Mask}$ agree.  If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A new matrix $\matrix{C} = \langle \bold{D}_3({\sf op}),
\bold{m}(\matrix{A}), \bold{n}(\matrix{B}), \bold{L}(\vector{C}) = \{(i,j,C_{ij}) : \matrix{Mask}(i,j)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $C_{ij} = \bigoplus_{k \in \vector{i}(\matrix{A}(i,:)) \cap
\vector{i}(\matrix{B}(:,j))} (\matrix{A}(i,j) \otimes \matrix{B}(k,j))$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operations of semiring {\sf op}, respectively.  If $\vector{i}(\matrix{A}(i,:)) \cap \vector{i}(\matrix{B}(:,j)) = \emptyset $ then the tuple $(i,j,C_{ij})$
is not included in $\bold{L}(\matrix{C})$.

Finally, output parameter {\sf C} is computed from matrix $\matrix{C}$
as specified by descriptor {\sf desc}. (In the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{m}({\sf C}) = \bold{m}(\matrix{C})$ and $\bold{n}({\sf C}) = \bold{n}(\matrix{C})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.
%-----------------------------------------------------------------------------

\subsection{{\sf vxm}: Vector-matrix multiply}

Multiplies a vector by a matrix on an semiring. The result is a vector.

\paragraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_vxm(GrB_Vector              *u,
                         const GrB_Vector         mask,
                         const GrB_BinaryFunction accum,
                         const GrB_Semiring       op,
                         const GrB_Vector         v, 
                         const GrB_Matrix         A
                      [, const GrB_Descriptor     desc])
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf u}]    ({\sf OUTP}) An existing vector to store the result.

    \item[{\sf mask}] ({\sf MASK}) Output mask vector . The mask
    specifies which elements of the result vector can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

	\item[{\sf accum}]  Function used for accumulating entries into existing
                        \vector{u} entries. If no accumulation is desired,
	                    {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]   Semiring used in the vector-matrix multiply.
    \item[{\sf v}]    ({\sf ARG0}) The left-hand vector to be multiplied.
    \item[{\sf A}]    ({\sf ARG1}) The right-hand matrix to be multiplied.

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted. Valid fields are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf OUTP} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}_3({\sf op})$ to $\bold{D}(\vector{u})$.\\
    {\sf MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf mask})$ to {\sf bool} domain. \\
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}(\vector{v})$ to $\bold{D}_1({\sf op})$. \\
    {\sf ARG1} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}(\matrix{A})$ to $\bold{D}_2({\sf op})$. \\
    {\sf ARG1} & {\sf GrB\_TRAN} & Use transpose of {\sf A} for operation. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\scott{General comment for entire document: We should specify anything that we can about the behavior/program state when any error condition is returned.  What guarantees are we giving (think consistency models)?  Definitely related to mutability question earlier.}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among vectors, matrix dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of vectors, matrix, and/or semiring, for which the descriptor did not explicitly allow casting.
\end{itemize}

\paragraph{Description}

Vectors $\vector{v}, \vector{mask}$ and matrix $\matrix{A}$ are computed from
input parameters {\sf v}, {\sf mask} and {\sf A}, respectively, as specified
by descriptor {\sf desc}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting and transposition, can be performed.)  $\bold{D}(\vector{v}) =
\bold{D}_1({\sf op})$ and $\bold{D}(\matrix{A}) = \bold{D}_2({\sf op})$.
$\bold{D}(\vector{mask}) = {\sf GrB\_BOOL}$.  If {\sf mask} is {\sf GrB\_NULL}
then $\vector{mask}$ acts as a Boolean vector of size $\bold{n}(\vector{A})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{mask}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{m}(\matrix{A})$ and $\bold{n}(\vector{m}) =
\bold{n}(\vector{v})$. If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A new vector $\vector{u} = \langle \bold{D}_3({\sf op}),
\bold{n}(\matrix{A}), \bold{L}(\vector{u}) = \{(i,u_i) : \vector{mask}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $u_i = \bigoplus_{j \in \vector{i}(\vector{v}) \cap
\vector{i}(\matrix{A}(:,i))} (\vector{v}(j) \otimes \matrix{A}(j,i))$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operations of semiring {\sf op}, respectively.  If $\vector{i}(\vector{v})
\cap \vector{i}(\matrix{A}(:,i)) = \emptyset$ then the pair $(i,u_i)$
is not included in $\bold{L}(\vector{u})$.

Finally, output parameter {\sf u} is computed from vector $\vector{u}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf u}) = \bold{n}(\vector{u})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.

\scott{We need a more explicit discussion/specification regarding
masks and accumulation and their interaction (perhaps the diagram Manoj
projected at the SC15 BoF.} \jose{Agree. Need to find the proper place
for it.}

%-----------------------------------------------------------------------------

\subsection{{\sf mxv}: Matrix-vector multiply}

Multiplies a matrix by a vector within a semiring. The result is a vector.

\paragraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_mxv(GrB_Vector              *u,
                         const GrB_Vector         mask,
                         const GrB_BinaryFunction accum,
                         const GrB_Semiring       op, 
                         const GrB_Matrix         A,
                         const GrB_Vector         v
                      [, const GrB_Descriptor     desc])
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf u}]    ({\sf OUTP}) An existing vector to store the result.
    
    \item[{\sf mask}] ({\sf MASK}) Output mask vector . The mask
    specifies which elements of the result vector can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

	\item[{\sf accum}]  Function used for accumulating entries into existing
                        \vector{u} entries. If no accumulation is desired,
	                    {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]   Semiring used in the matrix-vector multiply.
    \item[{\sf A}]    ({\sf ARG0}) The left-hand matrix to be multiplied.
    \item[{\sf v}]    ({\sf ARG1}) The right-hand vector to be multiplied.

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted. Valid fields are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf OUTP} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}_3({\sf op})$ to $\bold{D}(\vector{u})$.\\
    {\sf MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf mask})$ to {\sf bool} domain. \\
    {\sf ARG0} & {\sf GrB\_TRAN} & Use transpose of {\sf A} for operation. \\
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}(\matrix{A})$ to $\bold{D}_1({\sf op})$. \\
    {\sf ARG1} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}(\vector{v})$ to $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among vectors, matrix dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of vectors, matrix, and/or semiring, for which the descriptor did not explicitly allow casting.
\end{itemize}


\paragraph{Description}

Vectors $\vector{v}, \vector{mask}$ and matrix $\matrix{A}$ are computed from
input parameters {\sf v}, {\sf mask} and {\sf A}, respectively, as specified
by descriptor {\sf desc}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting and transposition, can be performed.)  $\bold{D}(\vector{v}) =
\bold{D}_1({\sf op})$ and $\bold{D}(\matrix{A}) = \bold{D}_2({\sf op})$.
$\bold{D}(\vector{mask}) = {\sf GrB\_BOOL}$.  If {\sf mask} is {\sf GrB\_NULL} or omitted,
then $\vector{mask}$ is a Boolean vector of size $\bold{m}(\vector{A})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{mask}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{n}(\matrix{A})$ and $\bold{n}(\vector{mask}) =
\bold{m}(\vector{v})$. If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A new vector $\vector{u} = \langle \bold{D}_3({\sf op}),
\bold{m}(\matrix{A}), \bold{L}(\vector{u}) = \{(i,u_i) : \vector{mask}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $u_i = \bigoplus_{j \in \vector{i}(\vector{v}) \cap
\vector{i}(\matrix{A}(i,:))} (\matrix{A}(i,j)) \otimes \vector{v}(j)$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operations of semiring {\sf op}, respectively.  If $\vector{i}(\vector{v})
\cap \vector{i}(\matrix{A}(:,i)) = \emptyset$ then the pair $(i,u_i)$
is not included in $\bold{L}(\vector{u})$.

Finally, output parameter {\sf u} is computed from vector $\vector{u}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf u}) = \bold{n}(\vector{u})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.
