\subsubsection{{\sf mXm}: Matrix-matrix multiply}

Placeholder

\aydin{Aydin to fill}

\paragraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_mXm(GrB_Matrix               C,
                         const GrB_Semiring       sr,
                         const GrB_Matrix         A, 
                         const GrB_Matrix         B
                      [, const GrB_MaskMatrix     mask
                      [, const GrB_Descriptor     desc
                      [, const GrB_BinaryFunction accum]]])
\end{verbatim}

%-----------------------------------------------------------------------------

\subsubsection{{\sf vXm}: Vector-matrix multiply}

Multiplies a vector by a matrix within an semiring. The result is a vector.

\paragraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_vXm(GrB_Vector               u,
                         const GrB_Semiring       sr,
                         const GrB_Vector         v, 
                         const GrB_Matrix         A
                      [, const GrB_MaskVector     mask
                      [, const GrB_Descriptor     desc
                      [, const GrB_BinaryFunction accum]]])
\end{verbatim}

\paragraph{Input Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf u}]    ({\sf OUTP}) An existing vector to store the result.
    \item[{\sf sr}]   ({\sf ARG0}) Semiring used in the vector-matrix multiply.
    \item[{\sf v}]    ({\sf ARG1}) The left-hand vector to be multiplied.
    \item[{\sf A}]    ({\sf ARG2}) The right-hand matrix to be multiplied.

    \item[{\sf mask}] ({\sf MASK}) Output mask vector (optional). The mask
    specifies which elements of the result vector can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} can be used or the mask can be omitted.

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted. Valid fields are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf OUTP} & {\sf GrB\_CAST} & Allow casting from semiring D3 to {\sf u}'s domain. \\
    {\sf ARG1} & {\sf GrB\_CAST} & Allow casting from {\sf v}'s domain to semiring D1. \\
    {\sf ARG2} & {\sf GrB\_CAST} & Allow casting from {\sf A}'s domain to semiring D2. \\
    {\sf ARG2} & {\sf GrB\_TRAN} & Use transpose of {\sf A} for operation. \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf ACCUM}& {\sf GrB\_ACC}  & Use the {\sf accum} function to add to existing values in {\sf C}.\\
    \end{tabular}

  	\item[{\sf accum}]  Function used for accumulating entries with existing \vector{u} entries. (optional). 
\end{itemize}

\paragraph{Return Values}

\scott{General comment for entire document: We should specify anything that we can about the behavior/program state when any error condition is returned.  What guarantees are we giving (think consistency models)?  Definitely related to mutability question earlier.}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among vectors, matrix dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of vectors, matrix, and/or semiring, for which the descriptor did not explicitly allow casting.
\end{itemize}

\paragraph{Description}

Vectors $\vector{v}, \vector{m}$ and matrix $\matrix{A}$ are computed from
input parameters {\sf v}, {\sf mask} and {\sf A}, respectively, as specified
by descriptor {\sf desc}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting, can be specified.)  $\bold{D}(\vector{v}) =
\bold{D}_1({\sf s})$ and $\bold{D}(\matrix{A}) = \bold{D}_2({\sf s})$.
$\bold{D}(\vector{m}) = {\sf GrB\_BOOL}$.  If {\sf mask} is {\sf GrB\_NULL}
then $\vector{m}$ acts as a Boolean vector of size $\bold{n}(\vector{A})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{m}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{m}(\matrix{A})$ and $\bold{n}(\vector{m}) =
\bold{n}(\matrix{A})$. If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A new vector $\vector{u} = \langle \bold{D}_3({\sf s}),
\bold{n}(\matrix{A}), \bold{L}(\vector{u}) = \{(i,u_i) : \vector{m}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $u_i = \bigoplus_{j \in \vector{i}(\vector{v}) \cap
\vector{i}(\matrix{A}(:,i))} (\vector{v}(j) \otimes \matrix{A}(j,i))$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operations of semiring {\sf s}, respectively.  If $\vector{i}(\vector{v})
\cap \vector{i}(\matrix{A}(:,i)) = \emptyset$ then the pair $(i,u_i)$
is not included in $\bold{L}(\vector{u})$.

Finally, output parameter {\sf u} is computed from vector $\vector{u}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf u}) = \bold{n}(\vector{u})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.

\scott{We need a more explicit discussion/specification regarding
masks and accumulation and their interaction (perhaps the diagram Manoj
projected at the SC15 BoF.} \jose{Agree. Need to find the proper place
for it.}

%-----------------------------------------------------------------------------

\subsubsection{{\sf mXv}: Matrix-vector multiply}

Multiplies a matrix by a vector within a semiring. The result is a vector.

\paragraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_mXv(GrB_Vector               u,
                         const GrB_Semiring       sr, 
                         const GrB_Matrix         A,
                         const GrB_Vector         v
                      [, const GrB_MaskVector     mask
                      [, const GrB_Descriptor     desc
                      [, const GrB_BinaryFunction accum]]])
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf u}]    ({\sf OUTP}) An existing vector to store the result.
    \item[{\sf sr}]   ({\sf ARG0}) Semiring used in the matrix-vector multiply.
    \item[{\sf A}]    ({\sf ARG1}) The left-hand matrix to be multiplied.
    \item[{\sf v}]    ({\sf ARG2}) The right-hand vector to be multiplied.

    \item[{\sf mask}] ({\sf MASK}) Output mask vector (optional). The mask
    specifies which elements of the result vector can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} can be used or the mask can be omitted.

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted. Valid fields are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf OUTP} & {\sf GrB\_CAST} & Allow casting from semiring D3 to {\sf u}'s domain. \\
    {\sf ARG1} & {\sf GrB\_CAST} & Allow casting from {\sf A}'s domain to semiring D1. \\
    {\sf ARG1} & {\sf GrB\_TRAN} & Use transpose of {\sf A} for operation. \\
    {\sf ARG2} & {\sf GrB\_CAST} & Allow casting from {\sf v}'s domain to semiring D2. \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf ACCUM}& {\sf GrB\_ACC}  & Use the {\sf accum} function to add to existing values in {\sf C}.\\
    \end{tabular}

  	\item[{\sf accum}]  Function used for accumulating entries into existing \vector{u} entries. (optional). 
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among vectors, matrix dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of vectors, matrix, and/or semiring, for which the descriptor did not explicitly allow casting.
\end{itemize}


\paragraph{Description}

Vectors $\vector{v}, \vector{m}$ and matrix $\matrix{A}$ are computed from
input parameters {\sf v}, {\sf m} and {\sf A}, respectively, as specified
by descriptor {\sf d}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting, can be specified.)  $\bold{D}(\vector{v}) =
\bold{D}_1({\sf s})$ and $\bold{D}(\matrix{A}) = \bold{D}_2({\sf s})$.
$\bold{D}(\vector{m}) = {\sf GrB\_BOOL}$.  If {\sf m} is {\sf GrB\_NULL} or omitted,
then $\vector{m}$ is a Boolean vector of size $\bold{n}(\vector{A})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{m}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{n}(\matrix{A})$ and $\bold{n}(\vector{m}) =
\bold{m}(\matrix{A})$. If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A new vector $\vector{u} = \langle \bold{D}_3({\sf s}),
\bold{m}(\matrix{A}), \bold{L}(\vector{u}) = \{(i,u_i) : \vector{m}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $u_i = \bigoplus_{j \in \vector{i}(\vector{v}) \cap
\vector{i}(\matrix{A}(i,:))} (\matrix{A}(i,j)) \otimes \vector{v}(j)$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operations of semiring {\sf s}, respectively.  If $\vector{i}(\vector{v})
\cap \vector{i}(\matrix{A}(:,i)) = \emptyset$ then the pair $(i,u_i)$
is not included in $\bold{L}(\vector{u})$.

Finally, output parameter {\sf u} is computed from vector $\vector{u}$
as specified by descriptor {\sf d}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf u}) = \bold{n}(\vector{u})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.
