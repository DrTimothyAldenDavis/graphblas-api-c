\subsection{{\sf mxm}: Matrix-matrix multiply}

Multiplies a matrix with another matrix on a semiring. The result is a matrix.

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_mxm(GrB_Matrix              *C,
                         const GrB_Matrix         Mask,
                         const GrB_BinaryOp       accum,
                         const GrB_Semiring       op,
                         const GrB_Matrix         A, 
                         const GrB_Matrix         B,
                         const GrB_Descriptor     desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    An existing matrix (of dimensions $m \times n$) to store the result. 

    \item[{\sf Mask}] Output mask matrix of dimensions $m \times n$. 
    The mask specifies which elements of the result matrix,{\sf C}, can be modified. 
    If no mask is necessary (\ie, compute all elements of result
    matrix), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Operator used for accumulating entries into existing
    \matrix{C} entries. If no accumulation is desired,
    {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]   Semiring used in the matrix-matrix multiply: ${\sf op}=\langle D_1,D_2,D_3,\oplus,\otimes,0 \rangle$.
    \item[{\sf A}]    The left-hand matrix to be multiplied.  
    \item[{\sf B}]    The right-hand matrix to be multiplied. 

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    used. Valid fields are as follows: \\ ~\\
    \begin{tabular}{lllp{2.75in}}
    Var. & Field  & Value & Description \\
    \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf C})$ must equal 
                                     $\bold{D}_3({\sf op})$ when {\sf accum} is {\sf GrB\_NULL}; 
                                     otherwise, $\bold{D}({\sf C})$ must equal both 
                                     $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$.\\
    {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf Mask}. \\
               &                 & {\sf GrB\_NOCAST} & $\bold{D}({\sf Mask})$ must equal {\sf GrB\_BOOL}. \\
    {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A} for operation. \\
               &                 & {\sf GrB\_NOCAST} & $\bold{D}({\sf A})$ must equal $\bold{D}_1({\sf op})$. \\
    {\sf B}    & {\sf GrB\_INP1} & {\sf GrB\_TRAN}   & Use transpose of {\sf B} for operation. \\
               &                 & {\sf GrB\_NOCAST} & $\bold{D}({\sf B})$ must equal $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] matrix dimensions are incompatible (including mask).
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    the domains of the various matrices are incompatible (i.e., cannot 
perform the cast) with the corresponding domains of the operands, {\sf op} and {\sf accum}.  
If the descriptor specifies {\sf GrB\_NOCAST} for a given matrix, then this error is returned if 
the domains do not match exactly.
\end{itemize}


\paragraph{Description}

Matrices $\matrix{A}, \matrix{B}$, and $\matrix{Mask}$ are computed from
input parameters {\sf A}, {\sf B} and {\sf Mask}, respectively, as specified
by descriptor {\sf desc}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting and transposing, can be performed.)  $\bold{D}(\matrix{A}) =
\bold{D}_1({\sf op})$ and $\bold{D}(\matrix{B}) = \bold{D}_2({\sf op})$.
$\bold{D}(\matrix{Mask}) = {\sf GrB\_BOOL}$.  If {\sf Mask} is {\sf GrB\_NULL} or omitted,
then $\matrix{Mask}$ is a Boolean matrix of the same dimensions as $\matrix{C}$
and with all elements set to {\sf true}.

If either $\matrix{A}, \matrix{B}$, and $\matrix{Mask}$  cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that dimensions of $\matrix{A}$, $\matrix{B}$
and $\matrix{C}$ are compatible, considering possible transpositions.  If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A consistency check is performed to verify the dimensions of $\matrix{C}$
and $\matrix{Mask}$ agree.  If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A new matrix $\matrix{C} = \langle \bold{D}_3({\sf op}),
\bold{m}(\matrix{A}), \bold{n}(\matrix{B}), \bold{L}(\vector{C}) = \{(i,j,C_{ij}) : \matrix{Mask}(i,j)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $C_{ij} = \bigoplus_{k \in \vector{i}(\matrix{A}(i,:)) \cap
\vector{i}(\matrix{B}(:,j))} (\matrix{A}(i,j) \otimes \matrix{B}(k,j))$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operators of semiring {\sf op}, respectively.  If $\vector{i}(\matrix{A}(i,:)) \cap \vector{i}(\matrix{B}(:,j)) = \emptyset $ then the tuple $(i,j,C_{ij})$
is not included in $\bold{L}(\matrix{C})$.

Finally, output parameter {\sf C} is computed from matrix $\matrix{C}$
as specified by descriptor {\sf desc}. (In the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{m}({\sf C}) = \bold{m}(\matrix{C})$ and $\bold{n}({\sf C}) = \bold{n}(\matrix{C})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.

\paragraph{Alternate Description (WORK IN PROGRESS)}

A consistency check is performed to verify that dimensions of {\sf A}, {\sf B}, {\sf C}
and {\sf Mask} are compatible, considering possible transpositions of {\sf A} and 
{\sf B}.  As an example without transposes, it is verified that 
$\bold{m}({\sf C}) = \bold{m}(\sf A)$ and $\bold{n}({\sf C}) = \bold{n}(\sf B)$. 
A consistency check is also performed to verify that the dimensions of $\sf C$ and 
$\sf Mask$ are the same.  Note, if {\sf Mask} is {\sf GrB\_NULL} or omitted,
then $\matrix{Mask}$ is a Boolean matrix of the same dimensions as $\sf C$
and with all elements set to {\sf true}. If either consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A check is also performed to verify that the domains of the matrices are consistent
with the operations to be performed.  Matrices $\matrix{A}, \matrix{B}$, and 
$\matrix{Mask}$ are computed from input parameters {\sf A}, {\sf B} and {\sf Mask},
respectively, where additional preprocessing such as casting, transposition, and
structural complement could be performed as specified by descriptor, {\sf desc}.
Note that at this point, $\bold{D}(\matrix{A}) = \bold{D}_1({\sf op})$ and 
$\bold{D}(\matrix{B}) = \bold{D}_2({\sf op})$.  Also, $\bold{D}(\matrix{Mask}) = 
{\sf GrB\_BOOL}$.  The operation is aborted and the method returns a {\sf GrB\_DOMAIN\_MISMATCH}
in the following situations:
\begin{itemize}
\item $\bold{D}({\sf A})$ does not equal $\bold{D}_1({\sf op})$ and the descriptor prohibits casting of {\sf GrB\_INP0},
\item $\bold{D}({\sf B})$ does not equal $\bold{D}_2({\sf op})$ and the descriptor prohibits casting of {\sf GrB\_INP1},
\item $\bold{D}({\sf Mask})$ does not equal ${\sf GrB\_BOOL}$ and the descriptor prohibits casting of {\sf GrB\_MASK} (Mask is not {\sf GrB\_NULL},
\item If accumulation operator is NOT present:
        \begin{itemize}
        \item $\bold{D}({\sf C})$ does not equal $\bold{D}_3({\sf op})$ and the descriptor prohibits casting of {\sf GrB\_OUTP},
        \end{itemize}
\item If accumulation operator is present:
        \begin{itemize}
        \item $\bold{D}({\sf C})$ does not equal $\langle \bold{D}_3({\sf accum})$ and the descriptor prohibits casting of {\sf GrB\_OUTP}
        \item $\bold{D}({\sf C})$ does not equal $\langle \bold{D}_1({\sf accum})$ and the descriptor prohibits casting of {\sf GrB\_OUTP}
        \item $\bold{D}_3({\sf op})$ does not equal $\langle \bold{D}_2({\sf accum})$
        \end{itemize}
\item Casting is allowed and necessary, for any argument but there is no "defined cast operation" between the two domains.
\end{itemize}



A new matrix $\matrix{C} = \langle \bold{D}_3({\sf op}),
\bold{m}(\matrix{A}), \bold{n}(\matrix{B}), \bold{L}(\vector{C}) = \{(i,j,C_{ij}) : \matrix{Mask}(i,j)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $C_{ij} = \bigoplus_{k \in \vector{i}(\matrix{A}(i,:)) \cap
\vector{i}(\matrix{B}(:,j))} (\matrix{A}(i,j) \otimes \matrix{B}(k,j))$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operators of semiring {\sf op}, respectively.  If $\vector{i}(\matrix{A}(i,:)) \cap \vector{i}(\matrix{B}(:,j)) = \emptyset $ then the tuple $(i,j,C_{ij})$
is not included in $\bold{L}(\matrix{C})$.

Finally, output parameter {\sf C} is computed from matrix $\matrix{C}$. In the 
simplest case this is just a copy, but the {\sf accum} and {\sf desc} parameters can
specify additional postprocessing, including casting and accumulation of result
values.


%-----------------------------------------------------------------------------

\subsection{{\sf vxm}: Vector-matrix multiply}

Multiplies a vector by a matrix on an semiring. The result is a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_vxm(GrB_Vector            *u,
                         const GrB_Vector       mask,
                         const GrB_BinaryOp     accum,
                         const GrB_Semiring     op,
                         const GrB_Vector       v, 
                         const GrB_Matrix       A,
                         const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf u}]    ({\sf GrB\_OUTP}) An existing vector to store the result.

    \item[{\sf mask}] ({\sf GrB\_MASK}) Output mask vector . The mask
    specifies which elements of the result vector can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Operator used for accumulating entries into existing
                        \vector{u} entries. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]   Semiring used in the vector-matrix multiply.
    \item[{\sf v}]    ({\sf GrB\_INP0}) The left-hand vector to be multiplied.
    \item[{\sf A}]    ({\sf GrB\_INP1}) The right-hand matrix to be multiplied.

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted. Valid fields are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
    {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf u})$ must equal $\bold{D}_3({\sf op})$
                                          when {\sf accum} is {\sf GrB\_NULL}; otherwise, $\bold{D}({\sf u})$
                                          must equal both $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$.\\
    {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf mask})$ must equal {\sf GrB\_BOOL}. \\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf v})$ must equal $\bold{D}_1({\sf op})$. \\
    {\sf GrB\_INP1} & {\sf GrB\_TRAN}   & Use transpose of {\sf A} for operation. \\
    {\sf GrB\_INP1} & {\sf GrB\_NOCAST} & $\bold{D}({\sf A})$ must equal $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among vectors, matrix dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of vectors, matrix, and/or semiring, for which the descriptor did not explicitly allow casting.
\end{itemize}

\paragraph{Description}

Vectors $\vector{v}, \vector{mask}$ and matrix $\matrix{A}$ are computed from
input parameters {\sf v}, {\sf mask} and {\sf A}, respectively, as specified
by descriptor {\sf desc}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting and transposition, can be performed.)  $\bold{D}(\vector{v}) =
\bold{D}_1({\sf op})$ and $\bold{D}(\matrix{A}) = \bold{D}_2({\sf op})$.
$\bold{D}(\vector{mask}) = {\sf GrB\_BOOL}$.  If {\sf mask} is {\sf GrB\_NULL}
then $\vector{mask}$ acts as a Boolean vector of size $\bold{n}(\vector{A})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{mask}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{m}(\matrix{A})$ and $\bold{n}(\vector{m}) =
\bold{n}(\vector{v})$. If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A new vector $\vector{u} = \langle \bold{D}_3({\sf op}),
\bold{n}(\matrix{A}), \bold{L}(\vector{u}) = \{(i,u_i) : \vector{mask}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $u_i = \bigoplus_{j \in \vector{i}(\vector{v}) \cap
\vector{i}(\matrix{A}(:,i))} (\vector{v}(j) \otimes \matrix{A}(j,i))$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operator of semiring {\sf op}, respectively.  If $\vector{i}(\vector{v})
\cap \vector{i}(\matrix{A}(:,i)) = \emptyset$ then the pair $(i,u_i)$
is not present in $\bold{L}(\vector{u})$.

Finally, output parameter {\sf u} is computed from vector $\vector{u}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf u}) = \bold{n}(\vector{u})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.

\scott{We need a more explicit discussion/specification regarding
masks and accumulation and their interaction (perhaps the diagram Manoj
projected at the SC15 BoF.} \jose{Agree. Need to find the proper place
for it.}

%-----------------------------------------------------------------------------

\subsection{{\sf mxv}: Matrix-vector multiply}

Multiplies a matrix by a vector within a semiring. The result is a vector.

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_mxv(GrB_Vector            *u,
                         const GrB_Vector       mask,
                         const GrB_BinaryOp     accum,
                         const GrB_Semiring     op, 
                         const GrB_Matrix       A,
                         const GrB_Vector       v,
                         const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf u}]    ({\sf GrB\_OUTP}) An existing vector to store the result.
    
    \item[{\sf mask}] ({\sf GrB\_MASK}) Output mask vector . The mask
    specifies which elements of the result vector can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

	\item[{\sf accum}]  Operator used for accumulating entries into existing
                        \vector{u} entries. If no accumulation is desired,
	                    {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]   Semiring used in the matrix-vector multiply.
    \item[{\sf A}]    ({\sf GrB\_INP0}) The left-hand matrix to be multiplied.
    \item[{\sf v}]    ({\sf GrB\_INP1}) The right-hand vector to be multiplied.

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used. Valid fields are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
    {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf u})$ must equal $\bold{D}_3({\sf op})$
                                          when {\sf accum} is {\sf GrB\_NULL}; otherwise, $\bold{D}({\sf u})$
                                          must equal both $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$.\\
    {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf mask})$ must equal {\sf GrB\_BOOL}. \\
    {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A} for operation. \\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf A})$ must equal $\bold{D}_1({\sf op})$. \\
    {\sf GrB\_INP1} & {\sf GrB\_NOCAST} & $\bold{D}({\sf v})$ must equal $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among vectors, matrix dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of vectors, matrix, and/or semiring, for which the descriptor did not explicitly allow casting.
\end{itemize}


\paragraph{Description}

Vectors $\vector{v}, \vector{mask}$ and matrix $\matrix{A}$ are computed from
input parameters {\sf v}, {\sf mask} and {\sf A}, respectively, as specified
by descriptor {\sf desc}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting and transposition, can be performed.)  $\bold{D}(\vector{v}) =
\bold{D}_1({\sf op})$ and $\bold{D}(\matrix{A}) = \bold{D}_2({\sf op})$.
$\bold{D}(\vector{mask}) = {\sf GrB\_BOOL}$.  If {\sf mask} is {\sf GrB\_NULL} or omitted,
then $\vector{mask}$ is a Boolean vector of size $\bold{m}(\vector{A})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{mask}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{n}(\matrix{A})$ and $\bold{n}(\vector{mask}) =
\bold{n}(\vector{u}) = \bold{m}(\matrix{A})$. If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A new vector $\vector{u} = \langle \bold{D}_3({\sf op}),
\bold{m}(\matrix{A}), \bold{L}(\vector{u}) = \{(i,u_i) : \vector{mask}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $u_i = \bigoplus_{j \in \vector{i}(\vector{v}) \cap
\vector{i}(\matrix{A}(i,:))} (\matrix{A}(i,j)) \otimes \vector{v}(j)$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operators of semiring {\sf op}, respectively.  If $\vector{i}(\vector{v})
\cap \vector{i}(\matrix{A}(i,:)) = \emptyset$ then the pair $(i,u_i)$
is not included in $\bold{L}(\vector{u})$.

Finally, output parameter {\sf u} is computed from vector $\vector{u}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf u}) = \bold{n}(\vector{u})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.
