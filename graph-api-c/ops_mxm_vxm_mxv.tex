\subsubsection{Matrix-matrix multiply ({\sf mXm})}

Placeholder

\aydin{Aydin to fill}


\subsubsection{Vector-matrix multiply ({\sf vXm})}

Multiplies a vector by a matrix within an semiring. The result is a vector.

\paragraph{C99 Syntax}

\begin{verbatim}
#include "GraphBLAS.h"
GrB_info GrB_vxm(GrB_Vector *u, const GrB_Semiring s, const GrB_Vector v, 
                 const GrB_Matrix A[, const GrB_Vector m[, const GrB_Descriptor d]])
\end{verbatim}

\ajy{Should {\sf u} parameter have {\tt restrict} keyword?}
\jose{I don't see the value here. The implementors are free
to specialize the implementation when the matrices and
vectors do not overlap.}

\paragraph{Input Parameters}

\begin{itemize}
	\item[{\sf s}] ({\sf ARG0}) Semiring used in the vector-matrix
	multiply.

	\item[{\sf v}] ({\sf ARG1}) Vector to be multiplied.

	\item[{\sf A}] ({\sf ARG2}) Matrix to be multiplied.

	\item[{\sf m}] ({\sf MASK}) Operation mask (optional). The mask
	specifies which elements of the result vector are to be computed.
	If no mask is necessary (i.e., compute all elements of result
	vector), {\sf GrB\_NULL} can be used or the mask can be omitted.

	\item[{\sf d}] Operation descriptor (optional). The descriptor
	is used to specify details of the operation, such as transpose
	the matrix or not, invert the mask or not (see below). If a
	\emph{default} descriptor is desired, {\sf GrB\_NULL} can be
	used or the descriptor can be omitted.
\end{itemize}

\ajy{Can {\sf v} and {\sf m} refer to the same container?}
\ajy{Should ({\sf u} and {\sf v}) or ({\sf u} and {\sf m} NOT refer to the same container...use restrict?}
\jose{Don't see the value of restricting use at this level. All thse containers
are opaque, which means the implementation has full control. The {\bf Description} below
give a very specific semantics irrespective of overlap.}

\paragraph{Output Parameter}

\begin{itemize}
	\item[{\sf u}] ({\sf OUTP}) Address of result vector.
\end{itemize}

\paragraph{Return Value}

\scott{We should specify anything that we can about the behavior/program state when any error condition is returned.  What guarantees are we giving (think consistency models)?  Definitely related to mutability question earlier.}

\begin{tabular}{rl} 
{\sf GrB\_SUCCESS} 	& operation completed successfully \\
{\sf GrB\_PANIC}	& unknown internal error \\
{\sf GrB\_OUTOFMEM}	& not enough memory available for operation \\
{\sf GrB\_MISMATCH}	& mismatch among vectors, matrix and/or semiring
\end{tabular}

\scott{More return values possible: domain/type mismatches, dimension mismatches}
\jose{How much detail do we want?}
\scott{{\sf DOMAIN\_MISMATCH, DIMENSION\_MISMATCH} at least.}

\paragraph{Description}

Vectors $\vector{v}, \vector{m}$ and matrix $\matrix{A}$ are computed from
input parameters {\sf v}, {\sf m} and {\sf A}, respectively, as specified
by descriptor {\sf d}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting, can be specified.)  $\bold{D}(\vector{v}) =
\bold{D}_1({\sf s})$ and $\bold{D}(\matrix{A}) = \bold{D}_2({\sf s})$.
$\bold{D}(\vector{m}) = {\sf GrB\_BOOL}$.  If {\sf m} is {\sf GrB\_NULL}
then $\vector{m}$ is a Boolean vector of size $\bold{n}(\vector{A})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{m}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{m}(\matrix{A})$ and $\bold{n}(\vector{m}) =
\bold{n}(\matrix{A})$. If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_MISMATCH}.

A new vector $\vector{u} = \langle \bold{D}_3({\sf s}),
\bold{n}(\matrix{A}), \bold{L}(\vector{u}) = \{(i,u_i) : \vector{m}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $u_i = \bigoplus_{j \in \vector{i}(\vector{v}) \cap
\vector{i}(\matrix{A}(:,i))} (\vector{v}(j) \otimes \matrix{A}(j,i))$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operations of semiring {\sf s}, respectively.  If $\vector{i}(\vector{v})
\cap \vector{i}(\matrix{A}(:,i)) = \emptyset$ then the pair $(i,u_i)$
is not included in $\bold{L}(\vector{u})$.

Finally, output parameter {\sf u} is computed from vector $\vector{u}$
as specified by descriptor {\sf d}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf u}) = \bold{n}(\vector{u})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_MISMATCH}.

\scott{We need a more explicit discussion/specification regarding
masks and accumulation and their interaction (perhaps the diagram Manoj
projected at the SC15 BoF.} \jose{Agree. Need to find the proper place
for it.}

\scott{Is accumulation restricted to the use of the $\oplus$ operation
of the {\sf s} argument?  If so, add to the specification.} \jose{Yes,
accumulation is restricted to $\oplus$. Again, need to find the right
place for the specification.}

\subsubsection{Matrix-vector multiply ({\sf mXv})}

Multiplies a matrix by a vector within a semiring. The result is a vector.

\paragraph{C99 Syntax}

\begin{verbatim}
#include "GraphBLAS.h"
GrB_info GrB_mxv(GrB_Vector *u, const GrB_Semiring s, const GrB_Matrix A, 
                 const GrB_vector v[, const GrB_Vector m[, const GrB_Descriptor d]])
\end{verbatim}

\paragraph{Input Parameters}

\begin{itemize}
	\item[{\sf s}] ({\sf ARG0}) Semiring used in the vector-matrix
	multiply.

	\item[{\sf A}] ({\sf ARG1}) Matrix to be multiplied.

	\item[{\sf v}] ({\sf ARG2}) Vector to be multiplied.

	\item[{\sf m}] ({\sf MASK}) Operation mask (optional). The mask
	specifies which elements of the result vector are to be computed.
	If no mask is necessary (i.e., compute all elements of result
	vector), {\sf GrB\_NULL} can be used or the mask can be omitted.

	\item[{\sf d}] Operation descriptor (optional). The descriptor
	is used to specify details of the operation, such as transpose
	the matrix or not, invert the mask or not (see below). If a
	\emph{default} descriptor is desired, {\sf GrB\_NULL} can be
	used or the descriptor can be omitted.
\end{itemize}

\paragraph{Output Parameter}

\begin{itemize}
	\item[{\sf u}] ({\sf OUTP}) Address of result vector.
\end{itemize}

\paragraph{Return Value}

\begin{tabular}{rl} 
{\sf GrB\_SUCCESS} 	& operation completed successfully \\
{\sf GrB\_PANIC}	& unknown internal error \\
{\sf GrB\_OUTOFMEM}	& not enough memory available for operation \\
{\sf GrB\_MISMATCH}	& mismatch among vectors, matrix and/or semiring
\end{tabular}

\paragraph{Description}

Vectors $\vector{v}, \vector{m}$ and matrix $\matrix{A}$ are computed from
input parameters {\sf v}, {\sf m} and {\sf A}, respectively, as specified
by descriptor {\sf d}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting, can be specified.)  $\bold{D}(\vector{v}) =
\bold{D}_1({\sf s})$ and $\bold{D}(\matrix{A}) = \bold{D}_2({\sf s})$.
$\bold{D}(\vector{m}) = {\sf GrB\_BOOL}$.  If {\sf m} is {\sf GrB\_NULL} or omitted,
then $\vector{m}$ is a Boolean vector of size $\bold{n}(\vector{A})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{m}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{n}(\matrix{A})$ and $\bold{n}(\vector{m}) =
\bold{m}(\matrix{A})$. If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_MISMATCH}.

A new vector $\vector{u} = \langle \bold{D}_3({\sf s}),
\bold{m}(\matrix{A}), \bold{L}(\vector{u}) = \{(i,u_i) : \vector{m}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its elements
is computed by $u_i = \bigoplus_{j \in \vector{i}(\vector{v}) \cap
\vector{i}(\matrix{A}(i,:))} (\matrix{A}(i,j)) \otimes \vector{v}(j)$,
where $\oplus$ and $\otimes$ are the additive and multiplicative
operations of semiring {\sf s}, respectively.  If $\vector{i}(\vector{v})
\cap \vector{i}(\matrix{A}(:,i)) = \emptyset$ then the pair $(i,u_i)$
is not included in $\bold{L}(\vector{u})$.

Finally, output parameter {\sf u} is computed from vector $\vector{u}$
as specified by descriptor {\sf d}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf u}) = \bold{n}(\vector{u})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_MISMATCH}.
