
%-----------------------------------------------------------------------------
%-----------------------------------------------------------------------------

\subsection*{4.3.10 {\sf reduce}: Perform a reduction across the elements of an object}

%-----------------------------------------------------------------------------

\subsubsection*{4.3.10.2 {\sf reduce}: Vector-scalar variant}
%\label{Sec:Reduce_vector_scalar}

Reduce all stored values into a single scalar.

\paragraph{\syntax}

\begin{verbatim}
        // scalar value + monoid (only)
        GrB_Info GrB_reduce(<type>               *val,
                            const GrB_BinaryOp    accum,
                            const GrB_Monoid      op,
                            const GrB_Vector      u,
                            const GrB_Descriptor  desc);

        // GraphBLAS Scalar + monoid
        GrB_Info GrB_reduce(GrB_Scalar            s,
                            const GrB_BinaryOp    accum,
                            const GrB_Monoid      op,
                            const GrB_Vector      u,
                            const GrB_Descriptor  desc);

        // GraphBLAS Scalar + binary operator
        GrB_Info GrB_reduce(GrB_Scalar            s,
                            const GrB_BinaryOp    accum,
                            const GrB_BinaryOp    op,
                            const GrB_Vector      u,
                            const GrB_Descriptor  desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf val} or {\sf s}] ({\sf INOUT}) Scalar to store final reduced value into. On input,
    the scalar provides a value that may be accumulated (optionally) with the result of the
    reduction operation.  On output, this scalar holds the results of the
    operation.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf s} value. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) The monoid ($M = \langle D,\oplus,0 \rangle$) or binary operator 
    ($F_b = \langle D, D, D, \oplus \rangle$) used in the reduction operation. The $\oplus$ operator 
    must be commutative and associative; otherwise, the outcome of the operation is undefined.  
    \scott{Note the restrictions on the domains of the binary operator $F_b = \langle D, D, D, \oplus \rangle$, plus lots of complaining from the implementors about the use of binary ops/lack of identity leading to poor performance.}
    
    \item[{\sf u}]     ({\sf IN}) The GraphBLAS vector on which
    reduction will be performed.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
    \end{tabular}

    \emph{Note:} This argument is defined for consistency with the other GraphBLAS operations.
    There are currently no non-default field/value pairs that can be set for this operation.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking or non-blocking mode, 
    the operation completed successfully, and the
    output scalar {\sf s} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for the operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to a respective constructor.

    \item[{\sf GrB\_NULL\_POINTER}]  {\sf val} pointer is {\sf NULL}.
    
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of input and output arguments are
    incompatible with the corresponding domains of the accumulation operator, 
    or reduce operator.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_reduce} computes the result of performing a reduction
across all of the stored elements of an input vector storing the result into either
{\sf s} or {\sf val}.  This corresponds to (shown here for the scalar value case only):
\begin{equation*}
{\sf val} ~ = 
  \begin{cases}
     \hspace{3.7em} \bigoplus_{i \in \mathbf{ind}({\sf u})} {\sf u}(i) \text{,~~~ or} \\& \\
    {\sf val} ~\odot~ \left[ \bigoplus_{i \in \mathbf{ind}({\sf u})} {\sf u}(i)\right], \text{~if the the optional accumulator is specified.} 
  \end{cases}
\end{equation*}
where $\bigoplus = \bigodot({\sf op})$ and $\odot = \bigodot({\sf accum})$.  

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.85in]
\item[\bf Setup] The internal vector used in the computation is formed 
and its domain is tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output scalar.
\end{enumerate}

One vector argument is used in this {\sf GrB\_reduce} operation:
\begin{enumerate}
	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),
    \bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

The output scalar, argument vector, reduction operator and accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf val})$ or $\bold{D}({\sf s})$ must be
    compatible with $\bold{D}({\sf op})$ from $M$ {\color{red} (or with $\bDin1({\sf op})$ and 
    $\bDin2({\sf op})$ from $F_b$)}.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf val})$ or $\bold{D}({\sf s})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator, and 
    $\bold{D}({\sf op})$ from $M$ {\color{red} (or $\bDout({\sf op})$ from $F_b$)} must be compatible 
    with $\bDin2({\sf accum})$ of the accumulation operator.

	\item $\bold{D}({\sf u})$ must be compatible with $\bold{D}({\sf op})$ from $M$ {\color{red} 
    (or with $\bDin1({\sf op})$ and $\bDin2({\sf op})$ from $F_b$)}.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_reduce} ends and 
the domain mismatch error listed above is returned.

The number of values stored in the input, {\sf u}, is checked.  If there are no stored values in {\sf u}, then one of the following occurs depending on the output variant:
\[ 
{\sf {\bf L}(s)} =
\begin{cases}
    \{\}, & \mbox{(cleared) if {\sf accum} = {\sf GrB\_NULL}}, ~~\\ & \\
    {\sf {\bf L}(s)}, ~~~ ~~~~~~~ & \mbox{(unchanged) otherwise,}
\end{cases}
\]
or
\[ 
{\sf val} =
\begin{cases}
    \bold{0}({\sf op}), & \mbox{(cleared) if {\sf accum} = {\sf GrB\_NULL}}, \\ & \\
    {\sf val}{\color{red} ~\odot~ {\bf 0}({\sf op})}, & \mbox{{\color{red}(unchanged?)} otherwise,}
\end{cases}
\]
where $\bold{0}({\sf op})$ is the identity of the monoid. The operation returns immediately with {\sf GrB\_SUCCESS}.

For all other cases, the internal vector and scalar used in 
the computation is formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
    \item Scalar $\scalar{\tilde{s}} \leftarrow {\sf s}$ (GraphBLAS scalar case).
\end{enumerate}
% Note that these copies are not really necessary as aliasing cannot really happen 
% but this section is here to be consistent with the format of other operations.

We are now ready to carry out the reduce and any additional associated operations.  
An intermediate scalar result $t$ is computed as follows:
\[ 
t ~ = ~
    \bigoplus\limits_{i \in \bold{ind}(\vector{\widetilde{u}})} \vector{\widetilde{u}}(i),
\]
where $\oplus = \bigodot({\sf op})$.

The final reduction value is computed as follows:
\[
{\sf {\bf L}(s)} \leftarrow
    \begin{cases}
    \{ t \}, \text{ when {\sf accum = GrB\_NULL} or {\sf s} is empty, or} \\ & \\
    \{ {\bf val}(\tilde{s}) ~\odot ~ t \}, \text{otherwise;} \\
    \end{cases}
\]
or 
\[
{\sf val} \leftarrow
    \begin{cases}
    t, \text{ when {\sf accum = GrB\_NULL}, or} \hspace*{0.95in} \\ & \\
    {\sf val} ~\odot ~t, \text{otherwise;} \\
    \end{cases}
\]

In both {\sf GrB\_BLOCKING} and {\sf GrB\_NONBLOCKING} modes, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of the output scalar is as defined above.


%-----------------------------------------------------------------------------

\subsubsection*{4.3.10.3 {\sf reduce}: Matrix-scalar variant}
%\label{Sec:Reduce_matrix_scalar}

Reduce all stored values into a single scalar.

\paragraph{\syntax}

\begin{verbatim}
        // scalar value + monoid (only)
        GrB_Info GrB_reduce(<type>               *s,
                            const GrB_BinaryOp    accum,
                            const GrB_Monoid      op,
                            const GrB_Matrix      A,
                            const GrB_Descriptor  desc);

        // GraphBLAS Scalar + monoid
        GrB_Info GrB_reduce(GrB_Scalar            s,
                            const GrB_BinaryOp    accum,
                            const GrB_Monoid      op,
                            const GrB_Matrix      A,
                            const GrB_Descriptor  desc);

        // GraphBLAS Scalar + binary operator
        GrB_Info GrB_reduce(GrB_Scalar            s,
                            const GrB_BinaryOp    accum,
                            const GrB_BinaryOp    op,
                            const GrB_Matrix      A,
                            const GrB_Descriptor  desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf val} or {\sf s}] ({\sf INOUT}) Scalar to store final reduced value into. On input,
    the scalar provides a value that may be accumulated (optionally) with the result of the
    reduction operation.  On output, this scalar holds the results of the
    operation.

    \item[{\sf accum}] ({\sf IN}) An optional binary operator used for accumulating
    entries into existing {\sf s} value. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) The monoid ($M = \langle D,\oplus,0 \rangle$) or binary operator 
    ($F_b = \langle D, D, D, \oplus \rangle$) used in the reduction operation. The $\oplus$ operator 
    must be commutative and associative; otherwise, the outcome of the operation is undefined.  
    \scott{Note the restrictions on the domains of the binary operator $F_b = \langle D, D, D, \oplus \rangle$, plus lots of complaining from the implementors about the use of binary ops/lack of identity leading to poor performance.}
    
    \item[{\sf A}]     ({\sf IN}) The GraphBLAS matrix on which
    reduction will be performed.

    \item[{\sf desc}] ({\sf IN}) An optional operation descriptor. If
    a \emph{default} descriptor is desired, {\sf GrB\_NULL} should be
    specified. Non-default field/value pairs are listed as follows:  \\

    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
    \end{tabular}

    \emph{Note:} This argument is defined for consistency with the other GraphBLAS operations.
    There are currently no non-default field/value pairs that can be set for this operation.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking or non-blocking mode, 
    the operation completed successfully, and the
    output scalar {\sf s} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.

    \item[{\sf GrB\_INVALID\_OBJECT}] This is returned in any execution mode 
    whenever one of the opaque GraphBLAS objects (input or output) is in an invalid 
    state caused by a previous execution error.  Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}] Not enough memory available for the operation.

    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to a respective constructor.

    \item[{\sf GrB\_NULL\_POINTER}]  {\sf val} pointer is {\sf NULL}.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of input and output arguments are
    incompatible with the corresponding domains of the accumulation operator, 
    or reduce operator.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_reduce} computes the result of performing
a reduction across all of the stored elements of an input matrixstoring the result into either
{\sf s} or {\sf val}.  This corresponds to (shown here for the scalar value case only):
\begin{equation*}
{\sf val} ~ = 
  \begin{cases}
     \hspace{3.7em} \bigoplus_{(i, j) \in \mathbf{ind}({\sf A})} {\sf A}(i, j) \text{,~~~ or} \\& \\
    {\sf val} ~\odot~ \left[ \bigoplus_{(i, j) \in \mathbf{ind}({\sf A})} {\sf A}(i, j)\right], \text{~if the the optional accumulator is specified.} 
  \end{cases}
\end{equation*}
where $\bigoplus = \bigodot({\sf op})$ and $\odot = \bigodot({\sf accum})$.  

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.85in]
\item[\bf Setup] The internal matrix used in the computation is formed 
and its domain is tested for compatibility.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output scalar.
\end{enumerate}

One matrix argument is used in this {\sf GrB\_reduce} operation:
\begin{enumerate}
	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{size}({\sf A}),
    \bold{L}({\sf A}) = \{(i,j,A_{i,j}) \} \rangle$
\end{enumerate}

The output scalar, argument matrix, reduction operator and accumulation 
operator (if provided) are tested for domain compatibility as follows:
\begin{enumerate}

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf val})$ or $\bold{D}({\sf s})$ must be
    compatible with $\bold{D}({\sf op})$ from $M$ {\color{red} (or with $\bDin1({\sf op})$ and 
    $\bDin2({\sf op})$ from $F_b$)}.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf val})$ or $\bold{D}({\sf s})$ must be
    compatible with $\bDin1({\sf accum})$ and $\bDout({\sf accum})$ of the accumulation operator, and 
    $\bold{D}({\sf op})$ from $M$ {\color{red} (or $\bDout({\sf op})$ from $F_b$)} must be compatible 
    with $\bDin2({\sf accum})$ of the accumulation operator.

	\item $\bold{D}({\sf A})$ must be compatible with $\bold{D}({\sf op})$ from $M$ {\color{red} 
    (or with $\bDin1({\sf op})$ and $\bDin2({\sf op})$ from $F_b$)}.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any compatibility rule above is violated, execution of {\sf GrB\_reduce} ends and 
the domain mismatch error listed above is returned.

The number of values stored in the input, {\sf A}, is checked.  If there are no stored values in {\sf A}, then one of the following occurs depending on the output variant:
\[ 
{\sf {\bf L}(s)} =
\begin{cases}
    \{\}, & \mbox{(cleared) if {\sf accum} = {\sf GrB\_NULL}}, ~~\\ & \\
    {\sf {\bf L}(s)}, ~~~ ~~~~~~~ & \mbox{(unchanged) otherwise,}
\end{cases}
\]
or
\[ 
{\sf val} =
\begin{cases}
    \bold{0}({\sf op}), & \mbox{(cleared) if {\sf accum} = {\sf GrB\_NULL}}, \\ & \\
    {\sf val}{\color{red} ~\odot~ {\bf 0}({\sf op})}, & \mbox{{\color{red}(unchanged?)} otherwise,}
\end{cases}
\]
where $\bold{0}({\sf op})$ is the identity of the monoid. The operation returns immediately with {\sf GrB\_SUCCESS}.

For all other cases, the internal matrix and scalar used in 
the computation is formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Matrix $\matrix{\widetilde{A}} \leftarrow {\sf A}$.
    \item Scalar $\scalar{\tilde{s}} \leftarrow {\sf s}$ (GraphBLAS scalar case).
\end{enumerate}
% Note that these copies are not really necessary as aliasing cannot really happen 
% but this section is here to be consistent with the format of other operations.

We are now ready to carry out the reduce and any additional associated operations.  
An intermediate scalar result $t$ is computed as follows:
\[ 
t ~ = ~
    \bigoplus\limits_{(i, j) \in \bold{ind}(\matrix{\widetilde{A}})} \matrix{\widetilde{A}}(i, j),
\]
where $\oplus = \bigodot({\sf op})$.

The final reduction value is computed as follows:
\[
{\sf {\bf L}(s)} \leftarrow
    \begin{cases}
    \{ t \}, \text{ when {\sf accum = GrB\_NULL} or {\sf s} is empty, or} \\ & \\
    \{ {\bf val}(\tilde{s}) ~\odot ~ t \}, \text{otherwise;} \\
    \end{cases}
\]
or 
\[
{\sf val} \leftarrow
    \begin{cases}
    t, \text{ when {\sf accum = GrB\_NULL}, or} \hspace*{0.95in} \\ & \\
    {\sf val} ~\odot ~t, \text{otherwise;} \\
    \end{cases}
\]

In both {\sf GrB\_BLOCKING} and {\sf GrB\_NONBLOCKING} modes, the method exits with return value 
{\sf GrB\_SUCCESS} and the new contents of the output scalar is as defined above.

