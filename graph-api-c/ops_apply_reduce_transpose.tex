\subsubsection{Apply a unary function to the elements of a matrix ({\sf apply})}

Placeholder

\subsubsection{Perform a reduction across the elements of an object ({\sf reduce})}

Computes the reduction of the values of the elements of a vector or matrix.

\paragraph{Vector variant}

\subparagraph{C99 Syntax}

\begin{verbatim}
#include "GraphBLAS.h"
GrB_info GrB_reduce(scalar *t, const GrB_Semiring s, const GrB_Vector v
                    [, const GrB_Descriptor d])
GrB_info GrB_reduce(scalar *t, const GrB_Monoid s, const GrB_Vector v
                    [, const GrB_Descriptor d])
\end{verbatim}

\comment{
\scott{Should we use the space/semiring in place of the {\sf f} parameter
and just use the $\oplus$ or if an semiring consists of monoids this is
another place where a Monoid is appropriate.  Note that we must know the
identity value for the operation in order to store the correct value in
the scalar if the vector that you are reducing has not stored values.}
\jose{Yes, we should. Changed.}\scott{OK TO REMOVE}
}

\scott{Now we shift to the conversation about whether s is replaced with a
"relaxed monoid" or "binary function + identity"}

\subparagraph{Input Parameters}

\begin{itemize}
	\item[{\sf v}] Vector to be reduced.
	\item[{\sf s}] Semiring/monoid defining the reduction.
	\item[{\sf d}] Operation descriptor (optional).
\end{itemize}

\subparagraph{Output Parameters}

\begin{itemize}
	\item[{\sf t}] Value of the reduction. It must
	be a pointer to one of the types in 
	the left column of Table~\ref{Tab:PredefinedTypes} or
	{\tt void*}.
\end{itemize}

\subparagraph{Return Value}

\begin{tabular}{rl}
{\sf GrB\_SUCCESS}	& operation completed successfully \\
{\sf GrB\_PANIC}	& unknown internal error \\
{\sf GrB\_NOVECTOR}	& vector does not exist \\
{\sf GrB\_MISMATCH}	& mismatch between vector domain, scalar type or semiring/monoid \\
\end{tabular}

\subparagraph{Description}

Let $0 = \bold{0}({\sf s})$, whether ${\sf s}$ is a semiring or monoid.
Let $\oplus = \bigoplus({\sf s})$.

We must have $\bold{D}_3({\sf s}) = \bold{D}_1({\sf s})$.
Otherwise, the method returns {\sf GrB\_MISMATCH}.

Vector $\vector{v}$ is computed from input parameter ${\sf v}$ as
specified by descriptor {\sf d}. $\bold{D}(\vector{v}) = \bold{D}_2({\sf s})$
and $\bold{n}(\vector{v}) = \bold{n}({\sf v})$. If $\vector{v}$ cannot be computed
from the input parameters, the method returns {\sf GrB\_MISMATCH}.

A scalar variable $t$ such that $\bold{D}(t) = \bold{D_1}({\sf s})$ is
created and initialized $t \leftarrow \bold{0}({\sf s})$. 
We then compute the recurrence $t \leftarrow t \oplus v_i, \forall i \in \vector{i}(\vector{v})$.

Finally, output parameter {\sf t} is computed from scalar $t$.



\paragraph{Matrix variant}

Placeholder

\aydin{Aydin to fill}

%=========================================================================

\subsubsection{Transpose rows and columns of a matrix ({\sf transpose})}

{\scott If we adopt the concept of a vector having only one index and conventional orientation of column, then there is no materialized transpose for vector. For vector transpose only makes sense in the context of other operations.}

%-----------------------------------------------------------------------------
\paragraph{Standard Matrix Variant}

This version materializes a new matrix that is the transpose of the source matrix.

\subparagraph{C99 Syntax}

\begin{verbatim}
GrB_info GrB_transpose(GrB_Matrix *dst, const GrB_Function accum,
                       const GrB_Matrix src[, const GrB_Descriptor desc]);
\end{verbatim}

\subparagraph{Input Parameters}

\begin{itemize}
	\item[{\sf dst}]   ({\sf ARG0}) The matrix to assign the result.
	\item[{\sf accum}] ({\sf ARG1}) Function used for accumulation into dst.  {\sf GrB\_NULL}
                       can be used if no accumulation into dst is desired.
	\item[{\sf src}]   ({\sf ARG2}) The matrix to transpose.

	\item[{\sf desc}]  Operation descriptor (optional). The descriptor
    is used to specify details of the operation. Valid options are 
    invert (structural complement) of src ({\sf ARG2}). If
    a \emph{default} descriptor is desired,	{\sf GrB\_NULL} can be
    used or the descriptor can be omitted. Note that transpose of {\sf ARG2} using
	the descriptor will be ignored.(?).
\end{itemize}

\subparagraph{Return Value}

\scott{Are invalid/unused descriptors an error or ignored?}

\begin{tabular}{rl}
{\sf GrB\_SUCCESS}	& operation completed successfully \\
{\sf GrB\_PANIC}	& unknown internal error \\
{\sf GrB\_NOVECTOR}	& vector does not exist \\
{\sf GrB\_DIMENSION\_MISMATCH}	&  
        If the size/shape of dst is not the same\\
      & as the size/shape of the transpose of src. \\
{\sf GrB\_DOMAIN\_MISMATCH} &  
	    domain mismatch among matrices and/or \\
      & accum function \scott{elaborate}
\end{tabular}

\subparagraph{Description}

The dst matrix must have already been created with the proper dimensions
prior to calling this function.  Stored values are inserted into dst to
create a transpose of the src matrix where 
$dst(j,i) = src(i,j) \forall i,j where src(i,j) \neq 0$.

\scott{what happens when src is negated?}

\scott{What happens if accum is not used and dst is not empty?}


