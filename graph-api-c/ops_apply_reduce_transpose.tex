\subsection{{\sf apply}: Apply a unary function to the elements of an object}

%-----------------------------------------------------------------------------

\subsubsection{{\sf apply}: Vector variant}
\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Vector            *u,
                           const GrB_Vector       mask,
                           const GrB_BinaryOp     accum,
                           const GrB_UnaryOp      op,
                           const GrB_Vector       v,
                           const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf u}]   ({\sf GrB\_OUTP}) The vector to assign the result.

    \item[{\sf mask}] ({\sf GrB\_MASK}) Output mask. The mask
    specifies which elements of {\sf u} can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Operator used for accumulating entries into existing {\sf u} entries. 
			If no accumulation is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    The unary function (operation) to apply to each stored element in {\sf v}.
    \item[{\sf v}]   ({\sf GrB\_INP0}) The vector to apply the function to.
    \item[{\sf desc}]   Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
    {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf u})$ must equal $\bold{D}_2({\sf op})$ when
                                          {\sf accum} is {\sf GrB\_NULL}; otherwise $\bold{D}({\sf u})$
                                          must equal both $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
    {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf mask})$ must equal {\sf GrB\_BOOL}. \\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf v})$ must equal $\bold{D}_1({\sf op})$.\\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_DIMENSION\_MISMATCH}]            
        If the size of {\sf u} is not the same as either {\sf mask} or {\sf v}
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrices, unary function, and/or
        accum function \scott{elaborate}
\end{itemize}

\paragraph{Description}

The {\sf u} vector must have already been created with the proper dimensions
prior to calling this function.  The unary operator computes over stored values in {\sf v} and the results are assigned to corresponding location in {\sf u}.
The results of the unary function can be optionally accumulated with existing values in {\sf u} using {\sf accum}.  Assignment into {\sf u} can be optionally masked.

%--------------------------------------------------------------

\subsubsection{{\sf apply}: Matrix variant}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Matrix             *C,
                           const GrB_Matrix        Mask,
                           const GrB_BinaryOp      accum,
                           const GrB_UnaryOp       op,
                           const GrB_Matrix        A,
                           const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]     ({\sf GrB\_OUTP}) The matrix to assign the result.

    \item[{\sf mask}]  ({\sf GrB\_MASK}) Output mask. The mask
    specifies which elements of {\sf C} can be modified.
    If no mask is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Operator used for accumulating entries into existing {\sf C} entries. 
			If no accumulation is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    The unary function (operation) to apply to each stored element in {\sf A}.
    \item[{\sf A}]     ({\sf GrB\_INP0}) The matrix to apply the function to.
    \item[{\sf desc}]  Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
    {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf C})$ must equal $\bold{D}_2({\sf op})$ when
                                          {\sf accum} is {\sf GrB\_NULL}; otherwise $\bold{D}({\sf C})$
                                          must equal both $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
    {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf Mask}. \\
    {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf Mask})$ must equal {\sf GrB\_BOOL}. \\
    {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use the transpose {\sf A} for the operation.\\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf A})$ must equal $\bold{D}_1({\sf op})$.\\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_DIMENSION\_MISMATCH}]            
        If the size/shape of {\sf C} is not the same as either {\sf Mask} or {\sf A} (or its transpose if specified).
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrices, unary function, and/or
        accum function \scott{elaborate}
\end{itemize}

\paragraph{Description}

The {\sf C} matrix must have already been created with the proper dimensions
prior to calling this function.  The unary operator computes on stored values in {\sf A} and the results are assigned to corresponding location in {\sf C}.
The input matrix, {\sf A}, can be optionally transposed first.  The results of the unary function can be optionally accumulated with existing values in {\sf C} using accum.  Assignment into {\sf C} can be optionally masked.

%=========================================================================

\subsection{{\sf reduce}: Perform a reduction across the elements of an object}

Computes the reduction of the values of the elements of a vector or matrix.

%-----------------------------------------------------------------------------
\subsubsection{{\sf reduce}: Matrix to vector variant}

This performs a row-wise reduction of a matrix to produce a vector.  If column-wise reduction
is desired, the input matrix should be transposed which can be specified using the descriptor.

\paragraph{\syntax}

\begin{verbatim}
        // Using a Monoid
        GrB_Info GrB_reduce(GrB_Vector            *u,
                            const GrB_Vector       mask,
                            const GrB_BinaryOp     accum,
                            const GrB_Monoid       op,  
                            const GrB_Matrix       A,
                            const GrB_Descriptor   desc);
                            
        // Using a BinaryOp
        GrB_Info GrB_reduce(GrB_Vector            *u,
                            const GrB_Vector       mask,
                            const GrB_BinaryOp     accum,
                            const GrB_BinaryOp     op,  
                            const GrB_Matrix       A,
                            const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf u}]   ({\sf GrB\_OUTP}) Vector/Matrix to be assigned.

    \item[{\sf mask}] ({\sf GrB\_MASK}) Output mask. The mask specifies which elements
    of {\sf u} can be modified. If no mask is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] Operator used for accumulation into {\sf u}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    Operator used to perform the reduction of elements from {\sf A}.  If a Monoid is specified, its binary operator is used.
    \item[{\sf A}]     ({\sf GrB\_INP0}) The matrix on which to operate.

    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
    {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & When {\sf accum} is {\sf GrB\_NULL}, $\bold{D}({\sf u})$ must
                                          equal $\bold{D}({\sf op})$ when {\sf op} is a Monoid or 
                                          $\bold{D}_3({\sf op})$ when {\sf op} is a BinaryOp. \\
                    &                   & When {\sf accum} is not {\sf GrB\_NULL}, $\bold{D}({\sf u})$
                                          must equal both $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
    {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf mask})$ must equal {\sf GrB\_BOOL}. \\
    {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use the transpose of {\sf A} resulting in a 
    column-wise reduction. \\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & When {\sf op} is a Monoid, $\bold{D}(\matrix{A})$
                                          must equal $\bold{D}({\sf op})$.\\
                    &                   & When {\sf op} is a BinaryOp, $\bold{D}(\matrix{A})$ must equal
                                          both $\bold{D}_1({\sf op})$ and $\bold{D}_2({\sf op})$.\\
    \end{tabular}

\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]    operation completed successfully.
\item[{\sf GrB\_PANIC}]      unknown internal error.
\item[{\sf GrB\_DIMENSION\_MISMATCH}]            
        If the size of {\sf u} is not the same as {\sf mask} or $\bold{m}({\sf A})$ (or its transpose if specified).
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrices, operator, or
        accum function \scott{elaborate}
\end{itemize}


\paragraph{Description}

Matrix \matrix{A} is computed from input parameter {\sf A} as specified
by descriptor {\sf desc}. Specifically, it computes the (sparse) vector of row ``sums'' if 
GrB\_TRAN  is not set, and the vector of column ``sums'' if GrB\_TRAN  is set. It then
stores this result vector into {\sf u}. $\vector{mask}$ is also computed from input parameter {\sf mask}
as specified by descriptor {\sf desc}.

In its simplest form, when called on a $m$-by-$n$ matrix \matrix{A}, this function returns a vector ${\sf u}$ 
of length $m$. Each entry ${\sf u}(i)$ is the ``sum'' of all entries in the $i$th row of 
{\sf A} with respect to the monoid or BinaryOp {\sf op}. 


A new vector $\vector{u} = \langle \bold{D}_3({\sf op}),
\bold{n}(\matrix{A}), \bold{L}(\vector{u}) = \{(i,u_i) : \vector{mask}(i)
= {\sf true} \} \rangle$ is created.  Let us denote the binary operation of the monoid or BinaryOp {\sf op} by $\oplus$,
then the value of each of $\vector{u}$'s elements
is computed by $ \vector{u}(i) = \matrix{A}(i,0) \oplus \matrix{A}(i,1) \oplus  \ldots \oplus  \matrix{A}(i,n)$.  
 

Finally, output parameter {\sf u} is computed from vector $\vector{u}$
as specified by descriptor {\sf desc}. In the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified. 
 If $\vector{u}(i)$ is empty, due to reducing an empty row or column, then the outcome depends on the variable {\sf accum}.
  if {\sf accum} is GrB\_NULL, then ${\sf u}(i)$ is also empty. If {\sf accum} is GrB\_ACCUM, then ${\sf u}(i)$ is unchanged.
A consistency check is
performed to verify that $\bold{n}({\sf u}) = \bold{n}(\vector{u})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.


%-----------------------------------------------------------------------------
\subsubsection{{\sf reduce}: Vector-scalar variants}

Reduce all stored values into a single scalar.

\scott{TODO: do we need to support an input mask for this variant?}

\scott{TODO: Need to have conversation about whether op can/should also take a semiring}

\scott{TODO: Should we support accum in this variant?}


\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_reduce(<type>                *dst,
                            const GrB_BinaryOp     accum,
                            const GrB_Monoid       op,
                            const GrB_Vector       v,
                            const GrB_Descriptor   desc);
\end{verbatim}


\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf dst}]    ({\sf GrB\_OUTP}) Scalar to store final reduced value into.  The type must be
                        consistent with the domain of {\sf v} or {\sf accum} (if used).

    \item[{\sf accum}]  Operator used for accumulation into {\sf dst}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]     ({\sf GrB\_INP0}) Monoid defining the reduction operator.
    \item[{\sf v}]    Vector to be reduced.

    \item[{\sf desc}]   Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
    {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf dst})$ must equal $\bold{D}({\sf op})$ when
                                          {\sf accum} is {\sf GrB\_NULL}; otherwise $\bold{D}({\sf dst})$
                                          must equal both $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf v})$ must equal $\bold{D}({\sf op})$.\\
    \end{tabular}\\
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully.
\item[{\sf GrB\_PANIC}]               unknown internal error.
\item[{\sf GrB\_NOVECTOR}]   {\sf v} vector does not exist
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among vector/matrix, monoid operation, and/or
        accum function, and {\sf dst} \scott{elaborate}
\end{itemize}

\paragraph{Description}

\scott{NEEDS REWRITE}

Let $0 = \bold{0}({\sf op})$, and let $\oplus = \bigodot({\sf op})$ (for monoids).
\scott{Let $\oplus = \bigoplus({\sf op})$ if op is a semiring.}

Vector $\vector{v}$ is computed from input parameter ${\sf v}$ as
specified by descriptor {\sf desc}. If $\vector{v}$ cannot be computed
from the input parameters, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

A scalar variable $s$ such that $\bold{D}(s) = \bold{D_3}({\sf op})$ is
created and initialized $s \leftarrow \bold{0}({\sf op})$. 
We then compute the recurrence $s \leftarrow s \oplus v_i, \forall i \in \vector{i}(\vector{v})$.

Finally, output parameter {\sf dst} is computed from scalar $s$.

%-----------------------------------------------------------------------------
\subsubsection{{\sf reduce}: Matrix-scalar variants}

Reduce all stored values into a single scalar.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_reduce(<type>                *dst,
                            const GrB_BinaryOp     accum,
                            const GrB_Monoid       op,
                            const GrB_Matrix       A,
                            const GrB_Descriptor   desc);
\end{verbatim}


\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf dst}]    ({\sf GrB\_OUTP}) Scalar to store final reduced value into.  The type must be
                        consistent with the domain of {\sf A} or {\sf accum} (if used).

    \item[{\sf accum}]  Operator used for accumulation into {\sf dst}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]     ({\sf GrB\_INP0}) Monoid defining the reduction operator.
    \item[{\sf A}]    Vector/matrix to be reduced.

    \item[{\sf desc}]   Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} isj to be
    used.  Valid fields and values are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
    {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf dst})$ must equal $\bold{D}({\sf op})$ when
                                          {\sf accum} is {\sf GrB\_NULL}; otherwise $\bold{D}({\sf dst})$
                                          must equal both $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf A})$ must equal $\bold{D}({\sf op})$.\\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully.
\item[{\sf GrB\_PANIC}]               unknown internal error.
\item[{\sf GrB\_NOMATRIX}]   {\sf A} matrix does not exist
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrix, monoid operation, and/or
        accum function, and {\sf dst} \scott{elaborate}
\end{itemize}

\paragraph{Description}

\scott{NEEDS REWRITE}

Let $0 = \bold{0}({\sf op})$, and let $\oplus = \bigodot({\sf op})$ (for monoids).
\scott{Let $\oplus = \bigoplus({\sf op})$ if op is a semiring.}

Matrix $\matrix{A}$ is computed from input parameter ${\sf A}$ as
specified by descriptor {\sf desc}. If $\matrix{A}$ cannot be computed
from the input parameters, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

A scalar variable $s$ such that $\bold{D}(s) = \bold{D_3}({\sf op})$ is
created and initialized $s \leftarrow \bold{0}({\sf op})$. 
We then compute the recurrence $s \leftarrow s \oplus A_{ij}, \forall (i, j) \in \bold{L}(\matrix{A})$.

Finally, output parameter {\sf dst} is computed from scalar $s$.

%=========================================================================

\subsection{{\sf transpose}: Transpose rows and columns of a matrix}

This version materializes a new matrix that is the transpose of the source matrix.

\scott{TODO: Need to discuss if we will support dst and src referencing the same matrix
with the meaning that in-place transpose is to be performed. With immutable dimensions
and non-square matrices this should be disallowed or throw a DIMENSION\_MISMATCH.}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_transpose(GrB_Matrix            *C,
                               const GrB_Matrix       Mask,
                               const GrB_BinaryOp     accum,
                               const GrB_Matrix       A,
                               const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]   ({\sf GrB\_OUTP}) The matrix to assign the result.

    \item[{\sf Mask}]  ({\sf GrB\_MASK}) Output mask. The mask specifies which elements
    of {\sf C} can be modified. If no mask is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] Operator used for accumulation into {\sf C}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf A}]   ({\sf GrB\_INP0}) The matrix to transpose.

    \item[{\sf desc}]   Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\
    \begin{tabular}{llp{3in}}
    Field  & Value & Description \\
    \hline
    {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf C})$ must equal $\bold{D}({\sf A})$ when
                                          {\sf accum} is {\sf GrB\_NULL}; otherwise $\bold{D}({\sf C})$
                                          must equal both $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
    {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf Mask}. \\
    {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf Mask})$ must equal {\sf GrB\_BOOL}. \\
    {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf A})$ must equal $\bold{D}({\sf C})$ 
                                          when {\sf accum} is {\sf GrB\_NULL}; otherwise,
                                          $\bold{D}({\sf A})$ must equal $\bold{D}_2({\sf accum})$.
                                          \scott{i.e., there are two ways to specify the former.}\\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_NOMATRIX}]   {\sf A} or {\sf C} matrix does not exist
\item[{\sf GrB\_DIMENSION\_MISMATCH}]      
        If the size/shape of {\sf C} is not the same as either {\sf Mask} or {\sf A} (or its transpose, if specified).
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrices and/or
        accum function \scott{elaborate}
\end{itemize}

\paragraph{Description}

\scott{This needs Jose's touch to get at explicit semantics.}

The {\sf C} matrix must have already been created with the proper dimensions
prior to calling this function.  Stored values are inserted into {\sf C} to
create a transpose of the {\sf A} matrix where 
${\sf C}(j,i) = {\sf A}(i,j) ~ \forall ~ (i,j) \in \bold{L}({\sf A})$.
If accum is specified then the function is used to combine with existing values in {\sf C} using {\sf eWiseAdd} semantics:
${\sf C}(j,i) \oplus = {\sf A}(i,j) ~ \forall ~ (i,j) \in \bold{L}({\sf A})$.
When {\sf Mask} is specified the destination location will only be assigned if the corresponding location in {\sf Mask} has a stored value.
