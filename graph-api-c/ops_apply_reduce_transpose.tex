\subsubsection{{\sf apply}: Apply a unary function to the elements of a matrix}


\subparagraph{C99 Syntax}

\begin{verbatim}
        // Vector version
        GrB_info GrB_apply(GrB_Vector                *dst,
                           const GrB_Vector           src,
                           GrB_UnaryFunction          func
                        [, const GrB_MaskVector       mask
                        [, const GrB_Descriptor       desc
                        [, const GrB_BinaryFunction   accum]]]);

        // Matrix version
        GrB_info GrB_apply(GrB_Matrix                *dst,
                           const GrB_Matrix           src,
                           GrB_UnaryFunction          func
                        [, const GrB_MaskMatrix       mask
                        [, const GrB_Descriptor       desc
                        [, const GrB_BinaryFunction   accum]]]);
\end{verbatim}

\subparagraph{Input Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf dst}]   ({\sf OUTP}) The matrix/vector to assign the result.
    \item[{\sf src}]   ({\sf ARG0}) The matrix to transpose.
    \item[{\sf func}]  ({\sf ARG1}) The unary function to apply to each stored element in src.

    \item[{\sf mask}]  ({\sf MASK}) Output mask (optional). The mask
    specifies which elements of {\sf dst} can be assigned.
    If no mask is necessary (i.e., compute all elements of result),
    {\sf GrB\_NULL} can be used or the mask can be omitted.

    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf ARG0} & {\sf GrB\_CAST} & Allow casting from $\bold{D}({\sf src})$ to $\bold{D}({\sf dst})$ \\
    {\sf ARG0} & {\sf GrB\_TRAN} & Transpose {\sf src} \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf OUTP}& {\sf GrB\_ACC}  & Use the {\sf accum} function to combine with existing values in {\sf dst}.\\
    \end{tabular}

    \item[{\sf accum}] Function used for accumulation into dst.  {\sf GrB\_NULL}
                       can be used if no accumulation into dst is desired.
\end{itemize}

\subparagraph{Return Value}

\scott{Are invalid descriptors an error or ignored?}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_DIMENSION\_MISMATCH}]            
        If the size/shape of dst is not the same as either mask or
        of the transpose of src.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrices, unary function, and/or
        accum function \scott{elaborate}
\end{itemize}

\subparagraph{Description}

The dst matrix must have already been created with the proper dimensions
prior to calling this function.  The unary function operators on stored values in src and the results are assigned to corresponding location in dst.
Src can be optionally transposed first.  The results of the unary function can be optionally accumulated with existing values in dst using accum.  Assignment into dst can be optionally masked.

%=========================================================================

\subsubsection{{\sf reduce}: Perform a reduction across the elements of an object}

Computes the reduction of the values of the elements of a vector or matrix.  There are a number of different variants.

%-----------------------------------------------------------------------------
\paragraph{Matrix to vector variants}

Placeholder

\aydin{Aydin to fill}

\begin{verbatim}
        // reduce rows to a column vector
        GrB_info GrB_rowReduce(GrB_Vector               *dst,
                               const GrB_BinaryFunction  op,   // or monoid
                               const GrB_Matrix          A
                            [, const GrB_MaskVector      mask
                            [, const GrB_Descriptor      desc
                            [, const GrB_BinaryFunction  accum]]])
                               
        // reduce columns to a row vector (not necessary if use transpose descriptor)
        //GrB_info GrB_colReduce(GrB_Vector               *dst,
        //                       const GrB_BinaryFunction  op,   // or monoid
        //                       const GrB_Matrix          A
        //                    [, const GrB_MaskVector      mask
        //                    [, const GrB_Descriptor      desc
        //                    [, const GrB_BinaryFunction  accum]]])
\end{verbatim}

%-----------------------------------------------------------------------------
\paragraph{Reduce to scalar variants}

\subparagraph{C99 Syntax}

\begin{verbatim}
        // semiring version, to be removed?
        //GrB_info GrB_reduce(scalar               *dst,
        //                    const GrB_Semiring    sr,
        //                    const GrB_Vector      src
        //                 [, const GrB_Descriptor  desc]);
                         
        // vector version
        GrB_info GrB_reduce(scalar               *dst
                            const GrB_Monoid      op
                            const GrB_Vector      src
                         [, const GrB_MaskVector  mask
                         [, const GrB_Descriptor  desc]]);
        // matrix version
        GrB_info GrB_reduce(scalar               *dst
                            const GrB_Monoid      op
                            const GrB_Matrix      src
                         [, const GrB_MaskVector  mask
                         [, const GrB_Descriptor  desc]]);
\end{verbatim}

\comment{
\scott{Should we use the space/semiring in place of the {\sf f} parameter
and just use the $\oplus$ or if an semiring consists of monoids this is
another place where a Monoid is appropriate.  Note that we must know the
identity value for the operation in order to store the correct value in
the scalar if the vector that you are reducing has not stored values.}
\jose{Yes, we should. Changed.}\scott{OK TO REMOVE}
}

\scott{Now we shift to the conversation about whether s is replaced with a
"relaxed monoid" or "binary function + identity"}

\subparagraph{Input Parameters}

\begin{itemize}
    \item[{\sf v}] Vector to be reduced.
    \item[{\sf s}] Semiring/monoid defining the reduction.
    \item[{\sf d}] Operation descriptor (optional).
\end{itemize}

\subparagraph{Output Parameters}

\begin{itemize}
    \item[{\sf t}] Value of the reduction. It must
    be a pointer to one of the types in 
    the left column of Table~\ref{Tab:PredefinedTypes} or
    {\tt void*}.
\end{itemize}

\subparagraph{Return Value}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_NOVECTOR}]    vector does not exist
\item[{\sf GrB\_MISMATCH}]    mismatch between vector domain, scalar type or semiring/monoid
\end{itemize}

\subparagraph{Description}

Let $0 = \bold{0}({\sf s})$, whether ${\sf s}$ is a semiring or monoid.
Let $\oplus = \bigoplus({\sf s})$.

We must have $\bold{D}_3({\sf s}) = \bold{D}_1({\sf s})$.
Otherwise, the method returns {\sf GrB\_MISMATCH}.

Vector $\vector{v}$ is computed from input parameter ${\sf v}$ as
specified by descriptor {\sf d}. $\bold{D}(\vector{v}) = \bold{D}_2({\sf s})$
and $\bold{n}(\vector{v}) = \bold{n}({\sf v})$. If $\vector{v}$ cannot be computed
from the input parameters, the method returns {\sf GrB\_MISMATCH}.

A scalar variable $t$ such that $\bold{D}(t) = \bold{D_1}({\sf s})$ is
created and initialized $t \leftarrow \bold{0}({\sf s})$. 
We then compute the recurrence $t \leftarrow t \oplus v_i, \forall i \in \vector{i}(\vector{v})$.

Finally, output parameter {\sf t} is computed from scalar $t$.

%=========================================================================

\subsubsection{{\sf transpose}: Transpose rows and columns of a matrix}

\scott{ If we adopt the concept of a vector having only one index and conventional orientation of column, then there is no materialized transpose for vector. For vector transpose only makes sense in the context of other operations.}

%-----------------------------------------------------------------------------
\paragraph{Standard Matrix Variant}

This version materializes a new matrix that is the transpose of the source matrix.

\subparagraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_transpose(GrB_Matrix           *dst,
                               const GrB_Matrix      src
                            [, const GrB_MaskMatrix  mask
                            [, const GrB_Descriptor  desc
                            [, const GrB_Function    accum]]]);
\end{verbatim}

\subparagraph{Input Parameters}

\begin{itemize}
    \item[{\sf dst}]   ({\sf OUTP}) The matrix to assign the result.
    \item[{\sf src}]   ({\sf ARG0}) The matrix to transpose.

    \item[{\sf desc}]  Operation descriptor (optional). The descriptor
    is used to specify details of the operation. Valid options are 
    invert (structural complement) of mask ({\sf ARG3}). If
    a \emph{default} descriptor is desired,    {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.

    \item[{\sf mask}]  (MASK) Output mask (optional). The mask
    specifies which elements of {\sf dst} can be assigned.
    If no mask is necessary (i.e., compute all elements of result),
    {\sf GrB\_NULL} can be used or the mask can be omitted.

    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf ARG0} & {\sf GrB\_CAST} & Allow casting from $\bold{D}({\sf src})$ to $\bold{D}({\sf dst})$ \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf OUTP}& {\sf GrB\_ACC}  & Use the {\sf accum} function to add to existing values in {\sf dst}.\\
    \end{tabular}

    \item[{\sf accum}] Function used for accumulation into dst.  {\sf GrB\_NULL}
                       can be used if no accumulation into dst is used.
\end{itemize}

\subparagraph{Return Value}

\scott{Are invalid descriptors an error or ignored?}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_DIMENSION\_MISMATCH}]      
        If the size/shape of dst is not the same as either mask or
        of the transpose of src.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrices and/or
        accum function \scott{elaborate}
\end{itemize}

\subparagraph{Description}

The dst matrix must have already been created with the proper dimensions
prior to calling this function.  Stored values are inserted into dst to
create a transpose of the src matrix where 
$dst(j,i) = src(i,j) \forall i,j where src(i,j) \neq 0$.
If accum is specified then the function is used to combine with existing values in dst using ewiseadd semantics:
$dst(j,i) \oplus = src(i,j) \forall i,j where src(i,j) \neq 0$.
When the mask is specified the destination location will only be assigned if the corresponding location in the mask has a stored value.

\scott{What happens when src is negated? It can't be. Only masks can be negated.}

\scott{What happens if accum is not used and dst is not empty? dst is overwritten.}

\scott{What happens if src and dst refer to the same matrix?  With immutable dimensions and non-square matrices this should be disallowed.}


