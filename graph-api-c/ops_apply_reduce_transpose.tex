\subsection{{\sf apply}: Apply a unary function to the elements of an object}

%-----------------------------------------------------------------------------

\subsubsection{{\sf apply}: Vector variant}
\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Vector            *w,
                           const GrB_Vector       mask,
                           const GrB_BinaryOp     accum,
                           const GrB_UnaryOp      op,
                           const GrB_Vector       u,
                           const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    apply operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}]  ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector,
    ${\sf w}$.  If no mask is desired (\ie, all elements
    of result are copied into the output vector), {\sf GrB\_NULL}
    should be specified. The mask dimensions must match those of the
    vector {\sf w} and the domain of {\sf mask} must be
    of type {\sf bool} or any of the predefined ``built-in'' types in
    Table~\ref{Tab:PredefinedTypes}.

    \item[{\sf accum}]    ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf w} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]	({\sf IN}) A unary operator applied to 
	    each element of input vector {\sf u}: ${\sf op} = \langle D_1,D_2,f \rangle$.

    \item[{\sf u}]       ({\sf IN}) The GraphBLAS vector to which the unary function
    is applied.
    
    \item[{\sf desc}]     ({\sf IN}) An optional operation descriptor.  If a 
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be used.  Valid 
    fields are as follows: \\
    
    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it. \\
        
        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural 
        complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
	    successfully. In non-blocking mode, this indicates that (at least) the consistency 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]            Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] At least one of the input objects is
	    in an invalid state. Likely caused by a previous execution error.
    Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf w} pointer is {\sf NULL}.
    
    \item[{\sf GrB\_DIMENSION\_MISMATCH}]  {\sf mask}, {\sf w} and/or {\sf u} dimensions are
    incompatible. 
    
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various vectors are
	incompatible with the corresponding domains of the accumulating operation, 
    mask, or unary function.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_apply} computes the result of applying a unary function
to the elements of a GraphBLAS vector:
${\sf w} = f({\sf u})$; or, if an optional binary accumulation 
operator ($\odot$) is provided, ${\sf w} = {\sf w} \odot f({\sf u})$.  
More explicitly:
\[
	{\sf w}(i) = f({\sf u}(i)) \mbox{~~or~~} 
    {\sf w}(i) = {\sf w}(i) \odot f({\sf u}(i))
    \ \forall i \ : \ 0 \leq i < \bold{size}({\sf u})
\]  
Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[\bf Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for consistency.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to three argument vectors are used in this {\sf GrB\_apply} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),
    \bold{L}({\sf w}) = \{(i,w_i) \} \rangle$

	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),
    \bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)

	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),
    \bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

The argument vectors and the accumulation 
operator (if provided) are tested for domain consistency as follows:
\begin{enumerate}
	\item The domain of {\sf mask} (if not {\sf GrB\_NULL}) must be from one of 
    the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be 
    compatible with $D_2$ of the unary operator.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $D_x$ and $D_z$ of the accumulation operator and 
    $D_2$ of the unary operator must be compatible with $D_y$ of the accumulation operator.

	\item $\bold{D}({\sf u})$ must be compatible with $D_1$.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any consistency rule above is violated, execution of {\sf GrB\_apply} ends
and the domain mismatch error listed above is returned.

From the argument vectors, the internal vectors and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item	If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \forall i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item	Otherwise, $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf mask}), \{i : ({\sf bool}){\sf mask}(i) = 
        \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is \true, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
    
\end{enumerate}

The internal vectors and masks are checked for for dimension consistency. 
The following conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$
	\item $\bold{size}(\vector{\widetilde{u}}) = \bold{size}(\vector{\widetilde{w}})$.
\end{enumerate}
If any consistency rule above is violated, execution of {\sf GrB\_apply} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can optionally exit
with {\sf GrB\_SUCCESS} return code and defer any computation and/or execution error codes.

We are now ready to carry out the apply and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
	\item $\vector{\widetilde{t}}$: The vector holding the result from applying the unary operator to the input vector
    $\vector{\widetilde{u}}$.
	\item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulator.
\end{itemize}

The intermediate vector, $\vector{\widetilde{t}}$, is created as follows:
\[ 
\vector{\widetilde{t}} = \langle
D_2, \bold{size}(\vector{\widetilde{u}}),
\bold{L}(\vector{\widetilde{t}}) =
\{(i,f(\vector{\widetilde{u}}(i))) \forall i \in \bold{ind}(\vector{\widetilde{u}}) \} \rangle. 
\]

The intermediate vector $\vector{\widetilde{z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\vector{\widetilde{z}} \leftarrow \vector{\widetilde{t}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then vector $\vector{\widetilde{z}}$ is defined as 
        \[ \langle D_z, \bold{size}(\vector{\widetilde{w}}), \bold{L}(\vector{\widetilde{z}})
		= \{(i,z_{i})  \forall (i) \in \bold{ind}(\vector{\widetilde{w}}) \cup 
        \bold{ind}(\vector{\widetilde{t}}) \} \rangle.\]
    The values of the elements of $\vector{\widetilde{z}}$ are computed based on the relationships between the sets of indices in $\vector{\widetilde{w}}$ and $\vector{\widetilde{t}}$.
\[
z_{i} = \vector{\widetilde{w}}(i) \odot \vector{\widetilde{t}}(i), \forall i \in  (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}})),
\]
\[
z_{i} = \vector{\widetilde{w}}(i), \forall  i \in  (\bold{ind}(\vector{\widetilde{w}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}}))),
\]
\[
z_{i} = \vector{\widetilde{t}}(i), \forall  i \in  (\bold{ind}(\vector{\widetilde{t}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\vector{\widetilde{z}}$ 
vector are written into the final result vector, {\sf w}. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set then any values in {\sf w} 
on input to {\sf GrB\_extract()} are deleted and the new output vector {\sf w} is,
\[ \bold{L}({\sf w}) = \{(i,z_{i}) : i \in (\bold{ind}(\vector{\widetilde{z}}) 
\cap \bold{ind}(\vector{\widetilde{m}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of 
$\vector{\widetilde{z}}$ indicated by 
the mask are copied into the result vector, {\sf w}, and elements of 
{\sf w} that fall outside the set indicated by the mask are unchanged:
\[ \bold{L}({\sf w}) = \{(i,w_{i}) : i \in (\bold{ind}({\sf w}) 
\cap \bold{ind}(\neg \vector{\widetilde{m}})) \} \cup \{(i,z_{i}) : i \in 
(\bold{ind}(\vector{\widetilde{z}}) \cap \bold{ind}(\vector{\widetilde{m}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.

%--------------------------------------------------------------

\subsubsection{{\sf apply}: Matrix variant}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Matrix             *C,
                           const GrB_Matrix        Mask,
                           const GrB_BinaryOp      accum,
                           const GrB_UnaryOp       op,
                           const GrB_Matrix        A,
                           const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]     ({\sf INOUT}) The matrix to assign the result.

    \item[{\sf Mask}]  ({\sf IN}) Output mask. The mask
    specifies which elements of {\sf C} can be modified.
    If no mask is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) Operator used for accumulating entries into existing {\sf C} entries. 
			If no accumulation is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) The unary function (operation) to apply to each stored element in {\sf A}.
    \item[{\sf A}]     ({\sf IN}) The matrix to apply the function to.
    \item[{\sf desc}]  ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C} is cleared (all elements removed) before result is stored in it. \\
    {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}    & Use the structural complement of {\sf Mask}. \\
    {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}    & Use the transpose {\sf A} for the operation.\\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.

\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf C} pointer is {\sf NULL}.

\item[{\sf GrB\_DIMENSION\_MISMATCH}]            
        If the size/shape of {\sf C} is not the same as either {\sf Mask} or {\sf A} (or its transpose if specified).
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrices, unary function, and/or
        accum function \scott{elaborate}
\end{itemize}

\paragraph{Description}

The {\sf C} matrix must have already been created with the proper dimensions
prior to calling this function.  The unary operator computes on stored values in {\sf A} and the results are assigned to corresponding location in {\sf C}.
The input matrix, {\sf A}, can be optionally transposed first.  The results of the unary function can be optionally accumulated with existing values in {\sf C} using accum.  Assignment into {\sf C} can be optionally masked.

%=========================================================================

\subsection{{\sf reduce}: Perform a reduction across the elements of an object}

Computes the reduction of the values of the elements of a vector or matrix.

%-----------------------------------------------------------------------------
\subsubsection{{\sf reduce}: Standard matrix to vector variant}

This performs a row-wise reduction of a matrix to produce a vector.  If column-wise reduction
is desired, the input matrix should be transposed which can be specified using the descriptor.

\paragraph{\syntax}

\begin{verbatim}
        // Using a Monoid
        GrB_Info GrB_reduce(GrB_Vector            *w,
                            const GrB_Vector       mask,
                            const GrB_BinaryOp     accum,
                            const GrB_Monoid       op,  
                            const GrB_Matrix       A,
                            const GrB_Descriptor   desc);
                            
        // Using a BinaryOp
        GrB_Info GrB_reduce(GrB_Vector            *w,
                            const GrB_Vector       mask,
                            const GrB_BinaryOp     accum,
                            const GrB_BinaryOp     op,  
                            const GrB_Matrix       A,
                            const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]     ({\sf INOUT}) Vector/Matrix to be assigned.

    \item[{\sf mask}]  ({\sf IN}) Output mask. The mask specifies which elements
    of {\sf w} can be modified. If no mask is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) Operator used for accumulation into {\sf w}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) Operator used to perform the reduction of elements from {\sf A}.  If a Monoid is specified, its binary operator is used.
    \item[{\sf A}]     ({\sf IN}) The matrix on which to operate.

    \item[{\sf desc}]  ({\sf IN}) Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w} is cleared (all elements removed) before result is stored in it. \\
    {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}    & Use the structural complement of {\sf mask}. \\
    {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}    & Use the transpose of {\sf A} 
    resulting in a column-wise reduction. \\
    \end{tabular}

\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]    operation completed successfully.
\item[{\sf GrB\_PANIC}]      unknown internal error.

\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf w} pointer is {\sf NULL}.

\item[{\sf GrB\_DIMENSION\_MISMATCH}]            
        If the size of {\sf w} is not the same as {\sf mask} or $\bold{m}({\sf A})$ (or its transpose if specified).
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrices, operator, or
        accum function \scott{elaborate}
\end{itemize}


\paragraph{Description}

Matrix \matrix{A} is computed from input parameter {\sf A} as specified
by descriptor {\sf desc}. Specifically, it computes the (sparse) vector of row ``sums'' if 
GrB\_TRAN  is not set, and the vector of column ``sums'' if GrB\_TRAN  is set. It then
stores this result vector into {\sf w}. $\vector{mask}$ is also computed from input parameter {\sf mask}
as specified by descriptor {\sf desc}.

In its simplest form, when called on a $m$-by-$n$ matrix \matrix{A}, this function returns a vector ${\sf w}$ 
of length $m$. Each entry ${\sf w}(i)$ is the ``sum'' of all entries in the $i$th row of 
{\sf A} with respect to the monoid or BinaryOp {\sf op}. 


A new vector $\vector{w} = \langle \bold{D}_3({\sf op}),
\bold{n}(\matrix{A}), \bold{L}(\vector{w}) = \{(i,w_i) : \vector{mask}(i)
= {\sf true} \} \rangle$ is created.  Let us denote the binary operation of the monoid or BinaryOp {\sf op} by $\oplus$,
then the value of each of $\vector{w}$'s elements
is computed by $ \vector{w}(i) = \matrix{A}(i,0) \oplus \matrix{A}(i,1) \oplus  \ldots \oplus  \matrix{A}(i,n)$.  
 

Finally, output parameter {\sf w} is computed from vector $\vector{w}$
as specified by descriptor {\sf desc}. In the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified. 
 If $\vector{w}(i)$ is empty, due to reducing an empty row or column, then the outcome depends on the variable {\sf accum}.
  if {\sf accum} is GrB\_NULL, then ${\sf w}(i)$ is also empty. If {\sf accum} is GrB\_ACCUM, then ${\sf w}(i)$ is unchanged.
A consistency check is
performed to verify that $\bold{n}({\sf w}) = \bold{n}(\vector{w})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.


%-----------------------------------------------------------------------------
\subsubsection{{\sf reduce}: Vector-scalar variants}
\label{Sec:Reduce_vector_scalar}

Reduce all stored values into a single scalar.

\scott{TODO: do we need to support an input mask for this variant?}

\scott{TODO: Need to have conversation about whether op can/should also take a semiring}

\scott{TODO: Should we support accum in this variant?}


\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_reduce(<type>                *val,
                            const GrB_BinaryOp     accum,
                            const GrB_Monoid       op,
                            const GrB_Vector       u,
                            const GrB_Descriptor   desc);
\end{verbatim}


\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf val}]    ({\sf INOUT}) Scalar to store final reduced value into.  The type must be
                        consistent with the domain of {\sf u} or {\sf accum} (if used).

    \item[{\sf accum}]  ({\sf IN}) Operator used for accumulation into {\sf val}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]     ({\sf IN}) Monoid defining the reduction operator.
    \item[{\sf u}]    Vector to be reduced.

    \item[{\sf desc}]   ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf val} & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & \scott{There are no reasonable descriptor parameters for this function.} \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully.
\item[{\sf GrB\_PANIC}]               unknown internal error.

\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf val} pointer is {\sf NULL}.

\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among vector/matrix, monoid operation, and/or
        accum function, and {\sf val} \scott{elaborate}
\end{itemize}

\paragraph{Description}

\scott{NEEDS REWRITE}

Let $0 = \bold{0}({\sf op})$, and let $\oplus = \bigodot({\sf op})$ (for monoids).
\scott{Let $\oplus = \bigoplus({\sf op})$ if op is a semiring.}

Vector $\vector{u}$ is computed from input parameter ${\sf u}$ as
specified by descriptor {\sf desc}. If $\vector{u}$ cannot be computed
from the input parameters, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

A scalar variable $s$ such that $\bold{D}(s) = \bold{D_3}({\sf op})$ is
created and initialized $s \leftarrow \bold{0}({\sf op})$. 
We then compute the recurrence $s \leftarrow s \oplus u_i, \forall i \in \vector{i}(\vector{u})$.

Finally, output parameter {\sf val} is computed from scalar $s$.

%-----------------------------------------------------------------------------
\subsubsection{{\sf reduce}: Matrix-scalar variants}
\label{Sec:Reduce_matrix_scalar}

Reduce all stored values into a single scalar.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_reduce(<type>                *val,
                            const GrB_BinaryOp     accum,
                            const GrB_Monoid       op,
                            const GrB_Matrix       A,
                            const GrB_Descriptor   desc);
\end{verbatim}


\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf val}]    ({\sf INOUT}) Scalar to store final reduced value into.  The type must be
                        consistent with the domain of {\sf A} or {\sf accum} (if used).

    \item[{\sf accum}]  ({\sf IN}) Operator used for accumulation into {\sf val}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]     ({\sf IN}) Monoid defining the reduction operator.
    \item[{\sf A}]    Vector/matrix to be reduced.

    \item[{\sf desc}]   ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} isj to be
    used.  Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf val} & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & \scott{There are no reasonable descriptor parameters for this function.} \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully.
\item[{\sf GrB\_PANIC}]               unknown internal error.

\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf val} pointer is {\sf NULL}.

\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrix, monoid operation, and/or
        accum function, and {\sf val} \scott{elaborate}
\end{itemize}

\paragraph{Description}

\scott{NEEDS REWRITE}

Let $0 = \bold{0}({\sf op})$, and let $\oplus = \bigodot({\sf op})$ (for monoids).
\scott{Let $\oplus = \bigoplus({\sf op})$ if op is a semiring.}

Matrix $\matrix{A}$ is computed from input parameter ${\sf A}$ as
specified by descriptor {\sf desc}. If $\matrix{A}$ cannot be computed
from the input parameters, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

A scalar variable $s$ such that $\bold{D}(s) = \bold{D_3}({\sf op})$ is
created and initialized $s \leftarrow \bold{0}({\sf op})$. 
We then compute the recurrence $s \leftarrow s \oplus A_{ij}, \forall (i, j) \in \bold{L}(\matrix{A})$.

Finally, output parameter {\sf val} is computed from scalar $s$.

%=========================================================================

\subsection{{\sf transpose}: Transpose rows and columns of a matrix}

This version materializes a new matrix that is the transpose of the source matrix.

\scott{TODO: Need to discuss if we will support C and A referencing the same matrix
with the meaning that in-place transpose is to be performed. With immutable dimensions
and non-square matrices this should be disallowed or throw a DIMENSION\_MISMATCH.}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_transpose(GrB_Matrix            *C,
                               const GrB_Matrix       Mask,
                               const GrB_BinaryOp     accum,
                               const GrB_Matrix       A,
                               const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]     ({\sf INOUT}) The matrix to assign the result.

    \item[{\sf Mask}]  ({\sf IN}) Output mask. The mask specifies which elements
    of {\sf C} can be modified. If no mask is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) Operator used for accumulation into {\sf C}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf A}]     ({\sf IN}) The matrix to transpose.

    \item[{\sf desc}]  ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C} is cleared (all elements removed) before result is stored in it. \\
    {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf Mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.

\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf C} pointer is {\sf NULL}.

\item[{\sf GrB\_DIMENSION\_MISMATCH}]      
        If the size/shape of {\sf C} is not the same as either {\sf Mask} or {\sf A} (or its transpose, if specified).
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrices and/or
        accum function \scott{elaborate}
\end{itemize}

\paragraph{Description}

\scott{This needs Jose's touch to get at explicit semantics.}

The {\sf C} matrix must have already been created with the proper dimensions
prior to calling this function.  Stored values are inserted into {\sf C} to
create a transpose of the {\sf A} matrix where 
${\sf C}(j,i) = {\sf A}(i,j) ~ \forall ~ (i,j) \in \bold{L}({\sf A})$.
If accum is specified then the function is used to combine with existing values in {\sf C} using {\sf eWiseAdd} semantics:
${\sf C}(j,i) \oplus = {\sf A}(i,j) ~ \forall ~ (i,j) \in \bold{L}({\sf A})$.
When {\sf Mask} is specified the destination location will only be assigned if the corresponding location in {\sf Mask} has a stored value.
