\subsubsection{{\sf apply}: Apply a unary function to the elements of a matrix}


\subparagraph{C99 Syntax}

\begin{verbatim}
GrB_info GrB_apply(GrB_Matrix *dst, const GrB_BinaryFunction accum,
                   GrB_UnaryFunction func, const GrB_Matrix src[,
                   const GrB_Matrix mask [, const GrB_Descriptor desc]]);
\end{verbatim}

\subparagraph{Input Parameters}

\begin{itemize}
	\item[{\sf dst}]   ({\sf ARG0}) The matrix to assign the result.
	\item[{\sf accum}] ({\sf ARG1}) Function used for accumulation into dst.  {\sf GrB\_NULL}
                       can be used if no accumulation into dst is desired.
    \item[{\sf func}]  ({\sf ARG2})
	\item[{\sf src}]   ({\sf ARG3}) The matrix to transpose.
    \item[{\sf mask}]  ({\sf ARG4}) The optional output mask.

	\item[{\sf desc}]  Operation descriptor (optional). The descriptor
    is used to specify details of the operation. Valid options are 
    invert (structural complement) of mask ({\sf ARG4}), and transpose of
    src ({\sf ARG3}. If a \emph{default} descriptor is desired,	{\sf GrB\_NULL} can be used or the descriptor can be omitted.
\end{itemize}

\subparagraph{Return Value}

\scott{Are invalid descriptors an error or ignored?}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}] 	operation completed successfully.
\item[{\sf GrB\_PANIC}]	    unknown internal error.
\item[{\sf GrB\_DIMENSION\_MISMATCH}]	  	  
        If the size/shape of dst is not the same as either mask or
        of the transpose of src.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
	    domain mismatch among matrices, unary function, and/or
        accum function \scott{elaborate}
\end{itemize}

\subparagraph{Description}

The dst matrix must have already been created with the proper dimensions
prior to calling this function.  The unary function operators on stored values in src and the results are assigned to corresponding location in dst.
Src can be optionally transposed first.  The results of the unary function can be optionally accumulated with existing values in dst using accum.  Assignment into dst can be optionally masked.

%=========================================================================

\subsubsection{{\sf reduce}: Perform a reduction across the elements of an object}

Computes the reduction of the values of the elements of a vector or matrix.  There are a number of different variants.

%-----------------------------------------------------------------------------
\paragraph{Vector variant}

\subparagraph{C99 Syntax}

\begin{verbatim}
#include "GraphBLAS.h"
GrB_info GrB_reduce(scalar *t, const GrB_Semiring s, const GrB_Vector v
                    [, const GrB_Descriptor d])
GrB_info GrB_reduce(scalar *t, const GrB_Monoid s, const GrB_Vector v
                    [, const GrB_Descriptor d])
\end{verbatim}

\comment{
\scott{Should we use the space/semiring in place of the {\sf f} parameter
and just use the $\oplus$ or if an semiring consists of monoids this is
another place where a Monoid is appropriate.  Note that we must know the
identity value for the operation in order to store the correct value in
the scalar if the vector that you are reducing has not stored values.}
\jose{Yes, we should. Changed.}\scott{OK TO REMOVE}
}

\scott{Now we shift to the conversation about whether s is replaced with a
"relaxed monoid" or "binary function + identity"}

\subparagraph{Input Parameters}

\begin{itemize}
	\item[{\sf v}] Vector to be reduced.
	\item[{\sf s}] Semiring/monoid defining the reduction.
	\item[{\sf d}] Operation descriptor (optional).
\end{itemize}

\subparagraph{Output Parameters}

\begin{itemize}
	\item[{\sf t}] Value of the reduction. It must
	be a pointer to one of the types in 
	the left column of Table~\ref{Tab:PredefinedTypes} or
	{\tt void*}.
\end{itemize}

\subparagraph{Return Value}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}] 	operation completed successfully.
\item[{\sf GrB\_PANIC}]	    unknown internal error.
\item[{\sf GrB\_NOVECTOR}]	vector does not exist
\item[{\sf GrB\_MISMATCH}]	mismatch between vector domain, scalar type or semiring/monoid
\end{itemize}

\subparagraph{Description}

Let $0 = \bold{0}({\sf s})$, whether ${\sf s}$ is a semiring or monoid.
Let $\oplus = \bigoplus({\sf s})$.

We must have $\bold{D}_3({\sf s}) = \bold{D}_1({\sf s})$.
Otherwise, the method returns {\sf GrB\_MISMATCH}.

Vector $\vector{v}$ is computed from input parameter ${\sf v}$ as
specified by descriptor {\sf d}. $\bold{D}(\vector{v}) = \bold{D}_2({\sf s})$
and $\bold{n}(\vector{v}) = \bold{n}({\sf v})$. If $\vector{v}$ cannot be computed
from the input parameters, the method returns {\sf GrB\_MISMATCH}.

A scalar variable $t$ such that $\bold{D}(t) = \bold{D_1}({\sf s})$ is
created and initialized $t \leftarrow \bold{0}({\sf s})$. 
We then compute the recurrence $t \leftarrow t \oplus v_i, \forall i \in \vector{i}(\vector{v})$.

Finally, output parameter {\sf t} is computed from scalar $t$.

%-----------------------------------------------------------------------------
\paragraph{Matrix variants}

Placeholder

\aydin{Aydin to fill}

\begin{verbatim}
#include "GraphBLAS.h"
// reduce to scalar
GrB_info GrB_reduce(scalar *t, const GrB_Monoid s,
                    const GrB_Matrix A [, const GrB_Descriptor d])

// reduce to vector
GrB_info GrB_rowReduce(GrB_Vector *r, const GrB_BinaryFunction s,
                       const GrB_Matrix A [, const GrB_Descriptor d])
GrB_info GrB_colReduce(GrB_Vector *c, const GrB_BinaryFunction s,
                       const GrB_Matrix A [, const GrB_Descriptor d])
\end{verbatim}

%=========================================================================

\subsubsection{{\sf transpose}: Transpose rows and columns of a matrix}

\scott{ If we adopt the concept of a vector having only one index and conventional orientation of column, then there is no materialized transpose for vector. For vector transpose only makes sense in the context of other operations.}

%-----------------------------------------------------------------------------
\paragraph{Standard Matrix Variant}

This version materializes a new matrix that is the transpose of the source matrix.

\subparagraph{C99 Syntax}

\begin{verbatim}
GrB_info GrB_transpose(GrB_Matrix *dst, const GrB_Function accum,
                       const GrB_Matrix src[, const GrB_Matrix mask [,
                       const GrB_Descriptor desc]]);
\end{verbatim}

\subparagraph{Input Parameters}

\begin{itemize}
	\item[{\sf dst}]   ({\sf ARG0}) The matrix to assign the result.
	\item[{\sf accum}] ({\sf ARG1}) Function used for accumulation into dst.  {\sf GrB\_NULL}
                       can be used if no accumulation into dst is desired.
	\item[{\sf src}]   ({\sf ARG2}) The matrix to transpose.
    \item[{\sf mask}]  ({\sf ARG3}) The optional output mask.

	\item[{\sf desc}]  Operation descriptor (optional). The descriptor
    is used to specify details of the operation. Valid options are 
    invert (structural complement) of mask ({\sf ARG3}). If
    a \emph{default} descriptor is desired,	{\sf GrB\_NULL} can be
    used or the descriptor can be omitted.
\end{itemize}

\subparagraph{Return Value}

\scott{Are invalid descriptors an error or ignored?}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}] 	operation completed successfully.
\item[{\sf GrB\_PANIC}]	    unknown internal error.
\item[{\sf GrB\_DIMENSION\_MISMATCH}]	  
        If the size/shape of dst is not the same as either mask or
        of the transpose of src.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
	    domain mismatch among matrices and/or
        accum function \scott{elaborate}
\end{itemize}

\subparagraph{Description}

The dst matrix must have already been created with the proper dimensions
prior to calling this function.  Stored values are inserted into dst to
create a transpose of the src matrix where 
$dst(j,i) = src(i,j) \forall i,j where src(i,j) \neq 0$.
If accum is specified then the function is used to combine with existing values in dst using ewiseadd semantics:
$dst(j,i) \oplus = src(i,j) \forall i,j where src(i,j) \neq 0$.
When the mask is specified the destination location will only be assigned if the corresponding location in the mask has a stored value.

\scott{What happens when src is negated? It can't be. Only masks can be negated.}

\scott{What happens if accum is not used and dst is not empty? dst is overwritten.}

\scott{What happens if src and dst refer to the same matrix?  With immutable dimensions and non-square matrices this should be disallowed.}


