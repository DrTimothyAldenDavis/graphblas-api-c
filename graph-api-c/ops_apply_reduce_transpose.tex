\subsection{{\sf apply}: Apply a unary function to the elements of an object}

%-----------------------------------------------------------------------------

\subsubsection{{\sf apply}: Vector variant}
\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Vector            *w,
                           const GrB_Vector       mask,
                           const GrB_BinaryOp     accum,
                           const GrB_UnaryOp      op,
                           const GrB_Vector       u,
                           const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    apply operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}]  ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector,
    ${\sf w}$.  If no mask is desired (\ie, all elements
    of result are copied into the output vector), {\sf GrB\_NULL}
    should be specified. The mask dimensions must match those of the
    vector {\sf w} and the domain of {\sf mask} must be
    of type {\sf bool} or any of the predefined ``built-in'' types in
    Table~\ref{Tab:PredefinedTypes}.

    \item[{\sf accum}]    ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf w} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]	({\sf IN}) A unary operator applied to 
	    each element of input vector {\sf u}: ${\sf op} = \langle D_1,D_2,f \rangle$.

    \item[{\sf u}]       ({\sf IN}) The GraphBLAS vector to which the unary function
    is applied.
    
    \item[{\sf desc}]     ({\sf IN}) An optional operation descriptor.  If a 
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be used.  Valid 
    fields are as follows: \\
    
    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it. \\
        
        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural 
        complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
	    successfully. In non-blocking mode, this indicates that (at least) the consistency 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]            Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] At least one of the input objects is
	    in an invalid state. Likely caused by a previous execution error.
    Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf w} pointer is {\sf NULL}.
    
    \item[{\sf GrB\_DIMENSION\_MISMATCH}]  {\sf mask}, {\sf w} and/or {\sf u} dimensions are
    incompatible. 
    
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various vectors are
	incompatible with the corresponding domains of the accumulating operation, 
    mask, or unary function.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_apply} computes the result of applying a unary function
to the elements of a GraphBLAS vector:
${\sf w} = f({\sf u})$; or, if an optional binary accumulation 
operator ($\odot$) is provided, ${\sf w} = {\sf w} \odot f({\sf u})$.  

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[\bf Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for consistency.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to three argument vectors are used in this {\sf GrB\_apply} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),
    \bold{L}({\sf w}) = \{(i,w_i) \} \rangle$

	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),
    \bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)

	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),
    \bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
\end{enumerate}

The argument vectors and the accumulation 
operator (if provided) are tested for domain consistency as follows:
\begin{enumerate}
	\item The domain of {\sf mask} (if not {\sf GrB\_NULL}) must be from one of 
    the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be 
    compatible with $D_2$ of the unary operator.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $D_x$ and $D_z$ of the accumulation operator and 
    $D_2$ of the unary operator must be compatible with $D_y$ of the accumulation operator.

	\item $\bold{D}({\sf u})$ must be compatible with $D_1$.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any consistency rule above is violated, execution of {\sf GrB\_apply} ends
and the domain mismatch error listed above is returned.

From the argument vectors, the internal vectors and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item	If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \forall i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item	Otherwise, $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf mask}), \{i : ({\sf bool}){\sf mask}(i) = 
        \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is \true, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
    
\end{enumerate}

The internal vectors and masks are checked for for dimension consistency. 
The following conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$
	\item $\bold{size}(\vector{\widetilde{u}}) = \bold{size}(\vector{\widetilde{w}})$.
\end{enumerate}
If any consistency rule above is violated, execution of {\sf GrB\_apply} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can optionally exit
with {\sf GrB\_SUCCESS} return code and defer any computation and/or execution error codes.

We are now ready to carry out the apply and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
	\item $\vector{\widetilde{t}}$: The vector holding the result from applying the unary operator to the input vector
    $\vector{\widetilde{u}}$.
	\item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulator.
\end{itemize}

The intermediate vector, $\vector{\widetilde{t}}$, is created as follows:
\[ 
\vector{\widetilde{t}} = \langle
D_2, \bold{size}(\vector{\widetilde{u}}),
\bold{L}(\vector{\widetilde{t}}) =
\{(i,f(\vector{\widetilde{u}}(i))) \forall i \in \bold{ind}(\vector{\widetilde{u}}) \} \rangle. 
\]

The intermediate vector $\vector{\widetilde{z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\vector{\widetilde{z}} \leftarrow \vector{\widetilde{t}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then vector $\vector{\widetilde{z}}$ is defined as 
        \[ \langle D_z, \bold{size}(\vector{\widetilde{w}}), \bold{L}(\vector{\widetilde{z}})
		= \{(i,z_{i})  \forall (i) \in \bold{ind}(\vector{\widetilde{w}}) \cup 
        \bold{ind}(\vector{\widetilde{t}}) \} \rangle.\]
    The values of the elements of $\vector{\widetilde{z}}$ are computed based on the relationships between the sets of indices in $\vector{\widetilde{w}}$ and $\vector{\widetilde{t}}$.
\[
z_{i} = \vector{\widetilde{w}}(i) \odot \vector{\widetilde{t}}(i), \forall i \in  (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}})),
\]
\[
z_{i} = \vector{\widetilde{w}}(i), \forall  i \in  (\bold{ind}(\vector{\widetilde{w}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}}))),
\]
\[
z_{i} = \vector{\widetilde{t}}(i), \forall  i \in  (\bold{ind}(\vector{\widetilde{t}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\vector{\widetilde{z}}$ 
vector are written into the final result vector, {\sf w}. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set then any values in {\sf w} 
on input to {\sf GrB\_apply()} are deleted and the new output vector {\sf w} is,
\[ \bold{L}({\sf w}) = \{(i,z_{i}) : i \in (\bold{ind}(\vector{\widetilde{z}}) 
\cap \bold{ind}(\vector{\widetilde{m}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of 
$\vector{\widetilde{z}}$ indicated by 
the mask are copied into the result vector, {\sf w}, and elements of 
{\sf w} that fall outside the set indicated by the mask are unchanged:
\[ \bold{L}({\sf w}) = \{(i,w_{i}) : i \in (\bold{ind}({\sf w}) 
\cap \bold{ind}(\neg \vector{\widetilde{m}})) \} \cup \{(i,z_{i}) : i \in 
(\bold{ind}(\vector{\widetilde{z}}) \cap \bold{ind}(\vector{\widetilde{m}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.

%--------------------------------------------------------------

\subsubsection{{\sf apply}: Matrix variant}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Matrix             *C,
                           const GrB_Matrix        Mask,
                           const GrB_BinaryOp      accum,
                           const GrB_UnaryOp       op,
                           const GrB_Matrix        A,
                           const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf C}]     ({\sf INOUT}) An existing GraphBLAS matrix.  On input,
    the matrix provides values that may be accumulated with the result of the
    apply operation.  On output, this matrix holds the results of the
    operation.

    \item[{\sf Mask}]  ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix,
    ${\sf C}$.  If no mask is desired (\ie, all elements
    of result are copied into the output vector), {\sf GrB\_NULL}
    should be specified.  The mask dimensions must match those of the
    matrix {\sf C} and the domain of {\sf Mask} must be
    of type {\sf bool} or any of the predefined ``built-in'' types in
    Table~\ref{Tab:PredefinedTypes}.

    \item[{\sf accum}] ({\sf IN})  An optional operator used for accumulating
    entries into existing {\sf C} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}] ({\sf IN}) A unary operator applied to each
	    element of input matrix {\sf A}: ${\sf op} = \langle D_1, D_2, f \rangle$.

    \item[{\sf A}]     ({\sf IN})  The GraphBLAS matrix to which the unary function 
    is applied.

    \item[{\sf desc}]  ({\sf IN}) An optional operation descriptor.  If a 
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be used.  Valid 
    fields are as follows: \\
    
    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C} 
        is cleared (all elements removed) before result is stored in it. \\
    
        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural 
        complement of {\sf Mask}. \\
    
        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Apply transpose to {\sf A} 
        before applying unary operator to elements.) \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
    successfully. In non-blocking mode, this indicates that the consistency 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output matrix {\sf C} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]            Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] At least one of the input objects is in an invalid state.
	    Likely caused by a previous execution error.
    Call {GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf dup} for matrix
    parameters).

    \item[{\sf GrB\_NULL\_POINTER}]  {\sf C} pointer is {\sf NULL}. \scott{We still
    do not agree if NULL indices pointer should be specified to result in this error}

    \item[{\sf GrB\_INDEX\_OUT\_OF\_BOUNDS}]  A value in {\sf row\_indices} 
    is greater than or equal to $\bold{nrows}({\sf A})$, or a value in 
    {\sf col\_indices} is greater than or equal to $\bold{ncols}({\sf A})$.  In 
    non-blocking mode, this can be reported as an execution error.
    
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] {\sf Mask} and {\sf C} dimensions are
    incompatible, ${\sf nrows} \neq \bold{nrows}({\sf C})$, or 
    ${\sf ncols} \neq \bold{ncols}({\sf C})$.

    \item[{\sf GrB\_DOMAIN\_MISMATCH}]     The domains of the various matrices
    are incompatible with the corresponding domains of the accumulating 
    operation or mask.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_apply} computes the result of applying a unary function
to the elements of a 
GraphBLAS matrix: ${\sf C} = f({\sf A})$; or, if an 
optional binary accumulation operator ($\odot$) is provided, 
${\sf C} = {\sf C} \odot f({\sf A})$.  

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[\bf Setup] The internal matrices and mask used in the computation are formed 
and their domains and dimensions are tested for consistency.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output matrix, possibly under 
control of a mask.
\end{enumerate}

Up to three argument matrices are used in this {\sf GrB\_apply} operation:
\begin{enumerate}
	\item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),
    \bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$
    
	\item ${\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}({\sf Mask}),
    \bold{ncols}({\sf Mask}),\bold{L}({\sf Mask}) = \{(i,j,M_{ij}) \} \rangle$ (optional)

	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}),
    \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
\end{enumerate}

The argument matrices and the accumulation 
operator (if provided) are tested for domain consistency as follows:
\begin{enumerate}
	\item The domain of {\sf Mask} (if not {\sf GrB\_NULL}) must be from one of 
    the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be 
    compatible with $D_2$i of the unary operator.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $D_x$ and $D_z$ of the accumulation operator and 
    $D_2$ of the unary operator must be compatible with $D_y$ of the accumulation operator.

	\item $\bold{D}({\sf A})$ must be compatible with $D_1$ of the unary operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any consistency rule above is violated, execution of {\sf GrB\_apply} ends
and the domain mismatch error listed above is returned.

From the argument matrices, the internal matrices, mask, and index arrays used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

	\item Two-dimensional mask, $\matrix{\widetilde{M}}$, is computed from 
    argument {\sf Mask} as follows:
	\begin{enumerate}

		\item	If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{M}} = 
        \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), 
        \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < 
        \bold{ncols}({\sf C}) \} \rangle$.

		\item	Otherwise, $\matrix{\widetilde{M}} = \langle 
        \bold{nrows}({\sf Mask}), \bold{ncols}({\sf Mask}), \{(i,j) : 
        ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is set, then 
        $\matrix{\widetilde{M}} \leftarrow \neg \matrix{\widetilde{M}}$.

	\end{enumerate}

	\item Matrix $\matrix{\widetilde{A}} \leftarrow 
    {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$.
    
\end{enumerate}

The internal matrices, mask and arrays are checked for dimension consistency. 
The following conditions must hold:
\begin{enumerate}
	\item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{M}})$.

	\item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{M}})$.

	\item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{A}})$.

	\item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{A}})$.
\end{enumerate}
If any consistency rule above is violated, execution of {\sf GrB\_apply} ends 
and the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can optionally exit
with {\sf GrB\_SUCCESS} return code and defer any computation and/or execution error codes.

We are now ready to carry out the apply and any additional 
associated operations.  We describe this in terms of two intermediate matrices:
\begin{itemize}
    \item $\matrix{\widetilde{T}}$: The matrix holding the result from applying the unary operator to the input matrix
    $\matrix{\widetilde{A}}$.
    
    \item $\matrix{\widetilde{Z}}$: The matrix holding the result after 
    application of the (optional) accumulator.
\end{itemize}

The intermediate matrix, $\matrix{\widetilde{T}}$, is created as follows:
\[
\begin{aligned}
\matrix{\widetilde{T}} = & \langle D_2,
                           \bold{nrows}(\matrix{\widetilde{C}}), 
                           \bold{ncols}(\matrix{\widetilde{C}}),  \bold{L}(\matrix{\widetilde{T}}) =
	\{(i,j,f(\matrix{\widetilde{A}}(i,j))) 
\ \forall \ (i,j) \in 
\bold{ind}(\matrix{\widetilde{A}}) \} \rangle.
\end{aligned}
\]

The intermediate matrix $\matrix{\widetilde{Z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{Z}} \leftarrow \matrix{\widetilde{T}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then matrix $\matrix{\widetilde{Z}}$ is defined as 
        \[ \langle D_z, \bold{nrows}(\matrix{\widetilde{C}}), \bold{ncols}(\matrix{\widetilde{C}}),
        \bold{L}(\matrix{\widetilde{Z}}) 
		= \{(i,j,Z_{ij})  \forall (i,j) \in \bold{ind}(\matrix{\widetilde{C}}) \cup 
        \bold{ind}(\matrix{\widetilde{T}}) \} \rangle. \]

        The values of the elements of $\matrix{\widetilde{Z}}$ are computed based on the 
        relationships between the sets of indices in $\matrix{\widetilde{C}}$ and 
        $\matrix{\widetilde{T}}$.
\[
Z_{ij} = \matrix{\widetilde{C}}(i,j) \odot \matrix{\widetilde{T}}(i,j), \ \mbox{if}\  (i,j) \in  (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}})),
\]
\[
Z_{ij} = \matrix{\widetilde{C}}(i,j) \ \mbox{if}\  (i,j) \in  (\bold{ind}(\matrix{\widetilde{C}}) - (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}}))),
\]
\[
Z_{ij} = \matrix{\widetilde{T}}(i,j) \ \mbox{if}\  (i,j) \in  (\bold{ind}(\matrix{\widetilde{T}}) - (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\matrix{\widetilde{Z}}$ 
matrix are written into the final result matrix, {\sf C}. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set then any values in {\sf C} 
on input to {\sf GrB\_apply()} are deleted and the new output matrix {\sf C} is,
\[ \bold{L}({\sf C}) = \{(i,j,Z_{ij}) : (i,j) \in (\bold{ind}(\matrix{\widetilde{Z}}) 
\cap \bold{ind}(\matrix{\widetilde{M}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of 
$\matrix{\widetilde{Z}}$ indicated by 
the mask are copied into the result matrix, {\sf C}, and elements of 
$\matrix{C}$ that fall outside the set indicated by the mask are unchanged:
\[ \bold{L}({\sf C}) = \{(i,j,C_{ij}) : (i, j) \in (\bold{ind}({\sf C}) 
\cap \bold{ind}(\neg \matrix{\widetilde{M}})) \} \cup \{(i,j,Z_{ij}) : (i,j) \in 
(\bold{ind}(\matrix{\widetilde{Z}}) \cap \bold{ind}(\matrix{\widetilde{M}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of matrix {\sf C} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of matrix {\sf C} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.

%=========================================================================

\subsection{{\sf reduce}: Perform a reduction across the elements of an object}

Computes the reduction of the values of the elements of a vector or matrix.

%-----------------------------------------------------------------------------
\subsubsection{{\sf reduce}: Standard matrix to vector variant}

This performs a row-wise reduction of a matrix to produce a vector.  If column-wise reduction
is desired, the input matrix should be transposed which can be specified using the descriptor.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_reduce(GrB_Vector            *w,
                            const GrB_Vector       mask,
                            const GrB_BinaryOp     accum,
                            const GrB_Monoid       op,  
                            const GrB_Matrix       A,
                            const GrB_Descriptor   desc);
                            
        GrB_Info GrB_reduce(GrB_Vector            *w,
                            const GrB_Vector       mask,
                            const GrB_BinaryOp     accum,
                            const GrB_BinaryOp     op,  
                            const GrB_Matrix       A,
                            const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    reduction operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}]  ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector,
    ${\sf w}$.  If no mask is desired (\ie, all elements
    of result are copied into the output vector), {\sf GrB\_NULL}
    should be specified. The mask dimensions must match those of the
    vector {\sf w} and the domain of {\sf mask} must be
    of type {\sf bool} or any of the predefined ``built-in'' types in
    Table~\ref{Tab:PredefinedTypes}.

    \item[{\sf accum}]    ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf w} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) The monoid or binary operator 
    used in the element-wise reduction operation.  Depending on which type is
    passed, the following defines the binary operator, $F_b=\langle D_1,D_2,D_3,\oplus \rangle$, used:
    \begin{itemize}[leftmargin=1.1in]
    \item[BinaryOp:] $F_b = \langle \bold{D}_1({\sf op}), \bold{D}_2({\sf op}),
    \bold{D}_3({\sf op}),\bold{\bigodot}({\sf op})\rangle$.  
    \item[Monoid:] $F_b = \langle \bold{D}_1({\sf op}), \bold{D}_1({\sf op}),
    \bold{D}_1({\sf op}),\bold{\bigodot}({\sf op})\rangle$,
    the identity element is ignored. 
    \end{itemize}
    
    \item[{\sf A}]     ({\sf IN}) The GraphBLAS matrix on which
	    reduction will be performed.
    
    \item[{\sf desc}]  ({\sf IN}) An optional operation descriptor.  If a \emph{default}
    descriptor is desired, {\sf GrB\_NULL} can be used.  Valid fields are
    as follows: \\
    
    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it. \\
        
	    {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}\\
        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A} for operation. 
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, the operation completed
	    successfully. In non-blocking mode, this indicates that (at least) the consistency 
    tests on dimensions and domains for the input arguments passed successfully. 
    Either way, output vector {\sf w} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]            Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] At least one of the input objects is
	    in an invalid state. Likely caused by a previous execution error.
    Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf w} pointer is {\sf NULL}.
    
    \item[{\sf GrB\_DIMENSION\_MISMATCH}]  {\sf mask}, {\sf w} and/or {\sf u} dimensions are
    incompatible. 
    
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various vectors and matrices are
	incompatible with the corresponding domains of the accumulating operation, 
    mask, or reduce function.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_reduce} computes the result of performing
a reduction across each of the rows of an input matrix:
${\sf w}(i) = \bigoplus {\sf A}(i,:) \forall i$; 
or, if an optional binary accumulation 
operator ($\odot$) is provided, ${\sf w}(i) = {\sf w}(i) \odot (\bigoplus {\sf A}(i,:)) \forall i$.  

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[\bf Setup] The internal vector, matrix and mask used in the computation are formed 
and their domains and dimensions are tested for consistency.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to three vector and matrix argument are used in this {\sf GrB\_reduce} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),
    \bold{L}({\sf w}) = \{(i,w_i) \} \rangle$

	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),
    \bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)

	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}),
    \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
\end{enumerate}

The argument vector, matrix, reduction operator and accumulation 
operator (if provided) are tested for domain consistency as follows:
\begin{enumerate}
	\item The domain of {\sf mask} (if not {\sf GrB\_NULL}) must be from one of 
    the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be 
    compatible with $D_3$ of the reduction binary operator.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $D_x$ and $D_z$ of the accumulation operator and 
    $D_3$ of the reduction binary operator must be compatible with $D_y$ of the accumulation operator.

	\item $\bold{D}({\sf A})$ must be compatible with $D_1$ and $D_2$ of the binary reduction operator.

        \item $D_3$ of the binary reduction operator has to be compatible with $D_1$ of the same operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any consistency rule above is violated, execution of {\sf GrB\_reduce} ends
and the domain mismatch error listed above is returned.

From the argument vectors, the internal vectors and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask, $\vector{\widetilde{m}}$, is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item	If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \forall i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item	Otherwise, $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf mask}), \{i : ({\sf bool}){\sf mask}(i) = 
        \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is \true, then 
        $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Matrix $\matrix{\widetilde{A}} \leftarrow 
    {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$.
    
\end{enumerate}

The internal vectors and masks are checked for for dimension consistency. 
The following conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})$
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{nrows}(\matrix{\widetilde{A}})$.
\end{enumerate}
If any consistency rule above is violated, execution of {\sf GrB\_reduce} ends and 
the dimension mismatch error listed above is returned.

From this point forward, in {\sf GrB\_NONBLOCKING} mode, the method can optionally exit
with {\sf GrB\_SUCCESS} return code and defer any computation and/or execution error codes.

We carry out the reduce and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
	\item $\vector{\widetilde{t}}$: The vector holding the result from reducing along the rows of input matrix
    $\matrix{\widetilde{A}}$.
	\item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulator.
\end{itemize}

The intermediate vector, $\vector{\widetilde{t}}$, is created as follows:
\[ 
\vector{\widetilde{t}} = \langle
D_3, \bold{size}(\vector{\widetilde{w}}),
\bold{L}(\vector{\widetilde{t}}) =
\{(i,t_i) : \bold{ind}(A(i,:)) \neq \emptyset   \} \rangle. 
\]
The value of each of its elements is computed by
\[
	t_i = \bigoplus_{j \in \bold{ind}(\matrix{\widetilde{A}}(i,:))} \matrix{\widetilde{A}}(i,j), 
\]
where $\oplus$ is the binary reduction operator.

The intermediate vector $\vector{\widetilde{z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\vector{\widetilde{z}} \leftarrow \vector{\widetilde{t}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then vector $\vector{\widetilde{z}}$ is defined as 
        \[ \langle D_z, \bold{size}(\vector{\widetilde{w}}), \bold{L}(\vector{\widetilde{z}})
		= \{(i,z_{i})  \forall (i) \in \bold{ind}(\vector{\widetilde{w}}) \cup 
        \bold{ind}(\vector{\widetilde{t}}) \} \rangle.\]
    The values of the elements of $\vector{\widetilde{z}}$ are computed based on the relationships between the sets of indices in $\vector{\widetilde{w}}$ and $\vector{\widetilde{t}}$.
\[
z_{i} = \vector{\widetilde{w}}(i) \odot \vector{\widetilde{t}}(i), \forall i \in  (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}})),
\]
\[
z_{i} = \vector{\widetilde{w}}(i), \forall  i \in  (\bold{ind}(\vector{\widetilde{w}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}}))),
\]
\[
z_{i} = \vector{\widetilde{t}}(i), \forall  i \in  (\bold{ind}(\vector{\widetilde{t}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\vector{\widetilde{z}}$ 
vector are written into the final result vector, {\sf w}. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set then any values in {\sf w} 
on input to {\sf GrB\_reduce()} are deleted and the new output vector {\sf w} is,
\[ \bold{L}({\sf w}) = \{(i,z_{i}) : i \in (\bold{ind}(\vector{\widetilde{z}}) 
\cap \bold{ind}(\vector{\widetilde{m}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of 
$\vector{\widetilde{z}}$ indicated by 
the mask are copied into the result vector, {\sf w}, and elements of 
{\sf w} that fall outside the set indicated by the mask are unchanged:
\[ \bold{L}({\sf w}) = \{(i,w_{i}) : i \in (\bold{ind}({\sf w}) 
\cap \bold{ind}(\neg \vector{\widetilde{m}})) \} \cup \{(i,z_{i}) : i \in 
(\bold{ind}(\vector{\widetilde{z}}) \cap \bold{ind}(\vector{\widetilde{m}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.

%-----------------------------------------------------------------------------
\subsubsection{{\sf reduce}: Vector-scalar variants}
\label{Sec:Reduce_vector_scalar}

Reduce all stored values into a single scalar.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_reduce(<type>                *val,
                            const GrB_BinaryOp     accum,
                            const GrB_Monoid       op,
                            const GrB_Vector       u,
                            const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf val}]    ({\sf INOUT}) Scalar to storpe final reduced value into. On input,
    the scalar provides a value that may be accumulated with the result of the
    reduction operation.  On output, this scalar holds the results of the
    operation.

    \item[{\sf accum}]    ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf val} value: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) The monoid 
    used in the element-wise reduction operation:
    $F_b=\langle D_1,D_2,D_3,\oplus \rangle = \langle \bold{D}_1({\sf op}), \bold{D}_1({\sf op}),
    \bold{D}_1({\sf op}),\bold{\bigodot}({\sf op})\rangle$.
    The monoid identity is used in the definition of the result.
    
    \item[{\sf u}]     ({\sf IN}) The GraphBLAS vector on which
	    reduction will be performed.
    
    \item[{\sf desc}]  ({\sf IN}) An optional operation descriptor.  If a \emph{default}
    descriptor is desired, {\sf GrB\_NULL} can be used.
    Valid fields are
    as follows: \\
    
    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
    \end{tabular}

    \emph{Note:} This argument is defined for consistency with the other GraphBLAS operations.
    There are no parameters that can be set for this operation.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         The operation completed
	    successfully. 
    Output scalar {\sf val} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]            Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] At least one of the input objects is
	    in an invalid state. Likely caused by a previous execution error.
    Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf dup} for vector
    parameters).
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf val} pointer is {\sf NULL}.
    
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of input and output arguments are
	incompatible with the corresponding domains of the accumulating operation, 
     or reduce function.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_reduce} computes the result of performing
a reduction across each of the elements of an input vector:
${\sf val} = \bigoplus {\sf u}(:)$; 
or, if an optional binary accumulation 
operator ($\odot$) is provided, ${\sf val} = {\sf val} \odot (\bigoplus {\sf u}(:))$.  

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[\bf Setup] The internal vector used in the computation is formed 
and its domain is tested for consistency.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output scalar.
\end{enumerate}

One vector argument is used in this {\sf GrB\_reduce} operation:
\begin{enumerate}
	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),
    \bold{L}({\sf u}) = \{(i,u_i) \} \rangle$

\end{enumerate}

The output scalar, argument vector, reduction operator and accumulation 
operator (if provided) are tested for domain consistency as follows:
\begin{enumerate}

	\item If {\sf accum} is {\sf GrB\_NULL}, then ${\sf val}$ must be 
    compatible with $D_3$ of the reduction binary operator.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then ${\sf val}$ must be
    compatible with $D_x$ and $D_z$ of the accumulation operator and 
    $D_3$ of the reduction binary operator must be compatible with $D_y$ of the accumulation operator.

	\item $\bold{D}({\sf u})$ must be compatible with $D_1$ and $D_2$ of the binary reduction operator.

        \item $D_3$ of the binary reduction operator has to be compatible with $D_1$ of the same operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any consistency rule above is violated, execution of {\sf GrB\_reduce} ends
and the domain mismatch error listed above is returned.

From the argument vector, the internal vector used in 
the computation is formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.
\end{enumerate}

We carry out the reduce and any additional 
associated operations.  
First, an intermediate scalar result $t$ is computed using the recurrence:
\[
	t \leftarrow \bold{0}({\sf op}),
\]
\[
	t \leftarrow t \oplus \vector{u}(i), \forall i \in \bold{ind}(\vector{u}). 
\]
Where $\oplus$ is the binary reduction operator.

The final reduction value {\sf val} is computed as follows:
\begin{itemize}
	\item If ${\sf accum} = {\sf GrB\_NULL}$, then ${\sf val} \leftarrow t$.

	\item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then ${\sf val} \leftarrow {\sf val} \odot t$. 
\end{itemize}

In both {\sf GrB\_BLOCKING} and {\sf GrB\_NONBLOCKING}  modes, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of {\sf val} is as defined above
and fully computed.  

%-----------------------------------------------------------------------------
\subsubsection{{\sf reduce}: Matrix-scalar variants}
\label{Sec:Reduce_matrix_scalar}

Reduce all stored values into a single scalar.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_reduce(<type>                *val,
                            const GrB_BinaryOp     accum,
                            const GrB_Monoid       op,
                            const GrB_Matrix       A,
                            const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf val}]    ({\sf INOUT}) Scalar to storpe final reduced value into. On input,
    the scalar provides a value that may be accumulated with the result of the
    reduction operation.  On output, this scalar holds the results of the
    operation.

    \item[{\sf accum}]    ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf val} value: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) The monoid 
    used in the element-wise reduction operation:
    $F_b=\langle D_1,D_2,D_3,\oplus \rangle = \langle \bold{D}_1({\sf op}), \bold{D}_1({\sf op}),
    \bold{D}_1({\sf op}),\bold{\bigodot}({\sf op})\rangle$.
    The monoid identity is used in the definition of the result.
    
    \item[{\sf A}]     ({\sf IN}) The GraphBLAS matrix on which
	    reduction will be performed.
    
    \item[{\sf desc}]  ({\sf IN}) An optional operation descriptor.  If a \emph{default}
    descriptor is desired, {\sf GrB\_NULL} can be used.
    Valid fields are
    as follows: \\
    
    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
    \end{tabular}

    \emph{Note:} This argument is defined for consistency with the other GraphBLAS operations.
    There are no parameters that can be set for this operation.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         The operation completed
	    successfully. 
    Output scalar {\sf val} is ready to be used in the next method of 
    the sequence.

    \item[{\sf GrB\_PANIC}]            Unknown internal error.
    
    \item[{\sf GrB\_INVALID\_OBJECT}] At least one of the input objects is
	    in an invalid state. Likely caused by a previous execution error.
    Call {\sf GrB\_error()} to access 
    any error messages generated by the implementation.

    \item[{\sf GrB\_OUT\_OF\_MEMORY}]  Not enough memory available for operation.
    
    \item[{\sf GrB\_UNINITIALIZED\_OBJECT}] One or more of the GraphBLAS objects 
    has not been initialized by a call to {\sf new} (or {\sf dup} for its class.
    
    \item[{\sf GrB\_NULL\_POINTER}]  {\sf val} pointer is {\sf NULL}.
    
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of input and output arguments are
	incompatible with the corresponding domains of the accumulating operation, 
     or reduce function.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_reduce} computes the result of performing
a reduction across each of the elements of an input matrix:
${\sf val} = \bigoplus {\sf A}(:,:)$; 
or, if an optional binary accumulation 
operator ($\odot$) is provided, ${\sf val} = {\sf val} \odot (\bigoplus {\sf A}(:,:))$.  

Logically, this operation occurs in three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[\bf Setup] The internal matrix used in the computation is formed 
and its domain is tested for consistency.
\item[\bf Compute] The indicated computations are carried out.
\item[\bf Output] The result is written into the output scalar.
\end{enumerate}

One matrix argument is used in this {\sf GrB\_reduce} operation:
\begin{enumerate}
	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{size}({\sf A}),
		\bold{L}({\sf A}) = \{(i,j,A_{i,j}) \} \rangle$

\end{enumerate}

The output scalar, argument matrix, reduction operator and accumulation 
operator (if provided) are tested for domain consistency as follows:
\begin{enumerate}

	\item If {\sf accum} is {\sf GrB\_NULL}, then ${\sf val}$ must be 
    compatible with $D_3$ of the reduction binary operator.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then ${\sf val}$ must be
    compatible with $D_x$ and $D_z$ of the accumulation operator and 
    $D_3$ of the reduction binary operator must be compatible with $D_y$ of the accumulation operator.

	\item $\bold{D}({\sf A})$ must be compatible with $D_1$ and $D_2$ of the binary reduction operator.

        \item $D_3$ of the binary reduction operator has to be compatible with $D_1$ of the same operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any consistency rule above is violated, execution of {\sf GrB\_reduce} ends
and the domain mismatch error listed above is returned.

From the argument matrix, the internal matrix used in 
the computation is formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Matrix $\matrix{\widetilde{A}} \leftarrow {\sf A}$.
\end{enumerate}

We carry out the reduce and any additional 
associated operations.  
First, an intermediate scalar result $t$ is computed using the recurrence:
\[
	t \leftarrow \bold{0}({\sf op}),
\]
\[
	t \leftarrow t \oplus \matrix{A}(i,j), \forall (i,j) \in \bold{ind}(\matrix{A}). 
\]
Where $\oplus$ is the binary reduction operator.

The final reduction value {\sf val} is computed as follows:
\begin{itemize}
	\item If ${\sf accum} = {\sf GrB\_NULL}$, then ${\sf val} \leftarrow t$.

	\item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then ${\sf val} \leftarrow {\sf val} \odot t$. 
\end{itemize}

In both {\sf GrB\_BLOCKING} and {\sf GrB\_NONBLOCKING}  modes, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of {\sf val} is as defined above
and fully computed.  


%=========================================================================

\subsection{{\sf transpose}: Transpose rows and columns of a matrix}

This version materializes a new matrix that is the transpose of the source matrix.

\scott{TODO: Need to discuss if we will support C and A referencing the same matrix
with the meaning that in-place transpose is to be performed. With immutable dimensions
and non-square matrices this should be disallowed or throw a DIMENSION\_MISMATCH.}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_transpose(GrB_Matrix            *C,
                               const GrB_Matrix       Mask,
                               const GrB_BinaryOp     accum,
                               const GrB_Matrix       A,
                               const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]     ({\sf INOUT}) The matrix to assign the result.

    \item[{\sf Mask}]  ({\sf IN}) Output mask. The mask specifies which elements
    of {\sf C} can be modified. If no mask is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) Operator used for accumulation into {\sf C}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf A}]     ({\sf IN}) The matrix to transpose.

    \item[{\sf desc}]  ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C} is cleared (all elements removed) before result is stored in it. \\
    {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf Mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.

\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf C} pointer is {\sf NULL}.

\item[{\sf GrB\_DIMENSION\_MISMATCH}]      
        If the size/shape of {\sf C} is not the same as either {\sf Mask} or {\sf A} (or its transpose, if specified).
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrices and/or
        accum function \scott{elaborate}
\end{itemize}

\paragraph{Description}

\scott{This needs Jose's touch to get at explicit semantics.}

The {\sf C} matrix must have already been created with the proper dimensions
prior to calling this function.  Stored values are inserted into {\sf C} to
create a transpose of the {\sf A} matrix where 
${\sf C}(j,i) = {\sf A}(i,j) ~ \forall ~ (i,j) \in \bold{L}({\sf A})$.
If accum is specified then the function is used to combine with existing values in {\sf C} using {\sf eWiseAdd} semantics:
${\sf C}(j,i) \oplus = {\sf A}(i,j) ~ \forall ~ (i,j) \in \bold{L}({\sf A})$.
When {\sf Mask} is specified the destination location will only be assigned if the corresponding location in {\sf Mask} has a stored value.
