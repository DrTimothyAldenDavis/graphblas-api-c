\subsection{{\sf apply}: Apply a unary function to the elements of an object}

%-----------------------------------------------------------------------------

\subsubsection{{\sf apply}: Vector variant}
\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Vector            *w,
                           const GrB_Vector       mask,
                           const GrB_BinaryOp     accum,
                           const GrB_UnaryOp      op,
                           const GrB_Vector       u,
                           const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]     ({\sf INOUT}) The vector to assign the result.

    \item[{\sf mask}]  ({\sf IN}) Output mask. The mask
    specifies which elements of {\sf w} can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) Operator used for accumulating entries into existing {\sf w} entries. 
			If no accumulation is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) The unary function (operation) to apply to each stored element in {\sf u}.
    \item[{\sf u}]     ({\sf IN}) The vector to apply the function to.
    \item[{\sf desc}]  ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w} is cleared (all elements removed) before result is stored in it. \\
    {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.

\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf w} pointer is {\sf NULL}.

\item[{\sf GrB\_DIMENSION\_MISMATCH}]            
        If the size of {\sf w} is not the same as either {\sf mask} or {\sf u}
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrices, unary function, and/or
        accum function \scott{elaborate}
\end{itemize}

\paragraph{Description}

The {\sf w} vector must have already been created with the proper dimensions
prior to calling this function.  The unary operator computes over stored values in {\sf u} and the results are assigned to corresponding location in {\sf w}.
The results of the unary function can be optionally accumulated with existing values in {\sf w} using {\sf accum}.  Assignment into {\sf w} can be optionally masked.

%--------------------------------------------------------------

\subsubsection{{\sf apply}: Matrix variant}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_apply(GrB_Matrix             *C,
                           const GrB_Matrix        Mask,
                           const GrB_BinaryOp      accum,
                           const GrB_UnaryOp       op,
                           const GrB_Matrix        A,
                           const GrB_Descriptor    desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]     ({\sf INOUT}) The matrix to assign the result.

    \item[{\sf Mask}]  ({\sf IN}) Output mask. The mask
    specifies which elements of {\sf C} can be modified.
    If no mask is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) Operator used for accumulating entries into existing {\sf C} entries. 
			If no accumulation is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) The unary function (operation) to apply to each stored element in {\sf A}.
    \item[{\sf A}]     ({\sf IN}) The matrix to apply the function to.
    \item[{\sf desc}]  ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C} is cleared (all elements removed) before result is stored in it. \\
    {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}    & Use the structural complement of {\sf Mask}. \\
    {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}    & Use the transpose {\sf A} for the operation.\\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.

\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf C} pointer is {\sf NULL}.

\item[{\sf GrB\_DIMENSION\_MISMATCH}]            
        If the size/shape of {\sf C} is not the same as either {\sf Mask} or {\sf A} (or its transpose if specified).
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrices, unary function, and/or
        accum function \scott{elaborate}
\end{itemize}

\paragraph{Description}

The {\sf C} matrix must have already been created with the proper dimensions
prior to calling this function.  The unary operator computes on stored values in {\sf A} and the results are assigned to corresponding location in {\sf C}.
The input matrix, {\sf A}, can be optionally transposed first.  The results of the unary function can be optionally accumulated with existing values in {\sf C} using accum.  Assignment into {\sf C} can be optionally masked.

%=========================================================================

\subsection{{\sf reduce}: Perform a reduction across the elements of an object}

Computes the reduction of the values of the elements of a vector or matrix.

%-----------------------------------------------------------------------------
\subsubsection{{\sf reduce}: Standard matrix to vector variant}

This performs a row-wise reduction of a matrix to produce a vector.  If column-wise reduction
is desired, the input matrix should be transposed which can be specified using the descriptor.

\paragraph{\syntax}

\begin{verbatim}
        // Using a Monoid
        GrB_Info GrB_reduce(GrB_Vector            *w,
                            const GrB_Vector       mask,
                            const GrB_BinaryOp     accum,
                            const GrB_Monoid       op,  
                            const GrB_Matrix       A,
                            const GrB_Descriptor   desc);
                            
        // Using a BinaryOp
        GrB_Info GrB_reduce(GrB_Vector            *w,
                            const GrB_Vector       mask,
                            const GrB_BinaryOp     accum,
                            const GrB_BinaryOp     op,  
                            const GrB_Matrix       A,
                            const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]     ({\sf INOUT}) Vector/Matrix to be assigned.

    \item[{\sf mask}]  ({\sf IN}) Output mask. The mask specifies which elements
    of {\sf w} can be modified. If no mask is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) Operator used for accumulation into {\sf w}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) Operator used to perform the reduction of elements from {\sf A}.  If a Monoid is specified, its binary operator is used.
    \item[{\sf A}]     ({\sf IN}) The matrix on which to operate.

    \item[{\sf desc}]  ({\sf IN}) Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w} is cleared (all elements removed) before result is stored in it. \\
    {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}    & Use the structural complement of {\sf mask}. \\
    {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}    & Use the transpose of {\sf A} 
    resulting in a column-wise reduction. \\
    \end{tabular}

\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]    operation completed successfully.
\item[{\sf GrB\_PANIC}]      unknown internal error.

\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf w} pointer is {\sf NULL}.

\item[{\sf GrB\_DIMENSION\_MISMATCH}]            
        If the size of {\sf w} is not the same as {\sf mask} or $\bold{m}({\sf A})$ (or its transpose if specified).
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrices, operator, or
        accum function \scott{elaborate}
\end{itemize}


\paragraph{Description}

Matrix \matrix{A} is computed from input parameter {\sf A} as specified
by descriptor {\sf desc}. Specifically, it computes the (sparse) vector of row ``sums'' if 
GrB\_TRAN  is not set, and the vector of column ``sums'' if GrB\_TRAN  is set. It then
stores this result vector into {\sf w}. $\vector{mask}$ is also computed from input parameter {\sf mask}
as specified by descriptor {\sf desc}.

In its simplest form, when called on a $m$-by-$n$ matrix \matrix{A}, this function returns a vector ${\sf w}$ 
of length $m$. Each entry ${\sf w}(i)$ is the ``sum'' of all entries in the $i$th row of 
{\sf A} with respect to the monoid or BinaryOp {\sf op}. 


A new vector $\vector{w} = \langle \bold{D}_3({\sf op}),
\bold{n}(\matrix{A}), \bold{L}(\vector{w}) = \{(i,w_i) : \vector{mask}(i)
= {\sf true} \} \rangle$ is created.  Let us denote the binary operation of the monoid or BinaryOp {\sf op} by $\oplus$,
then the value of each of $\vector{w}$'s elements
is computed by $ \vector{w}(i) = \matrix{A}(i,0) \oplus \matrix{A}(i,1) \oplus  \ldots \oplus  \matrix{A}(i,n)$.  
 

Finally, output parameter {\sf w} is computed from vector $\vector{w}$
as specified by descriptor {\sf desc}. In the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified. 
 If $\vector{w}(i)$ is empty, due to reducing an empty row or column, then the outcome depends on the variable {\sf accum}.
  if {\sf accum} is GrB\_NULL, then ${\sf w}(i)$ is also empty. If {\sf accum} is GrB\_ACCUM, then ${\sf w}(i)$ is unchanged.
A consistency check is
performed to verify that $\bold{n}({\sf w}) = \bold{n}(\vector{w})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.


%-----------------------------------------------------------------------------
\subsubsection{{\sf reduce}: Vector-scalar variants}
\label{Sec:Reduce_vector_scalar}

Reduce all stored values into a single scalar.

\scott{TODO: do we need to support an input mask for this variant?}

\scott{TODO: Need to have conversation about whether op can/should also take a semiring}

\scott{TODO: Should we support accum in this variant?}


\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_reduce(<type>                *val,
                            const GrB_BinaryOp     accum,
                            const GrB_Monoid       op,
                            const GrB_Vector       u,
                            const GrB_Descriptor   desc);
\end{verbatim}


\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf val}]    ({\sf INOUT}) Scalar to store final reduced value into.  The type must be
                        consistent with the domain of {\sf u} or {\sf accum} (if used).

    \item[{\sf accum}]  ({\sf IN}) Operator used for accumulation into {\sf val}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]     ({\sf IN}) Monoid defining the reduction operator.
    \item[{\sf u}]    Vector to be reduced.

    \item[{\sf desc}]   ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf val} & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & \scott{There are no reasonable descriptor parameters for this function.} \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully.
\item[{\sf GrB\_PANIC}]               unknown internal error.

\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf val} pointer is {\sf NULL}.

\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among vector/matrix, monoid operation, and/or
        accum function, and {\sf val} \scott{elaborate}
\end{itemize}

\paragraph{Description}

\scott{NEEDS REWRITE}

Let $0 = \bold{0}({\sf op})$, and let $\oplus = \bigodot({\sf op})$ (for monoids).
\scott{Let $\oplus = \bigoplus({\sf op})$ if op is a semiring.}

Vector $\vector{u}$ is computed from input parameter ${\sf u}$ as
specified by descriptor {\sf desc}. If $\vector{u}$ cannot be computed
from the input parameters, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

A scalar variable $s$ such that $\bold{D}(s) = \bold{D_3}({\sf op})$ is
created and initialized $s \leftarrow \bold{0}({\sf op})$. 
We then compute the recurrence $s \leftarrow s \oplus u_i, \forall i \in \vector{i}(\vector{u})$.

Finally, output parameter {\sf val} is computed from scalar $s$.

%-----------------------------------------------------------------------------
\subsubsection{{\sf reduce}: Matrix-scalar variants}
\label{Sec:Reduce_matrix_scalar}

Reduce all stored values into a single scalar.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_reduce(<type>                *val,
                            const GrB_BinaryOp     accum,
                            const GrB_Monoid       op,
                            const GrB_Matrix       A,
                            const GrB_Descriptor   desc);
\end{verbatim}


\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf val}]    ({\sf INOUT}) Scalar to store final reduced value into.  The type must be
                        consistent with the domain of {\sf A} or {\sf accum} (if used).

    \item[{\sf accum}]  ({\sf IN}) Operator used for accumulation into {\sf val}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]     ({\sf IN}) Monoid defining the reduction operator.
    \item[{\sf A}]    Vector/matrix to be reduced.

    \item[{\sf desc}]   ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} isj to be
    used.  Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf val} & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & \scott{There are no reasonable descriptor parameters for this function.} \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully.
\item[{\sf GrB\_PANIC}]               unknown internal error.

\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf val} pointer is {\sf NULL}.

\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrix, monoid operation, and/or
        accum function, and {\sf val} \scott{elaborate}
\end{itemize}

\paragraph{Description}

\scott{NEEDS REWRITE}

Let $0 = \bold{0}({\sf op})$, and let $\oplus = \bigodot({\sf op})$ (for monoids).
\scott{Let $\oplus = \bigoplus({\sf op})$ if op is a semiring.}

Matrix $\matrix{A}$ is computed from input parameter ${\sf A}$ as
specified by descriptor {\sf desc}. If $\matrix{A}$ cannot be computed
from the input parameters, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

A scalar variable $s$ such that $\bold{D}(s) = \bold{D_3}({\sf op})$ is
created and initialized $s \leftarrow \bold{0}({\sf op})$. 
We then compute the recurrence $s \leftarrow s \oplus A_{ij}, \forall (i, j) \in \bold{L}(\matrix{A})$.

Finally, output parameter {\sf val} is computed from scalar $s$.

%=========================================================================

\subsection{{\sf transpose}: Transpose rows and columns of a matrix}

This version materializes a new matrix that is the transpose of the source matrix.

\scott{TODO: Need to discuss if we will support C and A referencing the same matrix
with the meaning that in-place transpose is to be performed. With immutable dimensions
and non-square matrices this should be disallowed or throw a DIMENSION\_MISMATCH.}

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_transpose(GrB_Matrix            *C,
                               const GrB_Matrix       Mask,
                               const GrB_BinaryOp     accum,
                               const GrB_Matrix       A,
                               const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]     ({\sf INOUT}) The matrix to assign the result.

    \item[{\sf Mask}]  ({\sf IN}) Output mask. The mask specifies which elements
    of {\sf C} can be modified. If no mask is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] ({\sf IN}) Operator used for accumulation into {\sf C}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf A}]     ({\sf IN}) The matrix to transpose.

    \item[{\sf desc}]  ({\sf IN}) Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used.  Valid fields and values are as follows: \\ ~\\
    \begin{tabular}{lllp{2.5in}}
    Param & Field  & Value & Description \\
    \hline
    {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C} is cleared (all elements removed) before result is stored in it. \\
    {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf Mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.

\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          one or more of the GraphBLAS objects has
                                    not been initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf C} pointer is {\sf NULL}.

\item[{\sf GrB\_DIMENSION\_MISMATCH}]      
        If the size/shape of {\sf C} is not the same as either {\sf Mask} or {\sf A} (or its transpose, if specified).
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  
        domain mismatch among matrices and/or
        accum function \scott{elaborate}
\end{itemize}

\paragraph{Description}

\scott{This needs Jose's touch to get at explicit semantics.}

The {\sf C} matrix must have already been created with the proper dimensions
prior to calling this function.  Stored values are inserted into {\sf C} to
create a transpose of the {\sf A} matrix where 
${\sf C}(j,i) = {\sf A}(i,j) ~ \forall ~ (i,j) \in \bold{L}({\sf A})$.
If accum is specified then the function is used to combine with existing values in {\sf C} using {\sf eWiseAdd} semantics:
${\sf C}(j,i) \oplus = {\sf A}(i,j) ~ \forall ~ (i,j) \in \bold{L}({\sf A})$.
When {\sf Mask} is specified the destination location will only be assigned if the corresponding location in {\sf Mask} has a stored value.
