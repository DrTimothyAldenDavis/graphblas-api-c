\subsubsection{{\sf eWiseMult}: Element-wise multiplication}

{\bf Note:} The difference between {\sf eWiseAdd} and {\sf eWiseMult} is not 
about the semiring operation but how the index sets are treated.
{\sf eWiseAdd} returns an object whose indices are the ``union'' of the 
indices of the inputs whereas {\sf eWiseMult} returns an object whose indices 
are the ``intersection'' of the indices of the inputs. In both cases, the 
passed monoid (or function) operates on the set of values from the 
intersection set. 
 
\paragraph{Vector variant}

Perform element-wise (general) multiplication on the elements of two vectors,
producing a third vector as result.

\subparagraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_eWiseMult(GrB_Vector               w,
                               const GrB_Monoid         op, 
                               const GrB_Vector         u,
                               const GrB_Vector         v
                            [, const GrB_MaskVector     mask
                            [, const GrB_Descriptor     desc
                            [, const GrB_BinaryFunction accum]]]);
                            
        GrB_info GrB_eWiseMult(GrB_Vector               w,
                               const GrB_BinaryFunction op, 
                               const GrB_Vector         u,
                               const GrB_Vector         v
                            [, const GrB_MaskVector     mask
                            [, const GrB_Descriptor     desc
                            [, const GrB_BinaryFunction accum]]]);
\end{verbatim}

\subparagraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]     ({\sf OUTP}) An existing vector to hold the result.
    \item[{\sf op}]    ({\sf ARG0}) monoid/function used in the element-wise multiplication.
    \item[{\sf u}]     ({\sf ARG1}) Left hand operand.
    \item[{\sf v}]     ({\sf ARG2}) Right hand operand.

    \item[{\sf mask}] ({\sf MASK}) Output mask vector (optional). The mask
    specifies which elements of the result vector can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} can be used or the mask can be omitted.

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted. Valid fields are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf OUTP} & {\sf GrB\_CAST} & Allow casting from $\bold{D}_3({\sf op})$ to $\bold{D}(\vector{w})$. \\
    {\sf ARG1} & {\sf GrB\_CAST} & Allow casting from $\bold{D}(\vector{u})$ to $\bold{D}_1({\sf op})$. \\
    {\sf ARG2} & {\sf GrB\_CAST} & Allow casting from $\bold{D}(\vector{v})$ to $\bold{D}_2({\sf op})$. \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf ACCUM}& {\sf GrB\_ACC}  & Use the {\sf accum} function to add to existing values in {\sf C}.\\
    \end{tabular}

  	\item[{\sf accum}]  Function used for accumulating entries with existing \vector{w} entries. (optional).
\end{itemize}

\subparagraph{Return Value}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among vectors dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of vectors, and operation, for which the descriptor did not explicitly allow casting.
\end{itemize}

\subparagraph{Description}

%If {\sf op} is a semiring, then $\otimes = \bigotimes({\sf op})$. 
%If {\sf op} is a monoid or function, then $\otimes = \bigoplus({\sf op})$.

The binary operation, {\sf op}, whether it is a monoid or a binary function
is generically referred to as $\otimes$ in this discussion.

Vectors $\vector{v}, \vector{m}$ and $\vector{u}$ are computed from
input parameters {\sf v}, {\sf m} and {\sf u}, respectively, as specified
by descriptor {\sf d}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting, can be specified.)  $\bold{D}(\vector{u}) =
\bold{D}_1({\sf op})$ and $\bold{D}(\vector{v}) = \bold{D}_2({\sf op})$.
$\bold{D}(\vector{m}) = {\sf GrB\_BOOL}$.  If {\sf m} is {\sf GrB\_NULL} or omitted,
then $\vector{m}$ is a Boolean vector of size $\bold{n}(\vector{u})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{m}$ or $\vector{u}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{n}(\vector{u}) = \bold{n}(\vector{m})$. If a consistency
check fails, the operation is aborted and the method returns {\sf
GrB\_DIMENSION\_MISMATCH}.

A new vector $\vector{w} = \langle \bold{D}_3({\sf op}),
\bold{n}(\vector{u}), \bold{L}(\vector{w}) = \{(i,w_i)  \forall i \in
\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}) : \vector{m}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its
elements is computed by $w_i = \vector{u}(i) \otimes \vector{v}(i)$,
where $\otimes$ is as defined above from {\sf op}.
If $\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}) = \emptyset$
then $\bold{L}(\vector{w}) = \emptyset$.

Finally, output parameter {\sf w} is computed from vector $\vector{w}$
as specified by descriptor {\sf d}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf w}) = \bold{n}(\vector{w})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.

%-----------------------------------------------------------------------------

\paragraph{Matrix variant}

Placeholder

\aydin{Aydin to fill}


\subparagraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_eWiseMult(GrB_Matrix               C,
                               const GrB_Monoid         op, 
                               const GrB_Matrix         A,
                               const GrB_Matrix         B
                            [, const GrB_MaskMatrix     mask
                            [, const GrB_Descriptor     desc
                            [, const GrB_BinaryFunction accum]]]);
                            
        GrB_info GrB_eWiseMult(GrB_Matrix               C,
                               const GrB_BinaryFunction op, 
                               const GrB_Matrix         A,
                               const GrB_Matrix         B
                            [, const GrB_MaskMatrix     mask
                            [, const GrB_Descriptor     desc
                            [, const GrB_BinaryFunction accum]]]);
\end{verbatim}


%-----------------------------------------------------------------------------


\subsubsection{{\sf eWiseAdd}: Element-wise addition}

{\bf Note:} The difference between {\sf eWiseAdd} and {\sf eWiseMult} is not about the semiring operation but how the index sets are treated.
 {\sf eWiseAdd} returns an object whose indices are the ``union'' of the indices of the inputs whereas  
 {\sf eWiseMult} returns an object whose indices are the ``intersection'' of the indices of the inputs. In both cases, the passed monoid (or function) operates on the 
 set of values from the intersection set. 

\paragraph{Vector variant}

Perform element-wise (general) addition on the elements of two vectors,
producing a third vector as result.

\subparagraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_eWiseAdd(GrB_Vector               w,
                              const GrB_Monoid         op, 
                              const GrB_Vector         u,
                              const GrB_Vector         v
                           [, const GrB_MaskVector     mask
                           [, const GrB_Descriptor     desc
                           [, const GrB_BinaryFunction accum]]]);
                            
        GrB_info GrB_eWiseAdd(GrB_Vector               w,
                              const GrB_BinaryFunction op, 
                              const GrB_Vector         u,
                              const GrB_Vector         v
                           [, const GrB_MaskVector     mask
                           [, const GrB_Descriptor     desc
                           [, const GrB_BinaryFunction accum]]]);
\end{verbatim}

\subparagraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]     ({\sf OUTP}) An existing vector to hold the result.
    \item[{\sf op}]    ({\sf ARG0}) monoid/function used in the element-wise addition.
    \item[{\sf u}]     ({\sf ARG1}) Left hand operand.
    \item[{\sf v}]     ({\sf ARG2}) Right hand operand.

    \item[{\sf mask}] ({\sf MASK}) Output mask vector (optional). The mask
    specifies which elements of the result vector can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} can be used or the mask can be omitted.

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted. Valid fields are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf OUTP} & {\sf GrB\_CAST} & Allow casting from $\bold{D}_3({\sf op})$ to $\bold{D}(\vector{w})$. \\
    {\sf ARG1} & {\sf GrB\_CAST} & Allow casting from $\bold{D}(\vector{u})$ to $\bold{D}_1({\sf op})$. \\
    {\sf ARG2} & {\sf GrB\_CAST} & Allow casting from $\bold{D}(\vector{v})$ to $\bold{D}_2({\sf op})$. \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf ACCUM}& {\sf GrB\_ACC}  & Use the {\sf accum} function to add to existing values in {\sf C}.\\
    \end{tabular}

  	\item[{\sf accum}]  Function used for accumulating entries with existing \vector{w} entries. (optional).
\end{itemize}

\subparagraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among vectors dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of vectors, and operation, for which the descriptor did not explicitly allow casting.
\end{itemize}

\subparagraph{Description}

%If {\sf op} is a semiring, then $\oplus = \bigoplus({\sf op})$. 
%If {\sf op} is a monoid or function, then $\oplus = \bigoplus({\sf op})$.

The binary operation, {\sf op}, whether it is a monoid or a binary function
is generically referred to as $\oplus$ in this discussion.

Vectors $\vector{v}, \vector{m}$ and $\vector{u}$ are computed from
input parameters {\sf v}, {\sf m} and {\sf u}, respectively, as specified
by descriptor {\sf d}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting, can be specified.)  $\bold{D}(\vector{u}) =
\bold{D}_3({\sf op})$ and $\bold{D}(\vector{v}) = \bold{D}_3({\sf op})$.
$\bold{D}(\vector{m}) = {\sf GrB\_BOOL}$.  If {\sf m} is {\sf GrB\_NULL} or omitted,
then $\vector{m}$ is a Boolean vector of size $\bold{n}(\vector{u})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{m}$ or $\vector{u}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{n}(\vector{u}) = \bold{n}(\vector{m})$. If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A new vector $\vector{w} = \langle \bold{D}_3({\sf op}),
\bold{n}(\vector{u}), \bold{L}(\vector{w}) = \{(i,w_i)  \forall i \in
\vector{i}(\vector{v}) \cup \vector{i}(\vector{u}) : \vector{m}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its
elements is computed by 
\[
w_i = \vector{u}(i) \oplus \vector{v}(i), \ \mbox{if}\  i \in  \vector{i}(\vector{v}) \cap \vector{i}(\vector{u})
\]
\[
w_i = \vector{u}(i) \ \mbox{if}\  i \in  \vector{i}(\vector{u}) - (\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}))
\]
\[
w_i = \vector{v}(i) \ \mbox{if}\  i \in  \vector{i}(\vector{v}) - (\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}))
\]
where $\oplus$ is as defined above for {\sf op}.
If $\vector{i}(\vector{v}) \cup \vector{i}(\vector{u}) = \emptyset$
then $\bold{L}(\vector{w}) = \emptyset$.

Finally, output parameter {\sf w} is computed from vector $\vector{w}$
as specified by descriptor {\sf d}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf w}) = \bold{n}(\vector{w})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.

%-----------------------------------------------------------------------------

\paragraph{Matrix variant}

Placeholder

\aydin{Aydin to fill}


\subparagraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_eWiseAdd(GrB_Matrix               C,
                              const GrB_Monoid         op, 
                              const GrB_Matrix         A,
                              const GrB_Matrix         B
                           [, const GrB_MaskMatrix     mask
                           [, const GrB_Descriptor     desc
                           [, const GrB_BinaryFunction accum]]]);
                            
        GrB_info GrB_eWiseAdd(GrB_Matrix               C,
                              const GrB_BinaryFunction op, 
                              const GrB_Matrix         A,
                              const GrB_Matrix         B
                           [, const GrB_MaskMatrix     mask
                           [, const GrB_Descriptor     desc
                           [, const GrB_BinaryFunction accum]]]);
\end{verbatim}

