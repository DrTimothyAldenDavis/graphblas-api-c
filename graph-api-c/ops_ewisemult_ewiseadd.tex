\subsubsection{Element-wise multiplication ({\sf eWiseMult})}

{\bf Note:} The difference between {\sf ewiseadd} and {\sf ewisemult} is not about the semiring operation but how the index sets are treated.
 {\sf ewiseadd} returns an object whose indices are the ``union'' of the indices of the inputs whereas  
 {\sf ewisemult} returns an object whose indices are the ``intersection'' of the indices of the inputs. In both cases, the passed monoid (or function) operates on the 
 set of values from the intersection set. 
 
\paragraph{Vector variant}

Perform element-wise (general) multiplication on the elements of two vectors,
producing a third vector as result.

\subparagraph{C99 Syntax}

\begin{verbatim}
#include "GraphBLAS.h"
GrB_info GrB_ewisemult(GrB_Vector* w, const GrB_Semiring s, const GrB_Vector u,
         const GrB_Vector v[, const GrB_Vector m[, const GrB_Descriptor d]])
GrB_info GrB_ewisemult(GrB_Vector* w, const GrB_Monoid s, const GrB_Vector u,
         const GrB_Vector v[, const GrB_Vector m[, const GrB_Descriptor d]])
GrB_info GrB_ewisemult(GrB_Vector* w, const GrB_Function s, const GrB_Vector u,
         const GrB_Vector v[, const GrB_Vector m[, const GrB_Descriptor d]])
\end{verbatim}

\subparagraph{Input Parameters}

\begin{itemize}
	\item[{\sf s}] ({\sf ARG0}) Semiring/monoid/function used in the element-wise multiplication.

	\item[{\sf u}] ({\sf ARG1}) Left vector to be multiplied.

	\item[{\sf v}] ({\sf ARG2}) Right vector to be multiplied.

	\item[{\sf m}] ({\sf MASK}) Operation mask (optional). The mask
	specifies which elements of the result vector are to be computed.
	If no mask is necessary (i.e., compute all elements of result
	vector), {\sf GrB\_NULL} can be used or the mask can be omitted.

	\item[{\sf d}] Operation descriptor (optional). The descriptor
	is used to specify details of the operation, such as 
	invert the mask or not (see below). If a
	\emph{default} descriptor is desired, {\sf GrB\_NULL} can be
	used or the descriptor can be omitted.
\end{itemize}

\subparagraph{Output Parameter}

\begin{itemize}
	\item[{\sf w}] ({\sf OUTP}) Address of result vector.
\end{itemize}

\subparagraph{Return Value}

\begin{tabular}{rl} 
{\sf GrB\_SUCCESS} 	& operation completed successfully \\
{\sf GrB\_PANIC}	& unknown internal error \\
{\sf GrB\_OUTOFMEM}	& not enough memory available for operation \\
{\sf GrB\_MISMATCH}	& mismatch among vectors and/or semiring/monoid/function
\end{tabular}

\subparagraph{Description}

If {\sf s} is a semiring, then $\otimes = \bigotimes({\sf s})$. 
If {\sf s} is a monoid or function, then $\otimes = \bigoplus({\sf s})$.

Vectors $\vector{v}, \vector{m}$ and $\vector{u}$ are computed from
input parameters {\sf v}, {\sf m} and {\sf u}, respectively, as specified
by descriptor {\sf d}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting, can be specified.)  $\bold{D}(\vector{u}) =
\bold{D}_1({\sf s})$ and $\bold{D}(\vector{v}) = \bold{D}_2({\sf s})$.
$\bold{D}(\vector{m}) = {\sf GrB\_BOOL}$.  If {\sf m} is {\sf GrB\_NULL} or omitted,
then $\vector{m}$ is a Boolean vector of size $\bold{n}(\vector{u})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{m}$ or $\vector{u}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{n}(\vector{u}) = \bold{n}(\vector{m})$. If a consistency
check fails, the operation is aborted and the method returns {\sf
GrB\_MISMATCH}.

A new vector $\vector{w} = \langle \bold{D}_3({\sf s}),
\bold{n}(\vector{u}), \bold{L}(\vector{w}) = \{(i,w_i)  \forall i \in
\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}) : \vector{m}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its
elements is computed by $w_i = \vector{u}(i) \otimes \vector{v}(i)$,
where $\otimes$ is as defined above for {\sf s}.
If $\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}) = \emptyset$
then $\bold{L}(\vector{w}) = \emptyset$.

Finally, output parameter {\sf w} is computed from vector $\vector{w}$
as specified by descriptor {\sf d}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf w}) = \bold{n}(\vector{w})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_MISMATCH}.

\subsubsection{Element-wise addition ({\sf eWiseAdd})}

{\bf Note:} The difference between {\sf ewiseadd} and {\sf ewisemult} is not about the semiring operation but how the index sets are treated.
 {\sf ewiseadd} returns an object whose indices are the ``union'' of the indices of the inputs whereas  
 {\sf ewisemult} returns an object whose indices are the ``intersection'' of the indices of the inputs. In both cases, the passed monoid (or function) operates on the 
 set of values from the intersection set. 

\paragraph{Vector variant}

Perform element-wise (general) addition on the elements of two vectors,
producing a third vector as result.

\subparagraph{C99 Syntax}

\begin{verbatim}
#include "GraphBLAS.h"
GrB_info GrB_ewiseadd(GrB_Vector* w, const GrB_Semiring s, const GrB_Vector u,
         const GrB_Vector v[, const GrB_Vector m[, const GrB_Descriptor d]])
GrB_info GrB_ewiseadd(GrB_Vector* w, const GrB_Monoid s, const GrB_Vector u,
         const GrB_Vector v[, const GrB_Vector m[, const GrB_Descriptor d]])
GrB_info GrB_ewiseadd(GrB_Vector* w, const GrB_Function s, const GrB_Vector u,
         const GrB_Vector v[, const GrB_Vector m[, const GrB_Descriptor d]])
\end{verbatim}

\subparagraph{Input Parameters}

\begin{itemize}
	\item[{\sf s}] ({\sf ARG0}) Semiring/monoid/function used in the element-wise addition.

	\item[{\sf u}] ({\sf ARG1}) Left vector to be added.

	\item[{\sf v}] ({\sf ARG2}) Right vector to be added.

	\item[{\sf m}] ({\sf MASK}) Operation mask (optional). The mask
	specifies which elements of the result vector are to be computed.
	If no mask is necessary (i.e., compute all elements of result
	vector), {\sf GrB\_NULL} can be used or the mask can be omitted.

	\item[{\sf d}] Operation descriptor (optional). The descriptor
	is used to specify details of the operation, such as 
	invert the mask or not (see below). If a
	\emph{default} descriptor is desired, {\sf GrB\_NULL} can be
	used or the descriptor can be omitted.
\end{itemize}

\subparagraph{Output Parameter}

\begin{itemize}
	\item[{\sf w}] ({\sf OUTP}) Address of result vector.
\end{itemize}

\subparagraph{Return Value}

\begin{tabular}{rl} 
{\sf GrB\_SUCCESS} 	& operation completed successfully \\
{\sf GrB\_PANIC}	& unknown internal error \\
{\sf GrB\_OUTOFMEM}	& not enough memory available for operation \\
{\sf GrB\_MISMATCH}	& mismatch among vectors, matrix and/or semiring/monoid/function
\end{tabular}

\subparagraph{Description}

If {\sf s} is a semiring, then $\oplus = \bigoplus({\sf s})$. 
If {\sf s} is a monoid or function, then $\oplus = \bigoplus({\sf s})$.

Vectors $\vector{v}, \vector{m}$ and $\vector{u}$ are computed from
input parameters {\sf v}, {\sf m} and {\sf u}, respectively, as specified
by descriptor {\sf d}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting, can be specified.)  $\bold{D}(\vector{u}) =
\bold{D}_3({\sf s})$ and $\bold{D}(\vector{v}) = \bold{D}_3({\sf s})$.
$\bold{D}(\vector{m}) = {\sf GrB\_BOOL}$.  If {\sf m} is {\sf GrB\_NULL} or omitted,
then $\vector{m}$ is a Boolean vector of size $\bold{n}(\vector{u})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{m}$ or $\vector{u}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{n}(\vector{u}) = \bold{n}(\vector{m})$. If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_MISMATCH}.

A new vector $\vector{w} = \langle \bold{D}_3({\sf s}),
\bold{n}(\vector{u}), \bold{L}(\vector{w}) = \{(i,w_i)  \forall i \in
\vector{i}(\vector{v}) \cup \vector{i}(\vector{u}) : \vector{m}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its
elements is computed by 
\[
w_i = \vector{u}(i) \oplus \vector{v}(i), \ \mbox{if}\  i \in  \vector{i}(\vector{v}) \cap \vector{i}(\vector{u})
\]
\[
w_i = \vector{u}(i) \ \mbox{if}\  i \in  \vector{i}(\vector{u}) - (\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}))
\]
\[
w_i = \vector{v}(i) \ \mbox{if}\  i \in  \vector{i}(\vector{v}) - (\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}))
\]
where $\oplus$ is as defined above for {\sf s}.
If $\vector{i}(\vector{v}) \cup \vector{i}(\vector{u}) = \emptyset$
then $\bold{L}(\vector{w}) = \emptyset$.

Finally, output parameter {\sf w} is computed from vector $\vector{w}$
as specified by descriptor {\sf d}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf w}) = \bold{n}(\vector{w})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_MISMATCH}.
