\subsection{{\sf eWiseMult}: Element-wise multiplication}

{\bf Note:} The difference between {\sf eWiseAdd} and {\sf eWiseMult} is not 
about the semiring operation but how the index sets are treated.
{\sf eWiseAdd} returns an object whose indices are the ``union'' of the 
indices of the inputs whereas {\sf eWiseMult} returns an object whose indices 
are the ``intersection'' of the indices of the inputs. In both cases, the 
passed semiring, monoid, or operator operates on the set of values from the 
resulting index set. 

\comment{
\scott{Two points need to be revisited for ewiseX operations.  First, 'add' and 'mult'
really are a misnomer and have been the source of much confusion.  ewiseunion and
ewiseintersection really are much more descriptive.  Second, we are not in agreement
about whether or not to support the semiring interface as you need to then carefully
document which of the semirings binary operators will be used.  I recommend removal,
while providing helper functions that can 'wrap' semirings that extract the 
appropriate binary function: extract\_add(sr) or extract\_mult(sr).}

\aydin{As everyone will remember, I am all for both suggestions: rename to 
intersect/union (ewise union/intersect is an oxymoron so ewise- prefix should 
not be there) and don't support the confusing semiring version}
}

\subsubsection{{\sf eWiseMult}: Vector variant}

Perform element-wise (general) multiplication on the intersection of elements 
of two vectors, producing a third vector as result.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_eWiseMult(GrB_Vector            *w,
                               const GrB_Vector       mask,
                               const GrB_BinaryOp     accum,
                               const GrB_Semiring     op, 
                               const GrB_Vector       u,
                               const GrB_Vector       v,
                               const GrB_Descriptor   desc);
                            
        GrB_Info GrB_eWiseMult(GrB_Vector            *w,
                               const GrB_Vector       mask,
                               const GrB_BinaryOp     accum,
                               const GrB_Monoid       op, 
                               const GrB_Vector       u,
                               const GrB_Vector       v,
                               const GrB_Descriptor   desc);
                            
        GrB_Info GrB_eWiseMult(GrB_Vector            *w,
                               const GrB_Vector       mask,
                               const GrB_BinaryOp     accum,
                               const GrB_BinaryOp     op, 
                               const GrB_Vector       u,
                               const GrB_Vector       v,
                               const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    element-wise operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}]  ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector
    ${\sf w}$.  If no mask is desired (\ie, all elements
    of result are copied into the output vector), {\sf GrB\_NULL}
    should be specified. The mask dimensions must match those of the
    vector {\sf w} and the domain of {\sf mask} must be
    of type {\sf bool} or any of the predefined ``built-in'' types in
    Table~\ref{Tab:PredefinedTypes}.

    \item[{\sf accum}] ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf w} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) The semiring, monoid, or binary operator 
    used in the element-wise ``product'' operation.  Depending on which type is
    passed, the following defines the binary operator, $F_b=\langle D_1,D_2,D_3,\otimes\rangle$, used:
    \begin{itemize}[leftmargin=1.1in]
    \item[BinaryOp:] $F_b = \langle \bold{D}_1({\sf op}), \bold{D}_2({\sf op}),
    \bold{D}_3({\sf op}),\bold{\bigodot}({\sf op})\rangle$.  
    \item[Monoid:] $F_b = \langle \bold{D}_1({\sf op}), \bold{D}_1({\sf op}),
    \bold{D}_1({\sf op}),\bold{\bigodot}({\sf op})\rangle$,
    the identity element is ignored. 
    \item[Semiring:] $F_b = \langle \bold{D}_1({\sf op}), \bold{D}_2({\sf op}),
    \bold{D}_3({\sf op}),\bold{\bigotimes}({\sf op})\rangle$.  The semiring's
    additive monoid is ignored.
    \end{itemize}
    
    \item[{\sf u}]     ({\sf IN}) The GraphBLAS vector holding the values for
    the left-hand vector in the operation.
    
    \item[{\sf v}]     ({\sf IN}) The GraphBLAS vector holding the values for
    the right-hand vector in the operation.

    \item[{\sf desc}]  ({\sf IN}) An optional operation descriptor.  If a \emph{default}
    descriptor is desired, {\sf GrB\_NULL} can be used.  Valid fields are
    as follows: \\
    
    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before the result is stored in it. \\
        
        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural 
        complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, operation
	completed successfully. In non-blocking mode, this indicates
	that the consistency tests on dimensions and domains for the
	input arguments passed successfully. Either way, output vector
	{\sf w} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_OUTOFMEM}]        Not enough memory available for operation.
    
    \item[{\sf GrB\_NOOBJECT}]        One or more of the GraphBLAS objects has
    not been initialized by a call to {\sf new}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf w} pointer is {\sf NULL}.

    \item[{\sf GrB\_DIMENSION\_MISMATCH}] Mask or vector dimensions are incompatible.

	\item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various
	vectors are incompatible with the corresponding domains of the
	accumulating operation, binary operator ({\sf op}), or mask.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_eWiseMult} computes the element-wise ``product'' of
two GraphBLAS vectors: ${\sf w} = {\sf u} \otimes {\sf v}$, or, if an optional
binary accumulation operator ($\odot$) is provided, ${\sf w} = {\sf w} \odot
\left({\sf u} \otimes {\sf v}\right)$.  Logically, this operation occurs in
three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for consistency.
\item[Compute] The indicated computations are carried out.
\item[Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to four argument vectors are used in the {\sf GrB\_eWiseMult} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),\bold{L}({\sf w}) = \{(i,w_i) \} \rangle$
	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),\bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)
	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),\bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
	\item ${\sf v} = \langle \bold{D}({\sf v}),\bold{size}({\sf v}),\bold{L}({\sf v}) = \{(i,v_i) \} \rangle$
\end{enumerate}

The argument vectors, the ``product'' operator ({\sf op}), and the accumulator 
operator (if provided) are tested for domain consistency as follows:
\begin{enumerate}
	\item The domain of {\sf mask} (if not {\sf GrB\_NULL}) must be from one of the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item $\bold{D}({\sf u})$ must be compatible with $D_1$ of {\sf op}.

	\item $\bold{D}({\sf v})$ must be compatible with $D_2$ of {\sf op}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be 
    compatible with $D_3$ of the {\sf op}.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $D_x$ and $D_z$ of the accumulator operator and $D_3$ of
    {\sf op} must be compatible with $D_y$ of the accumulator operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any consistency rule above is violated, execution of {\sf GrB\_eWiseMult} ends
and the domain mismatch error listed above is returned.

From the argument vectors, the internal vectors and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask $\vector{\widetilde{m}}$ is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item	If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \forall i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item	Otherwise, $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf mask}), \{i : ({\sf bool}){\sf mask}(i) = 
        \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is set, then $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.

	\item Vector $\vector{\widetilde{v}} \leftarrow {\sf v}$.
\end{enumerate}

The internal vectors and masks are checked for shape consistency. The following 
conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})
    = \bold{size}(\vector{\widetilde{u}}) = \bold{size}(\vector{\widetilde{v}})$.
\end{enumerate}
If any consistency rule above is violated, execution of {\sf GrB\_eWiseMult} ends and 
the dimension mismatch error listed above is returned.

We are now ready to carry out the element-wise ``product'' and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
	\item $\vector{\widetilde{t}}$: The vector holding the element-wise ``product'' of
    $\vector{\widetilde{u}}$ and vector $\vector{\widetilde{v}}$.
	\item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulator.
\end{itemize}

The intermediate vector $\vector{\widetilde{t}} = \langle
D_3, \bold{size}(\vector{\widetilde{u}}),
\bold{L}(\vector{\widetilde{t}}) =
\{(i,t_i) : \bold{ind}(\vector{\widetilde{u}}) \cap 
\bold{ind}(\vector{\widetilde{v}})
 \neq \emptyset \} \rangle$
is created.  The value of each of its elements is computed by 
\[t_i = (\vector{\widetilde{u}}(i)
\otimes \vector{\widetilde{v}}(i)), \forall i \in 
(\bold{ind}(\vector{\widetilde{u}}) \cap 
\bold{ind}(\vector{\widetilde{v}}))\]

The intermediate vector $\vector{\widetilde{z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\vector{\widetilde{z}} = \vector{\widetilde{t}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then vector $\vector{\widetilde{z}}$ is defined as 
        \[ \langle D_z, \bold{size}(\vector{\widetilde{w}}), \bold{L}(\vector{\widetilde{z}})
		= \{(i,z_{i})  \forall (i) \in \bold{ind}(\vector{\widetilde{w}}) \cup 
        \bold{ind}(\vector{\widetilde{t}}) \} \rangle.\]
    The values of the elements of $\vector{\widetilde{z}}$ are computed based on the 
    relationships between the sets of indices in $\vector{\widetilde{w}}$ and 
    $\vector{\widetilde{t}}$.
\[
z_{i} = \vector{\widetilde{w}}(i) \odot \vector{\widetilde{t}}(i), \ \mbox{if}\  i \in  (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}})),
\]
\[
z_{i} = \vector{\widetilde{w}}(i), \ \mbox{if}\  i \in  (\bold{ind}(\vector{\widetilde{w}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}}))),
\]
\[
z_{i} = \vector{\widetilde{t}}(i), \ \mbox{if}\  i \in  (\bold{ind}(\vector{\widetilde{t}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\vector{\widetilde{z}}$ 
vector are written into the final result vector, $\vector{w}$. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set, then any values in $\vector{w}$ 
on input to {\sf GrB\_eWiseMult()} are deleted and the new output vector $\vector{w}$ is,
\[ \bold{L}({\sf w}) = \{(i,z_{i}) : i \in (\bold{ind}(\vector{\widetilde{z}}) 
\cap \bold{ind}(\vector{\widetilde{m}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of $\vector{\widetilde{z}}$ indicated by 
the mask are copied into the result vector, $\vector{w}$, and elements of 
$\vector{w}$ that fall outside the set indicated by the mask are unchanged:
\[ \bold{L}({\sf w}) = \{(i,w_{i}) : i \in (\bold{ind}(\vector{\sf w}) 
\cap \bold{ind}(\neg \vector{\widetilde{m}})) \} \cup \{(i,z_{i}) : i \in 
(\bold{ind}(\vector{\widetilde{m}}) \cap \bold{ind}(\vector{\widetilde{z}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.


%=============================================================================
\comment{
\paragraph{OLD Description}

A consistency check is performed to verify that $\bold{n}({\sf mask})
= \bold{n}({\sf u}) = \bold{n}({\sf v}) = \bold{n}({\sf w})$. If a consistency
check fails, the operation is aborted and the method returns {\sf
GrB\_DIMENSION\_MISMATCH}.

Vectors $\vector{m}, \vector{u}$ and $\vector{v}$ are computed from
input parameters {\sf mask}, {\sf u} and {\sf v}, respectively, as specified
by descriptor {\sf desc}.  If {\sf mask} is {\sf GrB\_NULL},
then $\vector{m}$ is a Boolean vector of size $\bold{n}(\vector{w})$
and with all elements set to {\sf true}.

If any of $\vector{m}, \vector{u}$ or $\vector{v}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A new vector $\vector{u} = \langle \bold{D}_3({\sf op}),
\bold{n}(\vector{v}), \bold{L}(\vector{u}) = \{(i,u_i)  \forall i \in
\vector{i}(\vector{v}) \cap \vector{i}(\vector{w}) : \vector{m}(i)
\in \bold{L}(\vector{m}) \} \rangle$ is created.  If 
$\vector{i}(\vector{v}) \cap \vector{i}(\vector{w}) = \emptyset$
then $\bold{L}(\vector{u}) = \emptyset$.

The value of each of its elements is computed by 
$u_i = \vector{v}(i) \otimes \vector{w}(i)$, where
$\otimes = \bigotimes({\sf op})$ if {\sf op} is a semiring, and 
$\otimes = \bigodot({\sf op})$ if {\sf op} is a monoid or binary operator.

Finally, output parameter {\sf u} is computed from vector $\vector{u}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting, can be specified.)
}
%=============================================================================

%-----------------------------------------------------------------------------

\subsubsection{{\sf eWiseMult}: Matrix variant}

Perform element-wise (general) multiplication on the intersection of elements 
of two matrices, producing a third matrix as result.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_eWiseMult(GrB_Matrix            *C,
                               const GrB_Matrix       Mask,
                               const GrB_BinaryOp     accum,
                               const GrB_Semiring     op, 
                               const GrB_Matrix       A,
                               const GrB_Matrix       B,
                               const GrB_Descriptor   desc);
                            
        GrB_Info GrB_eWiseMult(GrB_Matrix            *C,
                               const GrB_Matrix       Mask,
                               const GrB_BinaryOp     accum,
                               const GrB_Monoid       op, 
                               const GrB_Matrix       A,
                               const GrB_Matrix       B,
                               const GrB_Descriptor   desc);
                            
        GrB_Info GrB_eWiseMult(GrB_Matrix            *C,
                               const GrB_Matrix       Mask,
                               const GrB_BinaryOp     accum,
                               const GrB_BinaryOp     op, 
                               const GrB_Matrix       A,
                               const GrB_Matrix       B,
                               const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS matrix.  On input,
    the matrix provides values that may be accumulated with the result of the
    element-wise operation.  On output, this matrix holds the results of the
    operation.
    
    \item[{\sf Mask}]  ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix
    ${\sf C}$.  If no mask is desired (\ie, all elements
    of result are copied into the output matrix), {\sf GrB\_NULL}
    should be specified. The mask dimensions must match those of the
    matrix {\sf C} and the domain of {\sf Mask} must be
    of type {\sf bool} or any of the predefined ``built-in'' types in
    Table~\ref{Tab:PredefinedTypes}.

    \item[{\sf accum}] ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf C} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) The semiring, monoid, or binary operator 
    used in the element-wise ``product'' operation.  Depending on which type is
    passed, the following defines the binary operator, $F_b=\langle D_1,D_2,D_3,\otimes\rangle$, used:
    \begin{itemize}[leftmargin=1.1in]
    \item[BinaryOp:] $F_b = \langle \bold{D}_1({\sf op}), \bold{D}_2({\sf op}),
    \bold{D}_3({\sf op}),\bold{\bigodot}({\sf op})\rangle$.  
    \item[Monoid:] $F_b = \langle \bold{D}_1({\sf op}), \bold{D}_1({\sf op}),
    \bold{D}_1({\sf op}),\bold{\bigodot}({\sf op})\rangle$,
    the identity element is ignored. 
    \item[Semiring:] $F_b = \langle \bold{D}_1({\sf op}), \bold{D}_2({\sf op}),
    \bold{D}_3({\sf op}),\bold{\bigotimes}({\sf op})\rangle$.  The semiring's
    additive monoid is ignored.
    \end{itemize}
    
    \item[{\sf A}]     ({\sf IN}) The GraphBLAS matrix holding the values for
    the left-hand matrix in the operation.
    
    \item[{\sf B}]     ({\sf IN}) The GraphBLAS matrix holding the values for
    the right-hand matrix in the operation.
    
    \item[{\sf desc}]  ({\sf IN}) An optional operation descriptor.  If a \emph{default}
    descriptor is desired, {\sf GrB\_NULL} can be used.  Valid fields are
    as follows: \\
    
    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C} is cleared (all elements removed) before the result is stored in it.  \\
        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf Mask}. \\
        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A} for operation. \\
        {\sf B}    & {\sf GrB\_INP1} & {\sf GrB\_TRAN}   & Use transpose of {\sf B} for operation. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, operation
	completed successfully. In non-blocking mode, this indicates
	that the consistency tests on dimensions and domains for the
	input arguments passed successfully. Either way, output matrix
	{\sf C} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_OUTOFMEM}]        Not enough memory available for operation.
    
    \item[{\sf GrB\_NOOBJECT}]        One or more of the GraphBLAS objects has
    not been initialized by a call to {\sf new}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf C} pointer is {\sf NULL}.

    \item[{\sf GrB\_DIMENSION\_MISMATCH}] Mask or matrix dimensions are incompatible.

	\item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various
	matrices are incompatible with the corresponding domains of the
	accumulating operation, binary operator ({\sf op}), or mask.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_eWiseMult} computes the element-wise ``product'' of
two GraphBLAS matrices: ${\sf C} = {\sf A} \otimes {\sf B}$, or, if an optional
binary accumulation operator ($\odot$) is provided, ${\sf C} = {\sf C} \odot
\left({\sf A} \otimes {\sf B}\right)$.  Logically, this operation occurs in
three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[Setup] The internal matrices and mask used in the computation are formed 
and their domains and dimensions are tested for consistency.
\item[Compute] The indicated computations are carried out.
\item[Output] The result is written into the output matrix, possibly under 
control of a mask.
\end{enumerate}

Up to four argument matrices are used in the {\sf GrB\_eWiseMult} operation:
\begin{enumerate}
	\item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),\bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$
	\item ${\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}({\sf Mask}),\bold{ncols}({\sf Mask}),\bold{L}({\sf Mask}) = \{(i,j,M_{ij}) \} \rangle$ (optional)
	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}), \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
	\item ${\sf B} = \langle \bold{D}({\sf B}),\bold{nrows}({\sf B}), \bold{ncols}({\sf B}),\bold{L}({\sf B}) = \{(i,j,B_{ij}) \} \rangle$
\end{enumerate}

The argument matrices, the ``product'' operator ({\sf op}), and the accumulator 
operator (if provided) are tested for domain consistency as follows:
\begin{enumerate}
	\item The domain of {\sf Mask} (if not {\sf GrB\_NULL}) must be from one of the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item $\bold{D}({\sf A})$ must be compatible with $D_1$ of {\sf op}.

	\item $\bold{D}({\sf B})$ must be compatible with $D_2$ of {\sf op}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be 
    compatible with $D_3$ of the {\sf op}.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $D_x$ and $D_z$ of the accumulator operator and $D_3$ of
    {\sf op} must be compatible with $D_y$ of the accumulator operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any consistency rule above is violated, execution of {\sf GrB\_eWiseMult} ends
and the domain mismatch error listed above is returned.

From the argument matrices, the internal matrices and mask used in the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

	\item Two-dimensional mask $\matrix{\widetilde{M}}$ is computed from argument {\sf Mask} as follows:
	\begin{enumerate}

		\item	If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < \bold{ncols}({\sf C}) \} \rangle$.

		\item	Otherwise, $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), \bold{ncols}({\sf Mask}), \{(i,j) : ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is set, then $\matrix{\widetilde{M}} \leftarrow \neg \matrix{\widetilde{M}}$.

	\end{enumerate}

	\item Matrix $\matrix{\widetilde{A}} \leftarrow {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$.

	\item Matrix $\matrix{\widetilde{B}} \leftarrow {\sf desc[GrB\_INP1].GrB\_TRAN} \ ? \ {\sf B}^T : {\sf B}$.
\end{enumerate}

The internal matrices and masks are checked for shape consistency. The following conditions must hold:
\begin{enumerate}	
	\item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{M}})
	     = \bold{nrows}(\matrix{\widetilde{A}}) = \bold{nrows}(\matrix{\widetilde{C}})$.

	\item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{M}})
	     = \bold{ncols}(\matrix{\widetilde{A}}) = \bold{ncols}(\matrix{\widetilde{C}})$.
\end{enumerate}
If any consistency rule above is violated, execution of {\sf GrB\_eWiseMult} ends and the dimension mismatch error listed above is returned.

We are now ready to carry out the element-wise ``product'' and any additional 
associated operations.  We describe this in terms of two intermediate matrices:
\begin{itemize}
	\item $\matrix{\widetilde{T}}$: The matrix holding the element-wise product of
    $\matrix{\widetilde{A}}$ and matrix $\matrix{\widetilde{B}}$.
	\item $\matrix{\widetilde{Z}}$: The matrix holding the result after 
    application of the (optional) accumulator.
\end{itemize}

The intermediate matrix $\matrix{\widetilde{T}} = \langle
D_3, \bold{nrows}(\matrix{\widetilde{A}}), \bold{ncols}(\matrix{\widetilde{A}}),
\bold{L}(\matrix{\widetilde{T}}) =
\{(i,j,T_{ij}) : \bold{ind}(\matrix{\widetilde{A}}) \cap 
\bold{ind}(\matrix{\widetilde{B}})
 \neq \emptyset \} \rangle$
is created.  The value of each of its elements is computed by 
\[T_{ij} = (\matrix{\widetilde{A}}(i,j)
\otimes \matrix{\widetilde{B}}(i,j)), \forall (i,j) \in 
\bold{ind}(\matrix{\widetilde{A}}) \cap 
\bold{ind}(\matrix{\widetilde{B}}).\]

The intermediate matrix $\matrix{\widetilde{Z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{Z}} = \matrix{\widetilde{T}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then matrix $\matrix{\widetilde{Z}}$ is defined as 
        \[ \langle D_z, \bold{nrows}(\matrix{\widetilde{C}}), \bold{ncols}(\matrix{\widetilde{C}}), \bold{L}(\matrix{\widetilde{Z}})
		= \{(i,j,Z_{ij})  \forall (i,j) \in \bold{ind}(\matrix{\widetilde{C}}) \cup 
        \bold{ind}(\matrix{\widetilde{T}}) \} \rangle.\]
    The values of the elements of $\matrix{\widetilde{Z}}$ are computed based on the 
    relationships between the sets of indices in $\matrix{\widetilde{C}}$ and 
    $\matrix{\widetilde{T}}$.
\[
Z_{ij} = \matrix{\widetilde{C}}(i,j) \odot \matrix{\widetilde{T}}(i,j), \ \mbox{if}\  (i,j) \in  (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}})),
\]
\[
Z_{ij} = \matrix{\widetilde{C}}(i,j), \ \mbox{if}\  (i,j) \in  (\bold{ind}(\matrix{\widetilde{C}}) - (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}}))),
\]
\[
Z_{ij} = \matrix{\widetilde{T}}(i,j), \ \mbox{if}\  (i,j) \in  (\bold{ind}(\matrix{\widetilde{T}}) - (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\matrix{\widetilde{Z}}$ 
matrix are written into the final result matrix, $\matrix{C}$. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set, then any values in $\matrix{C}$ 
on input to {\sf GrB\_eWiseMult()} are deleted and the new output matrix $\matrix{C}$ is,
\[ \bold{L}({\sf C}) = \{(i,j,Z_{ij}) : (i,j) \in (\bold{ind}(\matrix{\widetilde{Z}}) 
\cap \bold{ind}(\matrix{\widetilde{M}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of $\matrix{\widetilde{Z}}$ indicated by 
the mask are copied into the result matrix, $\matrix{C}$, and elements of 
$\matrix{C}$ that fall outside the set indicated by the mask are unchanged:
\[ \bold{L}({\sf C}) = \{(i,j,C_{ij}) : (i,j) \in (\bold{ind}(\matrix{\sf C}) 
\cap \bold{ind}(\neg \matrix{\widetilde{M}})) \} \cup \{(i,j,Z_{ij}) : (i,j) \in 
(\bold{ind}(\matrix{\widetilde{Z}}) \cap \bold{ind}(\matrix{\widetilde{M}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of matrix {\sf C} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of matrix {\sf C} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.


%===========================================================================
\comment{
\paragraph{OLD Description}

A consistency check is performed to verify that the 
dimensions of {\sf C}, {\sf Mask}, {\sf A} and {\sf B}
are compatible, taking into consideration any transposition specified.
If a consistency check fails, the operation is aborted and the method 
returns {\sf GrB\_DIMENSION\_MISMATCH}.

Matrices $\matrix{A}, \matrix{M}$ and $\matrix{B}$ are computed from
input parameters {\sf A}, {\sf Mask} and {\sf B}, respectively, as specified
by descriptor {\sf desc}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting and transposition, can be performed.)  $\bold{D}(\matrix{A}) =
\bold{D}_1({\sf op})$ and $\bold{D}(\matrix{B}) = \bold{D}_2({\sf op})$.
$\bold{D}(\matrix{M}) = {\sf GrB\_BOOL}$.  If {\sf Mask} is {\sf GrB\_NULL},
then $\vector{M}$ is a Boolean matrix of size $\bold{m}(\matrix{\sf C}) \times \bold{n}(\matrix{\sf C})$
and with all elements set to {\sf true}.

If either $\matrix{B}, \matrix{M}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.  \scott{Too vague}

A new matrix $\matrix{C} = \langle \bold{D}_3({\sf op}), \bold{m}(\matrix{\sf C}),
\bold{n}(\matrix{\sf C}), \bold{L}(\matrix{C}) = \{(i,j,C_{ij})  \forall (i,j) \in
\bold{L}(\matrix{B}) \cap \bold{L}(\matrix{A}) : \matrix{M}(i,j)
= {\sf true} \} \rangle$ is created.  
If $\bold{L}(\matrix{B}) \cap \bold{L}(\matrix{A}) = \emptyset$
then $\bold{L}(\matrix{C}) = \emptyset$.

The value of each of its elements is computed by 
$C_{ij} = \matrix{A}(i,j) \otimes \matrix{B}(i,j)$, where
$\otimes = \bigotimes({\sf op})$ if {\sf op} is a semiring, and 
$\otimes = \bigodot({\sf op})$ if {\sf op} is a monoid or binary operator.

Finally, output parameter {\sf C} is computed from vector $\matrix{C}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be performed.) 
}
%=============================================================================


\subsection{{\sf eWiseAdd}: Element-wise addition}

{\bf Note:} The difference between {\sf eWiseAdd} and {\sf eWiseMult} is not 
about the semiring operation but how the index sets are treated.
{\sf eWiseAdd} returns an object whose indices are the ``union'' of the indices 
of the inputs whereas  
{\sf eWiseMult} returns an object whose indices are the ``intersection'' of the 
indices of the inputs. In both cases, the passed semiring, monoid, or operator 
operates on the set of values from the resulting index set. 

%-----------------------------------------------------------------------------

\subsubsection{{\sf eWiseAdd}: Vector variant}

Perform element-wise (general) addition on the elements of two vectors,
producing a third vector as result.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_eWiseAdd(GrB_Vector            *w,
                              const GrB_Vector       mask,
                              const GrB_BinaryOp     accum,
                              const GrB_Semiring     op, 
                              const GrB_Vector       u,
                              const GrB_Vector       v,
                              const GrB_Descriptor   desc);
                            
        GrB_Info GrB_eWiseAdd(GrB_Vector            *w,
                              const GrB_Vector       mask,
                              const GrB_BinaryOp     accum,
                              const GrB_Monoid       op, 
                              const GrB_Vector       u,
                              const GrB_Vector       v,
                              const GrB_Descriptor   desc);

        GrB_Info GrB_eWiseAdd(GrB_Vector            *w,
                              const GrB_Vector       mask,
                              const GrB_BinaryOp     accum,
                              const GrB_BinaryOp     op, 
                              const GrB_Vector       u,
                              const GrB_Vector       v,
                              const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]    ({\sf INOUT}) An existing GraphBLAS vector.  On input,
    the vector provides values that may be accumulated with the result of the
    element-wise operation.  On output, this vector holds the results of the
    operation.

    \item[{\sf mask}]  ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output vector
    ${\sf w}$.  If no mask is desired (\ie, all elements
    of result are copied into the output vector), {\sf GrB\_NULL}
    should be specified. The mask dimensions must match those of the
    vector {\sf w} and the domain of {\sf mask} must be
    of type {\sf bool} or any of the predefined ``built-in'' types in
    Table~\ref{Tab:PredefinedTypes}.

    \item[{\sf accum}] ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf w} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) The semiring, monoid, or binary operator 
    used in the element-wise ``sum'' operation.  Depending on which type is
    passed, the following defines the binary operator, 
    $F_b=\langle D_1,D_2,D_3,\oplus\rangle$, used:
    \begin{itemize}[leftmargin=1.1in]
    \item[BinaryOp:] $F_b = \langle \bold{D}_1({\sf op}), \bold{D}_2({\sf op}),
    \bold{D}_3({\sf op}),\bold{\bigodot}({\sf op})\rangle$.  
    \item[Monoid:] $F_b = \langle \bold{D}_1({\sf op}), \bold{D}_1({\sf op}),
    \bold{D}_1({\sf op}),\bold{\bigodot}({\sf op})\rangle$,
    the identity element is ignored. 
    \item[Semiring:] $F_b = \langle \bold{D}_1({\sf op}), \bold{D}_2({\sf op}),
    \bold{D}_3({\sf op}),\bold{\bigoplus}({\sf op})\rangle$.  The semiring's 
    multiplicative binary op and additive identity are ignored.
    \end{itemize}
    
    \item[{\sf u}]     ({\sf IN}) The GraphBLAS vector holding the values for
    the left-hand vector in the operation.
    
    \item[{\sf v}]     ({\sf IN}) The GraphBLAS vector holding the values for
    the right-hand vector in the operation.

    \item[{\sf desc}]  ({\sf IN}) An optional operation descriptor.  If a \emph{default}
    descriptor is desired, {\sf GrB\_NULL} can be used.  Valid fields are
    as follows: \\
    
    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf w}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output vector {\sf w}
        is cleared (all elements removed) before result is stored in it. \\
        {\sf mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural
        complement of {\sf mask}. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, operation
	completed successfully. In non-blocking mode, this indicates
	that the consistency tests on dimensions and domains for the
	input arguments passed successfully. Either way, output vector
	{\sf w} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_OUTOFMEM}]        Not enough memory available for operation.
    
    \item[{\sf GrB\_NOOBJECT}]        One or more of the GraphBLAS objects has
    not been initialized by a call to {\sf new}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf w} pointer is {\sf NULL}.

    \item[{\sf GrB\_DIMENSION\_MISMATCH}] Mask or vector dimensions are incompatible.

	\item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various
	vectors are incompatible with the corresponding domains of the
	accumulating operation, binary operator ({\sf op}), or mask.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_eWiseAdd} computes the element-wise ``sum'' of
two GraphBLAS vectors: ${\sf w} = {\sf u} \oplus {\sf v}$, or, if an optional
binary accumulation operator ($\odot$) is provided, ${\sf w} = {\sf w} \odot
\left({\sf u} \oplus {\sf v}\right)$.  Logically, this operation occurs in
three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[Setup] The internal vectors and mask used in the computation are formed 
and their domains and dimensions are tested for consistency.
\item[Compute] The indicated computations are carried out.
\item[Output] The result is written into the output vector, possibly under 
control of a mask.
\end{enumerate}

Up to four argument vectors are used in the {\sf GrB\_eWiseAdd} operation:
\begin{enumerate}
	\item ${\sf w} = \langle \bold{D}({\sf w}),\bold{size}({\sf w}),\bold{L}({\sf w}) = \{(i,w_i) \} \rangle$
	\item ${\sf mask} = \langle \bold{D}({\sf mask}),\bold{size}({\sf mask}),\bold{L}({\sf mask}) = \{(i,m_i) \} \rangle$ (optional)
	\item ${\sf u} = \langle \bold{D}({\sf u}),\bold{size}({\sf u}),\bold{L}({\sf u}) = \{(i,u_i) \} \rangle$
	\item ${\sf v} = \langle \bold{D}({\sf v}),\bold{size}({\sf v}),\bold{L}({\sf v}) = \{(i,v_i) \} \rangle$
\end{enumerate}

The argument vectors, the ``sum'' operator ({\sf op}), and the accumulator 
operator (if provided) are tested for domain consistency as follows:
\begin{enumerate}
	\item The domain of {\sf mask} (if not {\sf GrB\_NULL}) must be from one of the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item $\bold{D}({\sf u})$ must be compatible with $D_1$ of {\sf op}.

	\item $\bold{D}({\sf v})$ must be compatible with $D_2$ of {\sf op}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be 
    compatible with $D_3$ of the {\sf op}.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf w})$ must be
    compatible with $D_x$ and $D_z$ of the accumulator operator and $D_3$ of
    {\sf op} must be compatible with $D_y$ of the accumulator operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any consistency rule above is violated, execution of {\sf GrB\_eWiseMult} ends
and the domain mismatch error listed above is returned.

From the argument vectors, the internal vectors and mask used in 
the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Vector $\vector{\widetilde{w}} \leftarrow {\sf w}$.

	\item One-dimensional mask $\vector{\widetilde{m}}$ is computed from 
    argument {\sf mask} as follows:
	\begin{enumerate}
		\item	If ${\sf mask} = {\sf GrB\_NULL}$, then $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf w}), \{i, \forall i : 0 \leq i < 
        \bold{size}({\sf w}) \} \rangle$.

		\item	Otherwise, $\vector{\widetilde{m}} = 
        \langle \bold{size}({\sf mask}), \{i : ({\sf bool}){\sf mask}(i) = 
        \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is set, then $\vector{\widetilde{m}} \leftarrow \neg \vector{\widetilde{m}}$.
	\end{enumerate}

	\item Vector $\vector{\widetilde{u}} \leftarrow {\sf u}$.

	\item Vector $\vector{\widetilde{v}} \leftarrow {\sf v}$.
\end{enumerate}

The internal vectors and masks are checked for shape consistency. The following 
conditions must hold:
\begin{enumerate}
	\item $\bold{size}(\vector{\widetilde{w}}) = \bold{size}(\vector{\widetilde{m}})
    = \bold{size}(\vector{\widetilde{u}}) = \bold{size}(\vector{\widetilde{v}})$.
\end{enumerate}
If any consistency rule above is violated, execution of {\sf GrB\_eWiseMult} ends and 
the dimension mismatch error listed above is returned.

We are now ready to carry out the element-wise ``sum'' and any additional 
associated operations.  We describe this in terms of two intermediate vectors:
\begin{itemize}
	\item $\vector{\widetilde{t}}$: The vector holding the element-wise ``sum'' of
    $\vector{\widetilde{u}}$ and vector $\vector{\widetilde{v}}$.
	\item $\vector{\widetilde{z}}$: The vector holding the result after 
    application of the (optional) accumulator.
\end{itemize}

The intermediate vector $\vector{\widetilde{t}} = \langle
D_3, \bold{size}(\vector{\widetilde{u}}),
\bold{L}(\vector{\widetilde{t}}) =
\{(i,t_i) : \bold{ind}(\vector{\widetilde{u}}) \cap 
\bold{ind}(\vector{\widetilde{v}})
 \neq \emptyset \} \rangle$
is created.  The value of each of its elements is computed by:
\[t_i = (\vector{\widetilde{u}}(i) \oplus \vector{\widetilde{v}}(i)), \forall i \in (\bold{ind}(\vector{\widetilde{u}}) \cap \bold{ind}(\vector{\widetilde{v}}))\]
\[t_i = \vector{\widetilde{u}}(i), \forall i \in (\bold{ind}(\vector{\widetilde{u}}) - (\bold{ind}(\vector{\widetilde{v}}) \cap \bold{ind}(\vector{\widetilde{u}})))\]
\[t_i = \vector{\widetilde{v}}(i), \forall i \in (\bold{ind}(\vector{\widetilde{v}}) - (\bold{ind}(\vector{\widetilde{v}}) \cap \bold{ind}(\vector{\widetilde{u}})))\]
where the difference operator in the previous expressions refers to set difference.

The intermediate vector $\vector{\widetilde{z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\vector{\widetilde{z}} = \vector{\widetilde{t}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then vector $\vector{\widetilde{z}}$ is defined as 
        \[ \langle D_z, \bold{size}(\vector{\widetilde{w}}), \bold{L}(\vector{\widetilde{z}})
		= \{(i,z_{i})  \forall (i) \in \bold{ind}(\vector{\widetilde{w}}) \cup 
        \bold{ind}(\vector{\widetilde{t}}) \} \rangle.\]
    The values of the elements of $\vector{\widetilde{z}}$ are computed based on the 
    relationships between the sets of indices in $\vector{\widetilde{w}}$ and 
    $\vector{\widetilde{t}}$.
\[
z_{i} = \vector{\widetilde{w}}(i) \odot \vector{\widetilde{t}}(i), \ \mbox{if}\  i \in  (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}})),
\]
\[
z_{i} = \vector{\widetilde{w}}(i), \ \mbox{if}\  i \in  (\bold{ind}(\vector{\widetilde{w}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}}))),
\]
\[
z_{i} = \vector{\widetilde{t}}(i), \ \mbox{if}\  i \in  (\bold{ind}(\vector{\widetilde{t}}) - (\bold{ind}(\vector{\widetilde{t}}) \cap \bold{ind}(\vector{\widetilde{w}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\vector{\widetilde{z}}$ 
vector are written into the final result vector, $\vector{w}$. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set, then any values in $\vector{w}$ 
on input to {\sf GrB\_eWiseMult()} are deleted and the new output vector $\vector{w}$ is,
\[ \bold{L}({\sf w}) = \{(i,z_{i}) : i \in (\bold{ind}(\vector{\widetilde{z}}) 
\cap \bold{ind}(\vector{\widetilde{m}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of $\vector{\widetilde{z}}$ indicated by 
the mask are copied into the result vector, $\vector{w}$, and elements of 
$\vector{w}$ that fall outside the set indicated by the mask are unchanged:
\[ \bold{L}({\sf w}) = \{(i,w_{i}) : i \in (\bold{ind}(\vector{\sf w}) 
\cap \bold{ind}(\neg \vector{\widetilde{m}})) \} \cup \{(i,z_{i}) : i \in 
(\bold{ind}(\vector{\widetilde{z}}) \cap \bold{ind}(\vector{\widetilde{m}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of vector {\sf w} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.



%===========================================================================
\comment{
\paragraph{OLD Description}

A consistency check is performed to verify that $\bold{n}({\sf mask})
= \bold{n}({\sf u}) = \bold{n}({\sf v}) = \bold{n}({\sf w})$. If the consistency check
fails, the operation is aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

Vectors $\vector{m}, \vector{u}$, and $\vector{v}$ are computed from
input parameters {\sf mask}, {\sf u}, and {\sf v}, respectively, with any
modifications as specified by descriptor {\sf desc}.  
If {\sf mask} is {\sf GrB\_NULL} or omitted,
then $\vector{m}$ is a Boolean vector of size $\bold{n}(\vector{\sf w})$
and with all elements set to {\sf true}.

If $\vector{m}, \vector{u}$ or $\vector{v}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}. \scott{This is too vague for DOMAIN mismatch.}

A new vector $\vector{w} = \langle \bold{D}_3({\sf op}),
\bold{n}(\vector{\sf w}), \bold{L}(\vector{w}) = \{(i,w_i)  \forall i \in
\vector{i}(\vector{v}) \cup \vector{i}(\vector{u}) : \vector{m}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its
elements is computed by 
\[
w_i = \vector{u}(i) \oplus \vector{v}(i), \ \mbox{if}\  i \in  \vector{i}(\vector{v}) \cap \vector{i}(\vector{u})
\]
\[
w_i = \vector{u}(i) \ \mbox{if}\  i \in  \vector{i}(\vector{u}) - (\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}))
\]
\[
w_i = \vector{v}(i) \ \mbox{if}\  i \in  \vector{i}(\vector{v}) - (\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}))
\]
where $\oplus = \bigoplus({\sf op})$ if {\sf op} is a semiring, and $\oplus = \bigodot({\sf op})$
if {\sf op} is a monoid or binary operator.

Note that if $\vector{i}(\vector{v}) \cup \vector{i}(\vector{u}) = \emptyset$
then $\bold{L}(\vector{w}) = \emptyset$.


Finally, output parameter {\sf w} is computed from vector $\vector{w}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be performed.)  A consistency check is
performed to verify that $\bold{n}({\sf w}) = \bold{n}(\vector{w})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.
}

%-----------------------------------------------------------------------------

\subsubsection{{\sf eWiseAdd}: Matrix variant}

Perform element-wise (general) addition on the elements of two matrices,
producing a third matrix as result.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_eWiseAdd(GrB_Matrix            *C,
                              const GrB_Matrix       Mask,
                              const GrB_BinaryOp     accum,
                              const GrB_Semiring     op, 
                              const GrB_Matrix       A,
                              const GrB_Matrix       B,
                              const GrB_Descriptor   desc);
                            
        GrB_Info GrB_eWiseAdd(GrB_Matrix            *C,
                              const GrB_Matrix       Mask,
                              const GrB_BinaryOp     accum,
                              const GrB_Monoid       op, 
                              const GrB_Matrix       A,
                              const GrB_Matrix       B,
                              const GrB_Descriptor   desc);
                            
        GrB_Info GrB_eWiseAdd(GrB_Matrix            *C,
                              const GrB_Matrix       Mask,
                              const GrB_BinaryOp     accum,
                              const GrB_BinaryOp     op, 
                              const GrB_Matrix       A,
                              const GrB_Matrix       B,
                              const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]    ({\sf INOUT}) An existing GraphBLAS matrix.  On input,
    the matrix provides values that may be accumulated with the result of the
    element-wise operation.  On output, this matrix holds the results of the
    operation.

    \item[{\sf Mask}]  ({\sf IN}) An optional ``write'' mask that controls which
    results from this operation are stored into the output matrix
    ${\sf C}$.  If no mask is desired (\ie, all elements
    of result are copied into the output matrix), {\sf GrB\_NULL}
    should be specified. The mask dimensions must match those of the
    matrix {\sf C} and the domain of {\sf Mask} must be
    of type {\sf bool} or any of the predefined ``built-in'' types in
    Table~\ref{Tab:PredefinedTypes}.

    \item[{\sf accum}] ({\sf IN}) An optional operator used for accumulating
    entries into existing {\sf C} entries: ${\sf accum} = \langle D_x,
    D_y, D_z,\odot \rangle$. If assignment rather than accumulation is
    desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    ({\sf IN}) The semiring, monoid, or binary operator 
    used in the element-wise ``sum'' operation.  Depending on which type is
    passed, the following defines the binary operator, 
    $F_b=\langle D_1,D_2,D_3,\oplus\rangle$, used:
    \begin{itemize}[leftmargin=1.1in]
    \item[BinaryOp:] $F_b = \langle \bold{D}_1({\sf op}), \bold{D}_2({\sf op}),
    \bold{D}_3({\sf op}),\bold{\bigodot}({\sf op})\rangle$.  
    \item[Monoid:] $F_b = \langle \bold{D}_1({\sf op}), \bold{D}_1({\sf op}),
    \bold{D}_1({\sf op}),\bold{\bigodot}({\sf op})\rangle$,
    the identity element is ignored. 
    \item[Semiring:] $F_b = \langle \bold{D}_1({\sf op}), \bold{D}_2({\sf op}),
    \bold{D}_3({\sf op}),\bold{\bigoplus}({\sf op})\rangle$.  The semiring's 
    multiplicative binary op and additive identity are ignored.
    \end{itemize}
    
    \item[{\sf A}]     ({\sf IN}) The GraphBLAS matrix holding the values for
    the left-hand matrix in the operation.
    
    \item[{\sf B}]     ({\sf IN}) The GraphBLAS matrix holding the values for
    the right-hand matrix in the operation.
    
    \item[{\sf desc}]  ({\sf IN}) An optional operation descriptor.  If a \emph{default}
    descriptor is desired, {\sf GrB\_NULL} can be used.  Valid fields are
    as follows: \\
    
    \begin{tabular}{lllp{2.5in}}
        Param & Field  & Value & Description \\
        \hline
        {\sf C}    & {\sf GrB\_OUTP} & {\sf GrB\_REPLACE} & Output matrix {\sf C} is cleared (all elements removed) before result is stored in it.\\
        {\sf Mask} & {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf Mask}. \\
        {\sf A}    & {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A} for operation. \\
        {\sf B}    & {\sf GrB\_INP1} & {\sf GrB\_TRAN}   & Use transpose of {\sf B} for operation. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]         In blocking mode, operation
	completed successfully. In non-blocking mode, this indicates
	that the consistency tests on dimensions and domains for the
	input arguments passed successfully. Either way, output matrix
	{\sf C} is ready to be used in the next method of the sequence.

    \item[{\sf GrB\_PANIC}]           Unknown internal error.
    
    \item[{\sf GrB\_OUTOFMEM}]        Not enough memory available for operation.
    
    \item[{\sf GrB\_NOOBJECT}]        One or more of the GraphBLAS objects has
    not been initialized by a call to {\sf new}.
    
    \item[{\sf GrB\_NULL\_POINTER}]  The {\sf C} pointer is {\sf NULL}.

    \item[{\sf GrB\_DIMENSION\_MISMATCH}] Mask or matrix dimensions are incompatible.

	\item[{\sf GrB\_DOMAIN\_MISMATCH}]    The domains of the various
	matrices are incompatible with the corresponding domains of the
	accumulating operation, binary operator ({\sf op}), or mask.
\end{itemize}

\paragraph{Description}

This variant of {\sf GrB\_eWiseAdd } computes the element-wise ``sum'' of
two GraphBLAS matrices: ${\sf C} = {\sf A} \oplus {\sf B}$, or, if an optional
binary accumulation operator ($\odot$) is provided, ${\sf C} = {\sf C} \odot
\left({\sf A} \oplus {\sf B}\right)$.  Logically, this operation occurs in
three steps:
\begin{enumerate}[leftmargin=0.75in]
\item[Setup] The internal matrices and mask used in the computation are formed 
and their domains and dimensions are tested for consistency.
\item[Compute] The indicated computations are carried out.
\item[Output] The result is written into the output matrix, possibly under 
control of a mask.
\end{enumerate}

Up to four argument matrices are used in the {\sf GrB\_eWiseMult} operation:
\begin{enumerate}
	\item ${\sf C} = \langle \bold{D}({\sf C}),\bold{nrows}({\sf C}),\bold{ncols}({\sf C}),\bold{L}({\sf C}) = \{(i,j,C_{ij}) \} \rangle$
	\item ${\sf Mask} = \langle \bold{D}({\sf Mask}),\bold{nrows}({\sf Mask}),\bold{ncols}({\sf Mask}),\bold{L}({\sf Mask}) = \{(i,j,M_{ij}) \} \rangle$ (optional)
	\item ${\sf A} = \langle \bold{D}({\sf A}),\bold{nrows}({\sf A}), \bold{ncols}({\sf A}),\bold{L}({\sf A}) = \{(i,j,A_{ij}) \} \rangle$
	\item ${\sf B} = \langle \bold{D}({\sf B}),\bold{nrows}({\sf B}), \bold{ncols}({\sf B}),\bold{L}({\sf B}) = \{(i,j,B_{ij}) \} \rangle$
\end{enumerate}

The argument matrices, the ``sum'' operator ({\sf op}), and the accumulator 
operator (if provided) are tested for domain consistency as follows:
\begin{enumerate}
	\item The domain of {\sf Mask} (if not {\sf GrB\_NULL}) must be from one of the pre-defined types of Table~\ref{Tab:PredefinedTypes}.

	\item $\bold{D}({\sf A})$ must be compatible with $D_1$ of {\sf op}.

	\item $\bold{D}({\sf B})$ must be compatible with $D_2$ of {\sf op}.

	\item If {\sf accum} is {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be 
    compatible with $D_3$ of the {\sf op}.

	\item If {\sf accum} is not {\sf GrB\_NULL}, then $\bold{D}({\sf C})$ must be
    compatible with $D_x$ and $D_z$ of the accumulator operator and $D_3$ of
    {\sf op} must be compatible with $D_y$ of the accumulator operator.
\end{enumerate}
Two domains are compatible with each other if values from one domain can be cast 
to values in the other domain as per the rules of the C language.
In particular, domains from Table~\ref{Tab:PredefinedTypes} are all compatible 
with each other. A domain from a user-defined type is only compatible with itself.
If any consistency rule above is violated, execution of {\sf GrB\_eWiseMult} ends
and the domain mismatch error listed above is returned.

From the argument matrices, the internal matrices and mask used in the computation are formed ($\leftarrow$ denotes copy):
\begin{enumerate}
	\item Matrix $\matrix{\widetilde{C}} \leftarrow {\sf C}$.

	\item Two-dimensional mask $\matrix{\widetilde{M}}$ is computed from argument {\sf Mask} as follows:
	\begin{enumerate}

		\item	If ${\sf Mask} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf C}), \bold{ncols}({\sf C}), \{(i,j), \forall i,j : 0 \leq i <  \bold{nrows}({\sf C}), 0 \leq j < \bold{ncols}({\sf C}) \} \rangle$.

		\item	Otherwise, $\matrix{\widetilde{M}} = \langle \bold{nrows}({\sf Mask}), \bold{ncols}({\sf Mask}), \{(i,j) : ({\sf bool}){\sf Mask}(i,j) = \true\} \rangle$.

		\item	If ${\sf desc[GrB\_MASK].GrB\_SCMP}$ is set, then $\matrix{\widetilde{M}} \leftarrow \neg \matrix{\widetilde{M}}$.

	\end{enumerate}

	\item Matrix $\matrix{\widetilde{A}} \leftarrow {\sf desc[GrB\_INP0].GrB\_TRAN} \ ? \ {\sf A}^T : {\sf A}$.

	\item Matrix $\matrix{\widetilde{B}} \leftarrow {\sf desc[GrB\_INP1].GrB\_TRAN} \ ? \ {\sf B}^T : {\sf B}$.
\end{enumerate}

The internal matrices and masks are checked for shape consistency. The following conditions must hold:
\begin{enumerate}	
	\item $\bold{nrows}(\matrix{\widetilde{C}}) = \bold{nrows}(\matrix{\widetilde{M}})
	     = \bold{nrows}(\matrix{\widetilde{A}}) = \bold{nrows}(\matrix{\widetilde{C}})$.

	\item $\bold{ncols}(\matrix{\widetilde{C}}) = \bold{ncols}(\matrix{\widetilde{M}})
	     = \bold{ncols}(\matrix{\widetilde{A}}) = \bold{ncols}(\matrix{\widetilde{C}})$.
\end{enumerate}
If any consistency rule above is violated, execution of {\sf GrB\_eWiseMult} ends and the dimension mismatch error listed above is returned.

We are now ready to carry out the element-wise ``sum'' and any additional 
associated operations.  We describe this in terms of two intermediate matrices:
\begin{itemize}
	\item $\matrix{\widetilde{T}}$: The matrix holding the element-wise sum of
    $\matrix{\widetilde{A}}$ and matrix $\matrix{\widetilde{B}}$.
	\item $\matrix{\widetilde{Z}}$: The matrix holding the result after 
    application of the (optional) accumulator.
\end{itemize}

The intermediate matrix $\matrix{\widetilde{T}} = \langle
D_3, \bold{nrows}(\matrix{\widetilde{A}}), \bold{ncols}(\matrix{\widetilde{A}}),
\bold{L}(\matrix{\widetilde{T}}) =
\{(i,j,T_{ij}) : \bold{ind}(\matrix{\widetilde{A}}) \cap 
\bold{ind}(\matrix{\widetilde{B}})
 \neq \emptyset \} \rangle$
is created.  The value of each of its elements is computed by 
\[T_{ij} = (\matrix{\widetilde{A}}(i,j) \oplus \matrix{\widetilde{B}}(i,j)), \forall (i,j) \in \bold{ind}(\matrix{\widetilde{A}}) \cap \bold{ind}(\matrix{\widetilde{B}}).\]
\[T_{ij} = \matrix{\widetilde{A}}(i,j), \forall (i,j) \in (\bold{ind}(\matrix{\widetilde{A}}) - (\bold{ind}(\matrix{\widetilde{B}}) \cap \bold{ind}(\matrix{\widetilde{A}})))\]
\[T_{ij} = \matrix{\widetilde{B}}(i.j), \forall (i,j) \in (\bold{ind}(\matrix{\widetilde{B}}) - (\bold{ind}(\matrix{\widetilde{B}}) \cap \bold{ind}(\matrix{\widetilde{A}})))\]
where the difference operator in the previous expressions refers to set difference.


The intermediate matrix $\matrix{\widetilde{Z}}$ is created as follows:
\begin{itemize}
    \item If ${\sf accum} = {\sf GrB\_NULL}$, then $\matrix{\widetilde{Z}} = \matrix{\widetilde{T}}$.

    \item If ${\sf accum} = \langle D_x, D_y, D_z, \odot \rangle$, then matrix $\matrix{\widetilde{Z}}$ is defined as 
        \[ \langle D_z, \bold{nrows}(\matrix{\widetilde{C}}), \bold{ncols}(\matrix{\widetilde{C}}), \bold{L}(\matrix{\widetilde{Z}})
		= \{(i,j,Z_{ij})  \forall (i,j) \in \bold{ind}(\matrix{\widetilde{C}}) \cup 
        \bold{ind}(\matrix{\widetilde{T}}) \} \rangle.\]
    The values of the elements of $\matrix{\widetilde{Z}}$ are computed based on the 
    relationships between the sets of indices in $\matrix{\widetilde{C}}$ and 
    $\matrix{\widetilde{T}}$.
\[
Z_{ij} = \matrix{\widetilde{C}}(i,j) \odot \matrix{\widetilde{T}}(i,j), \ \mbox{if}\  (i,j) \in  (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}})),
\]
\[
Z_{ij} = \matrix{\widetilde{C}}(i,j), \ \mbox{if}\  (i,j) \in  (\bold{ind}(\matrix{\widetilde{C}}) - (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}}))),
\]
\[
Z_{ij} = \matrix{\widetilde{T}}(i,j), \ \mbox{if}\  (i,j) \in  (\bold{ind}(\matrix{\widetilde{T}}) - (\bold{ind}(\matrix{\widetilde{T}}) \cap \bold{ind}(\matrix{\widetilde{C}}))).
\]
where the difference operator in the previous expressions refers to set difference.
\end{itemize}

Finally, the set of output values that make up the $\matrix{\widetilde{Z}}$ 
matrix are written into the final result matrix, $\matrix{C}$. 
This is carried out under control of the mask which acts as a ``write mask''.
\begin{itemize}
\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is set, then any values in $\matrix{C}$ 
on input to {\sf GrB\_eWiseMult()} are deleted and the new output matrix $\matrix{C}$ is,
\[ \bold{L}({\sf C}) = \{(i,j,Z_{ij}) : (i,j) \in (\bold{ind}(\matrix{\widetilde{Z}}) 
\cap \bold{ind}(\matrix{\widetilde{M}})) \}. \]

\item If {\sf desc[GrB\_OUTP].GrB\_REPLACE} is not set, the elements of $\matrix{\widetilde{Z}}$ indicated by 
the mask are copied into the result matrix, $\matrix{C}$, and elements of 
$\matrix{C}$ that fall outside the set indicated by the mask are unchanged:
\[ \bold{L}({\sf C}) = \{(i,j,C_{ij}) : (i,j) \in (\bold{ind}(\matrix{\sf C}) 
\cap \bold{ind}(\neg \matrix{\widetilde{M}})) \} \cup \{(i,j,Z_{ij}) : (i,j) \in 
(\bold{ind}(\matrix{\widetilde{Z}}) \cap \bold{ind}(\matrix{\widetilde{M}})) \}. \]
\end{itemize}

In {\sf GrB\_BLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of matrix {\sf C} is as defined above
and fully computed.  
In {\sf GrB\_NONBLOCKING} mode, the method exits with return value 
{\sf GrB\_SUCCESS} and the new content of matrix {\sf C} is as defined above 
but may not be fully computed; however, it can be used in the next GraphBLAS 
method call in a sequence.


%==========================================================================
\comment{
\paragraph{OLD Description}
A consistency check is performed to verify that the
dimensions of {\sf C}, {\sf Mask}, {\sf A} and {\sf B}
are compatible, taking into consideration any transposition. If a 
consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

Matrices $\matrix{B}, \matrix{M}$ and $\vector{A}$ are computed from
input parameters {\sf B}, {\sf Mask} and {\sf A}, respectively, as specified
by descriptor {\sf desc}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting and transposition, can be performed.)  $\bold{D}(\matrix{A}) =
\bold{D}_3({\sf op})$ and $\bold{D}(\matrix{B}) = \bold{D}_3({\sf op})$.
$\bold{D}(\matrix{Matrix}) = {\sf GrB\_BOOL}$.  If {\sf Mask} is {\sf GrB\_NULL} or omitted,
then $\matrix{Matrix}$ is a Boolean matrix of shape 
$\bold{m}(\matrix{\sf C}) \times \bold{n}(\matrix{\sf C})$
and with all elements set to {\sf true}.

If either $\matrix{B}, \matrix{M}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns 
{\sf GrB\_DOMAIN\_MISMATCH}. \scott{This is too vague for DOMAIN mismatch.}

A new matrix $\matrix{C} = \langle \bold{D}_3({\sf op}),
\bold{m}(\matrix{\sf C}), \bold{n}(\matrix{\sf C}), \bold{L}(\matrix{C}) = \{(i,j,C_{ij})  \forall (i,j) \in
\bold{L}(\matrix{B}) \cup \bold{L}(\matrix{A}) : \matrix{M}(i,j)
= {\sf true} \} \rangle$ is created.  The value of each of its
elements is computed by 
\[
C_{ij} = \matrix{A}(i,j) \oplus \matrix{B}(i,j), \ \mbox{if}\  (i,j) \in  \bold{L}(\matrix{B}) \cap \bold{L}(\matrix{A})
\]
\[
C_{ij} = \matrix{A}(i,j) \ \mbox{if}\  (i,j) \in  \bold{L}(\matrix{A}) - (\bold{L}(\matrix{B}) \cap \bold{L}(\matrix{A}))
\]
\[
C_{ij} = \matrix{B}(i,j) \ \mbox{if}\  (i,j) \in  \bold{L}(\matrix{B}) - (\bold{L}(\matrix{B}) \cap \bold{L}(\matrix{A}))
\]
where $\oplus = \bigoplus({\sf op})$ if {\sf op} is a semiring, and $\oplus = \bigodot({\sf op})$
if {\sf op} is a monoid or binary operator.

Note that if $\bold{L}(\matrix{B}) \cup \bold{L}(\matrix{A}) = \emptyset$
then $\bold{L}(\matrix{C}) = \emptyset$.

Finally, output parameter {\sf C} is computed from matrix $\matrix{C}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be performed.) 

% A consistency check is
% performed to verify that $\bold{n}({\sf w}) = \bold{n}(\matrix{C})$. If
% the consistency check fails, the operation is aborted and the method
% return {\sf GrB\_DIMENSION\_MISMATCH}.
}