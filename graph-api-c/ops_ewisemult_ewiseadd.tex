\subsubsection{{\sf eWiseMult}: Element-wise multiplication}

{\bf Note:} The difference between {\sf eWiseAdd} and {\sf eWiseMult} is not 
about the semiring operation but how the index sets are treated.
{\sf eWiseAdd} returns an object whose indices are the ``union'' of the 
indices of the inputs whereas {\sf eWiseMult} returns an object whose indices 
are the ``intersection'' of the indices of the inputs. In both cases, the 
passed monoid (or function) operates on the set of values from the 
intersection set. 

\scott{Two points need to be revisited for ewiseX operations.  First, 'add' and 'mult'
really are a misnomer and have been the source of much confusion.  ewiseunion and
ewiseintersection really are much more descriptive.  Second, we are not in agreement
about whether or not to support the semiring interface as you need to then carefully
document which of the semirings binary functions will be used.  I recommend removal,
while providing helper functions that can 'wrap' semirings that extract the 
appropriate binary function: extract\_add(sr) or extract\_mult(sr).}

\paragraph{Vector variant}

Perform element-wise (general) multiplication on the elements of two vectors,
producing a third vector as result.

\subparagraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_ewisemult(GrB_Vector              *w,
                               const GrB_Vector         mask,
                               const GrB_BinaryFunction accum,
                               const GrB_Semiring       op, 
                               const GrB_Vector         u,
                               const GrB_Vector         v
                            [, const GrB_Descriptor     desc]);
                            
        GrB_info GrB_ewisemult(GrB_Vector              *w,
                               const GrB_Vector         mask,
                               const GrB_BinaryFunction accum,
                               const GrB_Monoid         op, 
                               const GrB_Vector         u,
                               const GrB_Vector         v
                            [, const GrB_Descriptor     desc]);
                            
        GrB_info GrB_ewisemult(GrB_Vector              *w,
                               const GrB_Vector         mask,
                               const GrB_BinaryFunction accum,
                               const GrB_BinaryFunction op, 
                               const GrB_Vector         u,
                               const GrB_Vector         v
                            [, const GrB_Descriptor     desc]);
\end{verbatim}

\subparagraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]     ({\sf OUTP}) An existing vector to hold the result.

    \item[{\sf mask}]  ({\sf MASK}) Output mask vector . The mask
    specifies which elements of the result vector can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Function used for accumulating entries into existing
                        \matrix{C} entries. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    The monoid/function used in the element-wise multiplication.
                       If a semiring is passed in then the $\otimes$  function from
                                    the semiring is used.
    \item[{\sf u}]     ({\sf ARG0}) Left hand operand.
    \item[{\sf v}]     ({\sf ARG1}) Right hand operand.

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted. Valid fields are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf OUTP} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}_3({\sf op})$ to $\bold{D}(\vector{w})$. \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf Mask})$ to {\sf bool} domain. \\
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}(\vector{u})$ to $\bold{D}_1({\sf op})$. \\
    {\sf ARG1} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}(\vector{v})$ to $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\subparagraph{Return Value}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among vectors dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of vectors, and operation, for which the descriptor did not explicitly allow casting.
\end{itemize}

\subparagraph{Description}

%If {\sf op} is a semiring, then $\otimes = \bigotimes({\sf op})$. 
%If {\sf op} is a monoid or function, then $\otimes = \bigoplus({\sf op})$.

The binary operation, {\sf op}, whether it is a monoid or a binary function
is generically referred to as $\otimes$ in this discussion.

Vectors $\vector{v}, \vector{m}$ and $\vector{u}$ are computed from
input parameters {\sf v}, {\sf m} and {\sf u}, respectively, as specified
by descriptor {\sf d}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting, can be specified.)  $\bold{D}(\vector{u}) =
\bold{D}_1({\sf op})$ and $\bold{D}(\vector{v}) = \bold{D}_2({\sf op})$.
$\bold{D}(\vector{m}) = {\sf GrB\_BOOL}$.  If {\sf m} is {\sf GrB\_NULL} or omitted,
then $\vector{m}$ is a Boolean vector of size $\bold{n}(\vector{u})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{m}$ or $\vector{u}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{n}(\vector{u}) = \bold{n}(\vector{m})$. If a consistency
check fails, the operation is aborted and the method returns {\sf
GrB\_DIMENSION\_MISMATCH}.

A new vector $\vector{w} = \langle \bold{D}_3({\sf op}),
\bold{n}(\vector{u}), \bold{L}(\vector{w}) = \{(i,w_i)  \forall i \in
\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}) : \vector{m}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its
elements is computed by $w_i = \vector{u}(i) \otimes \vector{v}(i)$,
where $\otimes$ is as defined above from {\sf op}.
If $\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}) = \emptyset$
then $\bold{L}(\vector{w}) = \emptyset$.

Finally, output parameter {\sf w} is computed from vector $\vector{w}$
as specified by descriptor {\sf d}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf w}) = \bold{n}(\vector{w})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.

%-----------------------------------------------------------------------------

\paragraph{Matrix variant}

Perform element-wise (general) multiplication on the elements of two matrices,
producing a third matrix as result.

\subparagraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_ewisemult(GrB_Matrix              *C,
                               const GrB_Matrix         mask,
                               const GrB_BinaryFunction accum,
                               const GrB_Semiring       op, 
                               const GrB_Matrix         A,
                               const GrB_Matrix         B
                            [, const GrB_Descriptor     desc]);
                            
        GrB_info GrB_ewisemult(GrB_Matrix              *C,
                               const GrB_Matrix         mask,
                               const GrB_BinaryFunction accum,
                               const GrB_Monoid         op, 
                               const GrB_Matrix         A,
                               const GrB_Matrix         B
                            [, const GrB_Descriptor     desc]);
                            
        GrB_info GrB_ewisemult(GrB_Matrix              *C,
                               const GrB_Matrix         mask,
                               const GrB_BinaryFunction accum,
                               const GrB_BinaryFunction op, 
                               const GrB_Matrix         A,
                               const GrB_Matrix         B
                            [, const GrB_Descriptor     desc]);
\end{verbatim}

\subparagraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]     ({\sf OUTP}) An existing matrix to hold the result.

    \item[{\sf mask}] ({\sf MASK}) Output mask matrix. The mask
    specifies which elements of the result matrix can be modified.
    If no mask is necessary (i.e., compute all elements of result
    matrix), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Function used for accumulating entries into existing
                        \matrix{C} entries. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    The monoid/function used in the element-wise multiplication.
                       If a semiring is passed in then the $\otimes$ function from
                                    the semiring is used.
    \item[{\sf A}]     ({\sf ARG0}) Left hand operand.
    \item[{\sf B}]     ({\sf ARG1}) Right hand operand.
    
    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted. Valid fields are as follows: \\
    \begin{tabular}{lll}
        Field  & Value & Description \\
        \hline
        {\sf OUTP} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}_3({\sf op})$ to $\bold{D}(\matrix{C})$. \\
        {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf Mask})$ to {\sf bool} domain. \\
    {\sf ARG0} & {\sf GrB\_TRAN} & Use transpose of {\sf A} for operation. \\
        {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}(\matrix{A})$ to $\bold{D}_1({\sf op})$. \\
    {\sf ARG1} & {\sf GrB\_TRAN} & Use transpose of {\sf B} for operation. \\
        {\sf ARG1} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}(\matrix{B})$ to $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\subparagraph{Return Value}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]             operation completed successfully
    \item[{\sf GrB\_PANIC}]               unknown internal error
    \item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among matrix dimensions.
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of matrices, and operation, for which the descriptor did not explicitly allow casting.
\end{itemize}

\subparagraph{Description}

%If {\sf op} is a semiring, then $\otimes = \bigotimes({\sf op})$. 
%If {\sf op} is a monoid or function, then $\otimes = \bigoplus({\sf op})$.

The binary operation, {\sf op}, whether it is a monoid or a binary function
is generically referred to as $\otimes$ in this discussion.

Matrices $\matrix{A}, \matrix{m}$ and $\matrix{B}$ are computed from
input parameters {\sf A}, {\sf m} and {\sf B}, respectively, as specified
by descriptor {\sf d}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting, can be specified.)  $\bold{D}(\matrix{A}) =
\bold{D}_1({\sf op})$ and $\bold{D}(\matrix{B}) = \bold{D}_2({\sf op})$.
$\bold{D}(\matrix{m}) = {\sf GrB\_BOOL}$.  If {\sf m} is {\sf GrB\_NULL} or omitted,
then $\vector{m}$ is a Boolean vector of size $\bold{n}(\matrix{A})$
and with all elements set to {\sf true}.

If either $\matrix{B}, \matrix{m}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns {\sf
    GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\matrix{B})
= \bold{n}(\matrix{A}) = \bold{n}(\matrix{m})$. If a consistency
check fails, the operation is aborted and the method returns {\sf
    GrB\_DIMENSION\_MISMATCH}.

A new matrix $\matrix{C} = \langle \bold{D}_3({\sf op}),
\bold{n}(\matrix{A}), \bold{L}(\matrix{C}) = \{(i,C_i)  \forall i \in
\matrix{i}(\matrix{B}) \cap \matrix{i}(\matrix{A}) : \matrix{m}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its
elements is computed by $C_i = \matrix{A}(i) \otimes \matrix{B}(i)$,
where $\otimes$ is as defined above from {\sf op}.
If $\matrix{i}(\matrix{B}) \cap \matrix{i}(\matrix{A}) = \emptyset$
then $\bold{L}(\matrix{C}) = \emptyset$.

Finally, output parameter {\sf w} is computed from vector $\matrix{C}$
as specified by descriptor {\sf d}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf C}) = \bold{n}(\matrix{C})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.

%-----------------------------------------------------------------------------


\subsubsection{{\sf eWiseAdd}: Element-wise addition}

{\bf Note:} The difference between {\sf eWiseAdd} and {\sf eWiseMult} is not about the semiring operation but how the index sets are treated.
 {\sf eWiseAdd} returns an object whose indices are the ``union'' of the indices of the inputs whereas  
 {\sf eWiseMult} returns an object whose indices are the ``intersection'' of the indices of the inputs. In both cases, the passed monoid (or function) operates on the 
 set of values from the intersection set. 

\paragraph{Vector variant}

Perform element-wise (general) addition on the elements of two vectors,
producing a third vector as result.

\subparagraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_ewiseadd(GrB_Vector              *w,
                              const GrB_Vector         mask,
                              const GrB_BinaryFunction accum,
                              const GrB_Semiring       op, 
                              const GrB_Vector         u,
                              const GrB_Vector         v
                           [, const GrB_Descriptor     desc]);
                            
        GrB_info GrB_ewiseadd(GrB_Vector              *w,
                              const GrB_Vector         mask,
                              const GrB_BinaryFunction accum,
                              const GrB_Monoid         op, 
                              const GrB_Vector         u,
                              const GrB_Vector         v
                           [, const GrB_Descriptor     desc]);
                            
        GrB_info GrB_ewiseadd(GrB_Vector              *w,
                              const GrB_Vector         mask,
                              const GrB_BinaryFunction accum,
                              const GrB_BinaryFunction op, 
                              const GrB_Vector         u,
                              const GrB_Vector         v
                           [, const GrB_Descriptor     desc]);
\end{verbatim}

\subparagraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf w}]     ({\sf OUTP}) An existing vector to hold the result.

    \item[{\sf mask}] ({\sf MASK}) Output mask vector . The mask
    specifies which elements of the result vector can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Function used for accumulating entries into existing
                        \matrix{C} entries. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    The monoid/function used in the element-wise addition.
                       If a semiring is passed in then the $\oplus$  function from
                                    the semiring is used.
    \item[{\sf u}]     ({\sf ARG0}) Left hand operand.
    \item[{\sf v}]     ({\sf ARG1}) Right hand operand.

    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted. Valid fields are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf OUTP} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}_3({\sf op})$ to $\bold{D}(\vector{w})$. \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf Mask})$ to {\sf bool} domain. \\
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}(\vector{u})$ to $\bold{D}_1({\sf op})$. \\
    {\sf ARG1} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}(\vector{v})$ to $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\subparagraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among vectors dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of vectors, and operation, for which the descriptor did not explicitly allow casting.
\end{itemize}

\subparagraph{Description}

%If {\sf op} is a semiring, then $\oplus = \bigoplus({\sf op})$. 
%If {\sf op} is a monoid or function, then $\oplus = \bigoplus({\sf op})$.

The binary operation, {\sf op}, whether it is a monoid or a binary function
is generically referred to as $\oplus$ in this discussion.

Vectors $\vector{v}, \vector{m}$ and $\vector{u}$ are computed from
input parameters {\sf v}, {\sf m} and {\sf u}, respectively, as specified
by descriptor {\sf d}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting, can be specified.)  $\bold{D}(\vector{u}) =
\bold{D}_3({\sf op})$ and $\bold{D}(\vector{v}) = \bold{D}_3({\sf op})$.
$\bold{D}(\vector{m}) = {\sf GrB\_BOOL}$.  If {\sf m} is {\sf GrB\_NULL} or omitted,
then $\vector{m}$ is a Boolean vector of size $\bold{n}(\vector{u})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{m}$ or $\vector{u}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\vector{v})
= \bold{n}(\vector{u}) = \bold{n}(\vector{m})$. If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A new vector $\vector{w} = \langle \bold{D}_3({\sf op}),
\bold{n}(\vector{u}), \bold{L}(\vector{w}) = \{(i,w_i)  \forall i \in
\vector{i}(\vector{v}) \cup \vector{i}(\vector{u}) : \vector{m}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its
elements is computed by 
\[
w_i = \vector{u}(i) \oplus \vector{v}(i), \ \mbox{if}\  i \in  \vector{i}(\vector{v}) \cap \vector{i}(\vector{u})
\]
\[
w_i = \vector{u}(i) \ \mbox{if}\  i \in  \vector{i}(\vector{u}) - (\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}))
\]
\[
w_i = \vector{v}(i) \ \mbox{if}\  i \in  \vector{i}(\vector{v}) - (\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}))
\]
where $\oplus$ is as defined above for {\sf op}.
If $\vector{i}(\vector{v}) \cup \vector{i}(\vector{u}) = \emptyset$
then $\bold{L}(\vector{w}) = \emptyset$.

Finally, output parameter {\sf w} is computed from vector $\vector{w}$
as specified by descriptor {\sf d}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf w}) = \bold{n}(\vector{w})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.

%-----------------------------------------------------------------------------

\paragraph{Matrix variant}

{\bf Note:} The difference between {\sf eWiseAdd} and {\sf eWiseMult} is not about the semiring operation but how the index sets are treated.
{\sf eWiseAdd} returns an object whose indices are the ``union'' of the indices of the inputs whereas  
{\sf eWiseMult} returns an object whose indices are the ``intersection'' of the indices of the inputs. In both cases, the passed monoid (or function) operates on the 
set of values from the intersection set. 

\subparagraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_ewiseadd(GrB_Matrix              *C,
                              const GrB_Matrix         mask,
                              const GrB_BinaryFunction accum,
                              const GrB_Semiring       op, 
                              const GrB_Matrix         A,
                              const GrB_Matrix         B
                           [, const GrB_Descriptor     desc]);
                            
        GrB_info GrB_ewiseadd(GrB_Matrix              *C,
                              const GrB_Matrix         mask,
                              const GrB_BinaryFunction accum,
                              const GrB_Monoid         op, 
                              const GrB_Matrix         A,
                              const GrB_Matrix         B
                           [, const GrB_Descriptor     desc]);
                            
        GrB_info GrB_ewiseadd(GrB_Matrix              *C,
                              const GrB_Matrix         mask,
                              const GrB_BinaryFunction accum,
                              const GrB_BinaryFunction op, 
                              const GrB_Matrix         A,
                              const GrB_Matrix         B
                           [, const GrB_Descriptor     desc]);
\end{verbatim}

\subparagraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]     ({\sf OUTP}) An existing matrix to hold the result.

    \item[{\sf mask}] ({\sf MASK}) Output mask matrix. The mask
    specifies which elements of the result matrix can be modified.
    If no mask is necessary (i.e., compute all elements of result
    matrix), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Function used for accumulating entries into existing
                        \matrix{C} entries. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    The monoid/function used in the element-wise addition.
                       If a semiring is passed in then the $\oplus$ function from
                                    the semiring is used.
    \item[{\sf A}]     ({\sf ARG0}) Left hand operand.
    \item[{\sf B}]     ({\sf ARG1}) Right hand operand.
    
    \item[{\sf desc}]  Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted. Valid fields are as follows: \\
    \begin{tabular}{lll}
        Field  & Value & Description \\
        \hline
        {\sf OUTP} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}_3({\sf op})$ to $\bold{D}(\matrix{C})$. \\
        {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf Mask})$ to {\sf bool} domain. \\
    {\sf ARG0} & {\sf GrB\_TRAN} & Use transpose of {\sf A} for operation. \\
        {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}(\matrix{A})$ to $\bold{D}_1({\sf op})$. \\
    {\sf ARG1} & {\sf GrB\_TRAN} & Use transpose of {\sf B} for operation. \\
        {\sf ARG1} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}(\matrix{B})$ to $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\subparagraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]             operation completed successfully
    \item[{\sf GrB\_PANIC}]               unknown internal error
    \item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among matrices dimensions.
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of matrices, and operation, for which the descriptor did not explicitly allow casting.
\end{itemize}

\subparagraph{Description}

%If {\sf op} is a semiring, then $\oplus = \bigoplus({\sf op})$. 
%If {\sf op} is a monoid or function, then $\oplus = \bigoplus({\sf op})$.

The binary operation, {\sf op}, whether it is a monoid or a binary function
is generically referred to as $\oplus$ in this discussion.

Matrices $\matrix{B}, \matrix{m}$ and $\vector{A}$ are computed from
input parameters {\sf B}, {\sf m} and {\sf A}, respectively, as specified
by descriptor {\sf d}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting, can be specified.)  $\bold{D}(\matrix{A}) =
\bold{D}_3({\sf op})$ and $\bold{D}(\matrix{B}) = \bold{D}_3({\sf op})$.
$\bold{D}(\matrix{m}) = {\sf GrB\_BOOL}$.  If {\sf m} is {\sf GrB\_NULL} or omitted,
then $\matrix{m}$ is a Boolean matrix of size $\bold{n}(\matrix{A})$
and with all elements set to {\sf true}.

If either $\matrix{B}, \matrix{m}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns {\sf
    GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that $\bold{n}(\matrix{B})
= \bold{n}(\matrix{A}) = \bold{n}(\matrix{m})$. If a consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

A new matrix $\matrix{w} = \langle \bold{D}_3({\sf op}),
\bold{n}(\matrix{A}), \bold{L}(\matrix{C}) = \{(i,C_i)  \forall i \in
\matrix{i}(\matrix{B}) \cup \matrix{i}(\matrix{A}) : \matrix{m}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its
elements is computed by 
\[
C_i = \matrix{A}(i) \oplus \matrix{B}(i), \ \mbox{if}\  i \in  \matrix{i}(\matrix{B}) \cap \matrix{i}(\matrix{A})
\]
\[
C_i = \matrix{A}(i) \ \mbox{if}\  i \in  \matrix{i}(\matrix{A}) - (\matrix{i}(\matrix{B}) \cap \matrix{i}(\matrix{A}))
\]
\[
C_i = \matrix{B}(i) \ \mbox{if}\  i \in  \matrix{i}(\matrix{B}) - (\matrix{i}(\matrix{B}) \cap \matrix{i}(\matrix{A}))
\]
where $\oplus$ is as defined above for {\sf op}.
If $\matrix{i}(\matrix{B}) \cup \matrix{i}(\matrix{A}) = \emptyset$
then $\bold{L}(\matrix{C}) = \emptyset$.

Finally, output parameter {\sf w} is computed from matrix $\matrix{C}$
as specified by descriptor {\sf d}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be specified.)  A consistency check is
performed to verify that $\bold{n}({\sf w}) = \bold{n}(\matrix{C})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.
