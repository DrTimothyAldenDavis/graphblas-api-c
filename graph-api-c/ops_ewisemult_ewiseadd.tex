\subsection{{\sf eWiseMult}: Element-wise multiplication}

{\bf Note:} The difference between {\sf eWiseAdd} and {\sf eWiseMult} is not 
about the semiring operation but how the index sets are treated.
{\sf eWiseAdd} returns an object whose indices are the ``union'' of the 
indices of the inputs whereas {\sf eWiseMult} returns an object whose indices 
are the ``intersection'' of the indices of the inputs. In both cases, the 
passed semiring, monoid, or operator operates on the set of values from the 
resulting index set. 

\comment{
\scott{Two points need to be revisited for ewiseX operations.  First, 'add' and 'mult'
really are a misnomer and have been the source of much confusion.  ewiseunion and
ewiseintersection really are much more descriptive.  Second, we are not in agreement
about whether or not to support the semiring interface as you need to then carefully
document which of the semirings binary operators will be used.  I recommend removal,
while providing helper functions that can 'wrap' semirings that extract the 
appropriate binary function: extract\_add(sr) or extract\_mult(sr).}
\aydin{As everyone will remember, I am all for both suggestions: rename to intersect/union (ewise union/intersect is
an oxymoron so ewise- prefix should not be there) and don't support the confusing semiring version}}

\subsubsection{Vector variant}

Perform element-wise (general) multiplication on the elements of two vectors,
producing a third vector as result.

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_eWiseMult(GrB_Vector            *u,
                               const GrB_Vector       mask,
                               const GrB_BinaryOp     accum,
                               const GrB_Semiring     op, 
                               const GrB_Vector       v,
                               const GrB_Vector       w,
                               const GrB_Descriptor   desc);
                            
        GrB_info GrB_eWiseMult(GrB_Vector            *u,
                               const GrB_Vector       mask,
                               const GrB_BinaryOp     accum,
                               const GrB_Monoid       op, 
                               const GrB_Vector       v,
                               const GrB_Vector       w,
                               const GrB_Descriptor   desc);
                            
        GrB_info GrB_eWiseMult(GrB_Vector            *u,
                               const GrB_Vector       mask,
                               const GrB_BinaryOp     accum,
                               const GrB_BinaryOp     op, 
                               const GrB_Vector       v,
                               const GrB_Vector       w,
                               const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf u}]     ({\sf GrB\_OUTP}) An existing vector to hold the result.

    \item[{\sf mask}]  ({\sf GrB\_MASK}) Output mask vector. The mask
    specifies which elements of the result vector can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Operator used for accumulating entries into existing
                       \vector{u} entries. If no accumulation is desired, 
                        {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    The semiring/monoid/operator used in the element-wise multiplication.
                       If a semiring is passed in then the $\otimes$  operator from
                                    the semiring is used.
    \item[{\sf v}]     ({\sf GrB\_INP0}) Left hand operand.
    \item[{\sf w}]     ({\sf GrB\_INP1}) Right hand operand.

    \item[{\sf desc}]  Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used. Valid fields are as follows: \\
    \begin{tabular}{llp{3in}}
        Field  & Value & Description \\
        \hline
        {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf u})$ must equal $\bold{D}_3({\sf op})$
                                              when {\sf accum} is {\sf GrB\_NULL}; otherwise, 
                                              $\bold{D}({\sf u})$ must equal both 
                                              $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
        {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
        {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf mask})$ must equal {\sf GrB\_BOOL}. \\
        {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf v})$ must equal $\bold{D}_1({\sf op})$. \\
        {\sf GrB\_INP1} & {\sf GrB\_NOCAST} & $\bold{D}({\sf w})$ must equal $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among vectors dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of vectors, and operation, for which the descriptor did not explicitly allow casting.
\end{itemize}

\paragraph{Description}

A consistency check is performed to verify that $\bold{n}({\sf mask})
= \bold{n}({\sf v}) = \bold{n}({\sf w}) = \bold{n}({\sf u})$. If a consistency
check fails, the operation is aborted and the method returns {\sf
GrB\_DIMENSION\_MISMATCH}.

\scott{Casting consistency checks are performed here if NOCAST is specified.}

Vectors $\vector{mask}, \vector{v}$ and $\vector{w}$ are computed from
input parameters {\sf mask}, {\sf v} and {\sf w}, respectively, as specified
by descriptor {\sf desc}. $\bold{D}(\vector{v}) = \bold{D}_1({\sf op})$, 
$\bold{D}(\vector{w}) = \bold{D}_2({\sf op})$, and
$\bold{D}(\vector{mask}) = {\sf GrB\_BOOL}$.  If {\sf mask} is {\sf GrB\_NULL} or
omitted, then $\vector{mask}$ is a Boolean vector of size $\bold{n}(\vector{u})$
and with all elements set to {\sf true}.

If any of $\vector{mask}, \vector{v}$ or $\vector{w}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.  \scott{This is too vague for DOMAIN mismatch}

A new vector $\vector{u} = \langle \bold{D}_3({\sf op}),
\bold{n}(\vector{v}), \bold{L}(\vector{u}) = \{(i,u_i)  \forall i \in
\vector{i}(\vector{v}) \cap \vector{i}(\vector{w}) : \vector{mask}(i)
\in \bold{L}(\vector{mask}) \} \rangle$ is created.  If 
$\vector{i}(\vector{v}) \cap \vector{i}(\vector{w}) = \emptyset$
then $\bold{L}(\vector{u}) = \emptyset$.

The value of each of its elements is computed by 
$u_i = \vector{v}(i) \otimes \vector{w}(i)$, where
$\otimes = \bigotimes({\sf op})$ if {\sf op} is a semiring, and 
$\otimes = \bigodot({\sf op})$ if {\sf op} is a monoid or binary operator.

Finally, output parameter {\sf u} is computed from vector $\vector{u}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting, can be specified.)

%-----------------------------------------------------------------------------

\subsubsection{Matrix variant}

Perform element-wise (general) multiplication on the elements of two matrices,
producing a third matrix as result.

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_eWiseMult(GrB_Matrix            *C,
                               const GrB_Matrix       Mask,
                               const GrB_BinaryOp     accum,
                               const GrB_Semiring     op, 
                               const GrB_Matrix       A,
                               const GrB_Matrix       B,
                               const GrB_Descriptor   desc);
                            
        GrB_info GrB_eWiseMult(GrB_Matrix            *C,
                               const GrB_Matrix       Mask,
                               const GrB_BinaryOp     accum,
                               const GrB_Monoid       op, 
                               const GrB_Matrix       A,
                               const GrB_Matrix       B,
                               const GrB_Descriptor   desc);
                            
        GrB_info GrB_eWiseMult(GrB_Matrix            *C,
                               const GrB_Matrix       Mask,
                               const GrB_BinaryOp     accum,
                               const GrB_BinaryOp     op, 
                               const GrB_Matrix       A,
                               const GrB_Matrix       B,
                               const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]     ({\sf GrB\_OUTP}) An existing matrix to hold the result.

    \item[{\sf Mask}] ({\sf GrB\_MASK}) Output mask matrix. The mask
    specifies which elements of the result matrix can be modified.
    If no mask is necessary (i.e., compute all elements of result
    matrix), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Operator used for accumulating entries into existing
                        \matrix{C} entries. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    The semiring/monoid/operator used in the element-wise multiplication.
                       If a semiring is passed in then the $\otimes$ operator from
                                    the semiring is used.
    \item[{\sf A}]     ({\sf GrB\_INP0}) Left hand operand.
    \item[{\sf B}]     ({\sf GrB\_INP1}) Right hand operand.
    
    \item[{\sf desc}]  Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used. Valid fields are as follows: \\
    \begin{tabular}{llp{3in}}
        Field  & Value & Description \\
        \hline
        {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf C})$ must equal $\bold{D}_3({\sf op})$
                                              when {\sf accum} is {\sf GrB\_NULL}; otherwise, 
                                              $\bold{D}({\sf C})$ must equal both 
                                              $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
        {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf Mask}. \\
        {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf Mask})$ must equal {\sf GrB\_BOOL}. \\
        {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A} for operation. \\
        {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf A})$ must equal $\bold{D}_1({\sf op})$. \\
        {\sf GrB\_INP1} & {\sf GrB\_TRAN}   & Use transpose of {\sf B} for operation. \\
        {\sf GrB\_INP1} & {\sf GrB\_NOCAST} & $\bold{D}({\sf B})$ must equal $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]             operation completed successfully
    \item[{\sf GrB\_PANIC}]               unknown internal error
    \item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among matrix dimensions.
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of matrices, and operation, for which the descriptor did not explicitly allow casting.
\end{itemize}

\paragraph{Description}

A consistency check is performed to verify that the 
dimensions of {\sf C}, {\sf Mask}, {\sf A} and {\sf B}
are compatible, taking into consideration any transposition specified.
If a consistency check fails, the operation is aborted and the method 
returns {\sf GrB\_DIMENSION\_MISMATCH}.

\scott{Casting consistency checks are performed here if NOCAST is specified.}

Matrices $\matrix{A}, \matrix{Mask}$ and $\matrix{B}$ are computed from
input parameters {\sf A}, {\sf Mask} and {\sf B}, respectively, as specified
by descriptor {\sf desc}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting and transposition, can be performed.)  $\bold{D}(\matrix{A}) =
\bold{D}_1({\sf op})$ and $\bold{D}(\matrix{B}) = \bold{D}_2({\sf op})$.
$\bold{D}(\matrix{Mask}) = {\sf GrB\_BOOL}$.  If {\sf Mask} is {\sf GrB\_NULL},
then $\vector{Mask}$ is a Boolean matrix of size $\bold{m}(\matrix{\sf C}) \times \bold{n}(\matrix{\sf C})$
and with all elements set to {\sf true}.

If either $\matrix{B}, \matrix{Mask}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.  \scott{Too vague}

A new matrix $\matrix{C} = \langle \bold{D}_3({\sf op}), \bold{m}(\matrix{\sf C}),
\bold{n}(\matrix{\sf C}), \bold{L}(\matrix{C}) = \{(i,j,C_{ij})  \forall (i,j) \in
\bold{L}(\matrix{B}) \cap \bold{L}(\matrix{A}) : \matrix{Mask}(i,j)
= {\sf true} \} \rangle$ is created.  
If $\bold{L}(\matrix{B}) \cap \bold{L}(\matrix{A}) = \emptyset$
then $\bold{L}(\matrix{C}) = \emptyset$.

The value of each of its elements is computed by 
$C_{ij} = \matrix{A}(i,j) \otimes \matrix{B}(i,j)$, where
$\otimes = \bigotimes({\sf op})$ if {\sf op} is a semiring, and 
$\otimes = \bigodot({\sf op})$ if {\sf op} is a monoid or binary operator.

Finally, output parameter {\sf C} is computed from vector $\matrix{C}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be performed.) 

% A consistency check is
% performed to verify that $\bold{n}({\sf C}) = \bold{n}(\matrix{C})$. If
% the consistency check fails, the operation is aborted and the method
% return {\sf GrB\_DIMENSION\_MISMATCH}.

%-----------------------------------------------------------------------------


\subsection{{\sf eWiseAdd}: Element-wise addition}

{\bf Note:} The difference between {\sf eWiseAdd} and {\sf eWiseMult} is not about the semiring operation but how the index sets are treated.
 {\sf eWiseAdd} returns an object whose indices are the ``union'' of the indices of the inputs whereas  
 {\sf eWiseMult} returns an object whose indices are the ``intersection'' of the indices of the inputs. In both cases, the passed semiring, monoid, or operator operates on the 
 set of values from the resulting index set. 

\subsubsection{Vector variant}

Perform element-wise (general) addition on the elements of two vectors,
producing a third vector as result.

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_eWiseAdd(GrB_Vector            *u,
                              const GrB_Vector       mask,
                              const GrB_BinaryOp     accum,
                              const GrB_Semiring     op, 
                              const GrB_Vector       v,
                              const GrB_Vector       w,
                              const GrB_Descriptor   desc);
                            
        GrB_info GrB_eWiseAdd(GrB_Vector            *u,
                              const GrB_Vector       mask,
                              const GrB_BinaryOp     accum,
                              const GrB_Monoid       op, 
                              const GrB_Vector       v,
                              const GrB_Vector       w,
                              const GrB_Descriptor   desc);

        GrB_info GrB_eWiseAdd(GrB_Vector            *u,
                              const GrB_Vector       mask,
                              const GrB_BinaryOp     accum,
                              const GrB_BinaryOp     op, 
                              const GrB_Vector       v,
                              const GrB_Vector       w,
                              const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf u}]     ({\sf GrB\_OUTP}) An existing vector to hold the result.

    \item[{\sf mask}] ({\sf GrB\_MASK}) Output mask vector. The mask
    specifies which elements of the result vector can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Operator used for accumulating entries into existing
                        \matrix{u} entries. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    The semiring/monoid/operator used in the element-wise addition.
                       If a semiring is passed in then the $\oplus$  operator from
                                    the semiring is used.
    \item[{\sf v}]     ({\sf GrB\_INP0}) Left hand operand.
    \item[{\sf w}]     ({\sf GrB\_INP1}) Right hand operand.

    \item[{\sf desc}]  Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used. Valid fields are as follows: \\
    \begin{tabular}{llp{3in}}
        Field  & Value & Description \\
        \hline
        {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf u})$ must equal $\bold{D}_3({\sf op})$
                                              when {\sf accum} is {\sf GrB\_NULL}; otherwise, 
                                              $\bold{D}({\sf u})$ must equal both 
                                              $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
        {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
        {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf mask})$ must equal {\sf GrB\_BOOL}. \\
        {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf v})$ must equal $\bold{D}_1({\sf op})$. \\
        {\sf GrB\_INP1} & {\sf GrB\_NOCAST} & $\bold{D}({\sf w})$ must equal $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             operation completed successfully
\item[{\sf GrB\_PANIC}]               unknown internal error
\item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
\item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among vectors dimensions.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of vectors, and operation, for which the descriptor did not explicitly allow casting.
\end{itemize}

\paragraph{Description}

A consistency check is performed to verify that $\bold{n}({\sf mask})
= \bold{n}({\sf u}) = \bold{n}({\sf v}) = \bold{n}({\sf w})$. If the consistency check
fails, the operation is aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

\scott{Casting consistency check are performed here for NOCAST parameters}

Vectors $\vector{mask}, \vector{v}$, and $\vector{w}$ are computed from
input parameters {\sf mask}, {\sf v}, and {\sf w}, respectively, with any
modifications as specified by descriptor {\sf desc}.  $\bold{D}(\vector{v}) =
\bold{D}_3({\sf op})$ and $\bold{D}(\vector{v}) = \bold{D}_3({\sf op})$.
$\bold{D}(\vector{m}) = {\sf GrB\_BOOL}$.  If {\sf mask} is {\sf GrB\_NULL} or omitted,
then $\vector{mask}$ is a Boolean vector of size $\bold{n}(\vector{\sf w})$
and with all elements set to {\sf true}.

If either $\vector{v}, \vector{mask}$ or $\vector{u}$ cannot be computed
from the input parameters as described above, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}. \scott{This is too vague for DOMAIN mismatch.}

A new vector $\vector{w} = \langle \bold{D}_3({\sf op}),
\bold{n}(\vector{\sf w}), \bold{L}(\vector{w}) = \{(i,w_i)  \forall i \in
\vector{i}(\vector{v}) \cup \vector{i}(\vector{u}) : \vector{m}(i)
= {\sf true} \} \rangle$ is created.  The value of each of its
elements is computed by 
\[
w_i = \vector{u}(i) \oplus \vector{v}(i), \ \mbox{if}\  i \in  \vector{i}(\vector{v}) \cap \vector{i}(\vector{u})
\]
\[
w_i = \vector{u}(i) \ \mbox{if}\  i \in  \vector{i}(\vector{u}) - (\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}))
\]
\[
w_i = \vector{v}(i) \ \mbox{if}\  i \in  \vector{i}(\vector{v}) - (\vector{i}(\vector{v}) \cap \vector{i}(\vector{u}))
\]
where $\oplus = \bigoplus({\sf op})$ if {\sf op} is a semiring, and $\oplus = \bigodot({\sf op})$
if {\sf op} is a monoid or binary operator.

Note that if $\vector{i}(\vector{v}) \cup \vector{i}(\vector{u}) = \emptyset$
then $\bold{L}(\vector{w}) = \emptyset$.


Finally, output parameter {\sf w} is computed from vector $\vector{w}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be performed.)  A consistency check is
performed to verify that $\bold{n}({\sf w}) = \bold{n}(\vector{w})$. If
the consistency check fails, the operation is aborted and the method
return {\sf GrB\_DIMENSION\_MISMATCH}.

%-----------------------------------------------------------------------------

\subsubsection{Matrix variant}

\comment{
{\bf Note:} The difference between {\sf eWiseAdd} and {\sf eWiseMult} is not about the semiring operation but how the index sets are treated.
{\sf eWiseAdd} returns an object whose indices are the ``union'' of the indices of the inputs whereas  
{\sf eWiseMult} returns an object whose indices are the ``intersection'' of the indices of the inputs. In both cases, the passed monoid (or operator) operates on the 
set of values from the intersection set. 
}

\paragraph{\syntax}

\begin{verbatim}
        GrB_info GrB_eWiseAdd(GrB_Matrix            *C,
                              const GrB_Matrix       Mask,
                              const GrB_BinaryOp     accum,
                              const GrB_Semiring     op, 
                              const GrB_Matrix       A,
                              const GrB_Matrix       B,
                              const GrB_Descriptor   desc);
                            
        GrB_info GrB_eWiseAdd(GrB_Matrix            *C,
                              const GrB_Matrix       Mask,
                              const GrB_BinaryOp     accum,
                              const GrB_Monoid       op, 
                              const GrB_Matrix       A,
                              const GrB_Matrix       B,
                              const GrB_Descriptor   desc);
                            
        GrB_info GrB_eWiseAdd(GrB_Matrix            *C,
                              const GrB_Matrix       Mask,
                              const GrB_BinaryOp     accum,
                              const GrB_BinaryOp     op, 
                              const GrB_Matrix       A,
                              const GrB_Matrix       B,
                              const GrB_Descriptor   desc);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf C}]     ({\sf GrB\_OUTP}) An existing matrix to hold the result.

    \item[{\sf Mask}] ({\sf GrB\_MASK}) Output mask matrix. The mask
    specifies which elements of the result matrix can be modified.
    If no mask is necessary (\ie, compute all elements of result
    matrix), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Operator used for accumulating entries into existing
                        \matrix{C} entries. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.

    \item[{\sf op}]    The semiring/monoid/operator used in the element-wise addition.
                       If a semiring is passed in then the $\oplus$ operator from
                                    the semiring is used.
    \item[{\sf A}]     ({\sf GrB\_INP0}) Left hand operand.
    \item[{\sf B}]     ({\sf GrB\_INP1}) Right hand operand.
    
    \item[{\sf desc}]  Operation descriptor. If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} is to be
    used. Valid fields are as follows: \\
    \begin{tabular}{llp{3in}}
        Field  & Value & Description \\
        \hline
        {\sf GrB\_OUTP} & {\sf GrB\_NOCAST} & $\bold{D}({\sf C})$ must equal $\bold{D}_3({\sf op})$
                                              when {\sf accum} is {\sf GrB\_NULL}; otherwise, 
                                              $\bold{D}({\sf C})$ must equal both 
                                              $\bold{D}_1({\sf accum})$ and $\bold{D}_3({\sf accum})$. \\
        {\sf GrB\_MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf Mask}. \\
        {\sf GrB\_MASK} & {\sf GrB\_NOCAST} & $\bold{D}({\sf Mask})$ must equal {\sf GrB\_BOOL}. \\
        {\sf GrB\_INP0} & {\sf GrB\_TRAN}   & Use transpose of {\sf A} for operation. \\
        {\sf GrB\_INP0} & {\sf GrB\_NOCAST} & $\bold{D}({\sf A})$ must equal $\bold{D}_1({\sf op})$. \\
        {\sf GrB\_INP1} & {\sf GrB\_TRAN}   & Use transpose of {\sf B} for operation. \\
        {\sf GrB\_INP1} & {\sf GrB\_NOCAST} & $\bold{D}({\sf B})$ must equal $\bold{D}_2({\sf op})$. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
    \item[{\sf GrB\_SUCCESS}]             operation completed successfully
    \item[{\sf GrB\_PANIC}]               unknown internal error
    \item[{\sf GrB\_OUTOFMEM}]            not enough memory available for operation
    \item[{\sf GrB\_DIMENSION\_MISMATCH}] mismatch among matrices dimensions.
    \item[{\sf GrB\_DOMAIN\_MISMATCH}]    mismatch among domains of matrices, and operation, for which the descriptor did not explicitly allow casting.
\end{itemize}

\paragraph{Description}

A consistency check is performed to verify that the
dimensions of {\sf C}, {\sf Mask}, {\sf A} and {\sf B}
are compatible, taking into consideration any transposition. If a 
consistency check fails, the operation is
aborted and the method returns {\sf GrB\_DIMENSION\_MISMATCH}.

\scott{Casting consistency check are performed here for NOCAST parameters}

Matrices $\matrix{B}, \matrix{Mask}$ and $\vector{A}$ are computed from
input parameters {\sf B}, {\sf Mask} and {\sf A}, respectively, as specified
by descriptor {\sf desc}. (See below for the properties of a descriptor. In
the simplest form, these are just copies, but additional preprocessing,
including casting and transposition, can be performed.)  $\bold{D}(\matrix{A}) =
\bold{D}_3({\sf op})$ and $\bold{D}(\matrix{B}) = \bold{D}_3({\sf op})$.
$\bold{D}(\matrix{Matrix}) = {\sf GrB\_BOOL}$.  If {\sf Mask} is {\sf GrB\_NULL} or omitted,
then $\matrix{Matrix}$ is a Boolean matrix of shape 
$\bold{m}(\matrix{\sf C}) \times \bold{n}(\matrix{\sf C})$
and with all elements set to {\sf true}.

If either $\matrix{B}, \matrix{Mask}$ or $\matrix{A}$ cannot be computed
from the input parameters as described above, the method returns 
{\sf GrB\_DOMAIN\_MISMATCH}. \scott{This is too vague for DOMAIN mismatch.}

A new matrix $\matrix{C} = \langle \bold{D}_3({\sf op}),
\bold{m}(\matrix{\sf C}), \bold{n}(\matrix{\sf C}), \bold{L}(\matrix{C}) = \{(i,j,C_{ij})  \forall (i,j) \in
\bold{L}(\matrix{B}) \cup \bold{L}(\matrix{A}) : \matrix{Mask}(i,j)
= {\sf true} \} \rangle$ is created.  The value of each of its
elements is computed by 
\[
C_{ij} = \matrix{A}(i,j) \oplus \matrix{B}(i,j), \ \mbox{if}\  (i,j) \in  \bold{L}(\matrix{B}) \cap \bold{L}(\matrix{A})
\]
\[
C_{ij} = \matrix{A}(i,j) \ \mbox{if}\  (i,j) \in  \bold{L}(\matrix{A}) - (\bold{L}(\matrix{B}) \cap \bold{L}(\matrix{A}))
\]
\[
C_{ij} = \matrix{B}(i,j) \ \mbox{if}\  (i,j) \in  \bold{L}(\matrix{B}) - (\bold{L}(\matrix{B}) \cap \bold{L}(\matrix{A}))
\]
where $\oplus = \bigoplus({\sf op})$ if {\sf op} is a semiring, and $\oplus = \bigodot({\sf op})$
if {\sf op} is a monoid or binary operator.

Note that if $\bold{L}(\matrix{B}) \cup \bold{L}(\matrix{A}) = \emptyset$
then $\bold{L}(\matrix{C}) = \emptyset$.

Finally, output parameter {\sf C} is computed from matrix $\matrix{C}$
as specified by descriptor {\sf desc}. (Again, in the simplest case this
is just a copy, but additional postprocessing, including casting and
accumulation of result values, can be performed.) 

% A consistency check is
% performed to verify that $\bold{n}({\sf w}) = \bold{n}(\matrix{C})$. If
% the consistency check fails, the operation is aborted and the method
% return {\sf GrB\_DIMENSION\_MISMATCH}.
