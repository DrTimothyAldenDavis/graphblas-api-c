\subsection{{\sf extract}: Selecting Sub-Graphs}
\label{Sec:extract}

Extract a sub-matrix from a larger matrix. 

\subsubsection{Standard matrix and vector variants}

In the standard version of {\sf extract}, GraphBLAS index arrays
specify the elements in the source vector/matrix that are copied to
the destination.  For vectors, only one index array is used to specify
elements, and for matrices two index arrays (for row and column indices)
are needed.  The size of the destination vector is the same size as
the one index array provided.  For matrices, the destination matrix has
the same number of rows as the size of the row index array and the same
number of columns as the size of the column index array.

If an accumulation function is specified,
then that function is
used to combine current elements in the destination with those elements
extracted from the source. If no accumulation function is specified, then
the destination is overwritten with the extracted elements.

\paragraph{C99 Syntax (vector variant)}

\begin{verbatim}
        GrB_info GrB_extract(GrB_Vector                *v,
                             const GrB_Vector           mask,
                             const GrB_BinaryFunction   accum,
                             const GrB_Vector           u,
                             const GrB_Index           *indices,
                             const GrB_Index            n,
                          [, const GrB_Descriptor       desc]);
\end{verbatim}

\paragraph{C99 Syntax (matrix variant)}

\begin{verbatim}                 
        GrB_info GrB_extract(GrB_Matrix                *B,
                             const GrB_Matrix           Mask,
                             const GrB_BinaryFunction   accum,
                             const GrB_Matrix           A,
                             const GrB_Index           *rows,
                             const GrB_Index            m,
                             const GrB_Index           *cols,
                             const GrB_Index            n,
                          [, GrB_Descriptor const       desc]);
\end{verbatim}

\paragraph{Parameters (vector variant)}

\begin{itemize}[leftmargin=1in]
    \item[{\sf v}]   ({\sf OUTP}) The vector to store the extracted subgraph.

    \item[{\sf mask}] ({\sf MASK}) Output mask. The mask
    specifies which elements of {\sf dst} can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Function used for accumulating entries into existing {\sf v} entries. 
			If no accumulation is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf u}]   ({\sf ARG0}) The vector from which to extract the subgraph.
    \item[{\sf indices}]     ({\sf ARG1}) The set of element indices specifying elements from source that
                              are extracted. Can
                              be set to {\sf GrB\_ALL} if all elements are
                              to be extracted.
    \item[{\sf n}]     ({\sf ARG2}) The number of indices in array {\sf indices}.

    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf mask})$ to {\sf bool} domain. \\
    {\sf MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf u})$ to $\bold{D}({\sf v})$ \\
    \end{tabular}
\end{itemize}

\paragraph{Parameters (matrix variant)}

\begin{itemize}[leftmargin=1in]
    \item[{\sf B}]   ({\sf OUTP}) The matrix to store the extracted subgraph.

    \item[{\sf Mask}] ({\sf MASK}) Output mask. The mask
    specifies which elements of {\sf dst} can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Function used for accumulating entries into existing {\sf B} entries. 
			If no accumulation is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf A}]   ({\sf ARG0}) The matrix from which to extract the subgraph.
    \item[{\sf rows}]     ({\sf ARG1}) The set of row indices specifying rows from source that
                              are extracted. Can
                              be set to {\sf GrB\_ALL} if all rows are
                              to be extracted.
    \item[{\sf m}]     ({\sf ARG2}) The number of indices in array {\sf rows}.
    \item[{\sf cols}]     ({\sf ARG3}) The set of column indices specifying
                              columns from source that are extracted. Can
                              be set to {\sf GrB\_ALL} if all columns are
                              to be extracted.
    \item[{\sf n}]     ({\sf ARG4}) The number of indices in array {\sf cols}.

    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf mask})$ to {\sf bool} domain. \\
    {\sf MASK} & {\sf GrB\_SCMP}   & Use the structural complement of {\sf mask}. \\
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf src})$ to $\bold{D}({\sf dst})$ \\
    {\sf ARG0} & {\sf GrB\_TRAN}   & Apply transpose to {\sf A} before extract.) \\
    \end{tabular}
\end{itemize}

\paragraph{Return Values (vector variant)}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]    not enough memory available for operation.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]
        A value in {\sf indices} references a non-existent element in {\sf u}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf indices} is not equal to the size of {\sf v}, or
        the dimensions of the mask (if specified) do not match {\sf v}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between $\bold{D}({\sf u})$ and $\bold{D}({\sf v})$, and/or the domains of the 
                                      {\sf accum} operation (if used) when {\sf NOCAST} has
                                      been specified or if $\bold{D}(\sf mask)$ is incorrect.
\end{itemize}

\paragraph{Return Values (matrix variant)}

\scott{Are invalid/unused descriptors an error or ignored?}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]     operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]    not enough memory available for operation.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]
        A value in {\sf rows} references a non-existent row in {\sf A}, or
        the value in {\sf cols} references a non-existent column in {\sf A}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf rows} is not equal to the number of rows in {\sf B}, or
        the size of {\sf cols} is not equal to the number of columns in {\sf B}, or
        the dimensions of the mask (if specified) do not match {\sf B}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between $\bold{D}({\sf A})$ and $\bold{D}({\sf B})$, and/or the domains of the 
                                      {\sf accum} operation (if used) when {\sf NOCAST} has
                                      been specified or if $\bold{D}(\sf Mask)$ is incorrect.
\end{itemize}


\paragraph{Description (vector variant)}

Vectors $\vector{u}$ and $\vector{mask}$ are computed from input
parameters {\sf u} and {\sf mask}, respectively, as specified by
descriptor {\sf desc}.  If either $\vector{u}$ or $\vector{mask}$
cannot be computed from the input parameters, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that all indices in array
{\sf indices} are valid. That is, they must fall within the range of allowed
indices for vector $\vector{u}$ ($0 \leq {\sf indices}[i] < \bold{n}(\vector{u})
\forall i = 0,\ldots,{\sf n}-1$).  Otherwise, the method returns {\sf
GrB\_INDEX\_OUTOFBOUNDS}.

A new vector $\vector{v} = \langle \bold{D}({\sf v}),{\sf n},
\bold{L}(\vector{v}) = \{ (i,v_i), i = 0,\ldots,{\sf n}-1 : {\sf indices}[i]
\in \bold{i}(\vector{u}) \wedge \vector{mask}[i] = \true \} \rangle$
is created.  The value $v_i$ is set to $\vector{u}[{\sf indices}[i]]$. If
casting from $\bold{D}(\vector{u})$ to $\bold{D}(\vector{v})$ is not
allowed, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

Finally, output parameter {\sf v} is computed from vector $\vector{v}$ as
specified by descriptor {\sf desc} and accumulation function {\sf accum}.

\paragraph{Description (matrix variant)}

Matrices $\matrix{A}$ and $\matrix{Mask}$ are computed from input
parameters {\sf A} and {\sf Mask}, respectively, as specified by
descriptor {\sf desc}.  If either $\matrix{A}$ or $\matrix{Mask}$
cannot be computed from the input parameters, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that all indices in arrays
{\sf rows} and {\sf cols} are valid. That is, they must fall within the range of allowed
indices for matrix $\matrix{A}$ ($0 \leq {\sf rows}[i] < \bold{m}(\matrix{A})
\forall i = 0,\ldots,{\sf m}-1$ and
$0 \leq {\sf cols}[j] < \bold{n}(\matrix{A}) \forall j = 0,\ldots,{\sf n}-1$).  Otherwise, the method returns {\sf
GrB\_INDEX\_OUTOFBOUNDS}.

A new matrix $\matrix{B} = \langle \bold{D}({\sf B}),{\sf m},{\sf n},
\bold{L}(\vector{B}) = \{ (i,j,B_{ij}), i = 0,\ldots,{\sf m}-1, j = 0, \ldots,{\sf n}-1 : {\sf rows}[i]
\in \bold{i}(\matrix{A}) \wedge {\sf cols}[j] \in \bold{j}(\matrix{A}) \wedge \vector{Mask}[i,j] = \true \} \rangle$
is created.  The value $B_{ij}$ is set to $\matrix{A}[{\sf rows}[i],{\sf cols}[j]]$. If
casting from $\bold{D}(\vector{A})$ to $\bold{D}(\vector{B})$ is not
allowed, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

Finally, output parameter {\sf B} is computed from matrix $\matrix{B}$ as
specified by descriptor {\sf desc} and accumulation function {\sf accum}.

%-----------------------------------------------------------------------------
\subsubsection{Column (and row) variant}

Extract from one column of a matrix into a vector.  Note that with the transpose
descriptor for the source matrix, elements of an arbitrary row of the matrix
can be extracted with this function as well.

\paragraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_extract(GrB_Vector                *v,
                             const GrB_Vector           mask,
                             const GrB_BinaryFunction   accum,
                             const GrB_Matrix           A,
                             const GrB_Index           *rows,
                             GrB_Index                  m,
                             GrB_Index                  col
                          [, const GrB_Descriptor       desc]); 
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1in]
    \item[{\sf v}]   ({\sf OUTP}) The vector into which to place the extracted values.

    \item[{\sf mask}] ({\sf MASK}) Output mask vector. The mask
    specifies which elements of {\sf v} can be modified.
    If no mask is necessary (i.e., compute all elements of result
    vector), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}]  Function used for accumulating entries into existing {\sf v} entries. 
			If no accumulation is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf A}]   ({\sf ARG0}) The matrix from which to extract the column.

    \item[{\sf rows}]     ({\sf ARG1}) An array of row indices to extract. Can
                              be set to a special array, {\sf GrB\_ALL}, if all elements
                              are to be extracted from the column.
    \item[{\sf m}]     ({\sf ARG2}) The number of indices in array {\sf rows}.
    \item[{\sf col}]     ({\sf ARG3}) The index of the column to extract.

    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf mask})$ to {\sf bool} domain. \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf A})$ to $\bold{D}({\sf v})$ \\
    {\sf ARG0} & {\sf GrB\_TRAN} & Apply transpose to {\sf A} before extract. \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  The indexes specify a position that outside the dimensions of src.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
       The size of {\sf rows} is greater than the size of {\sf v} , 
       or the dimensions of the mask (if specified) do not match {\sf v }.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between $\bold{D}(\sf A)$, 
                                      $\bold{D}({\sf v})$, and/or the domains of the 
                                      {\sf accum} operation (if used) when {\sf NOCAST} has
                                      been specified or if $\bold{D}(\sf mask)$ is incorrect.
\end{itemize}

\paragraph{Description}

Matrix $\matrix{A}$ and vector $\vector{mask}$ are computed from input
parameters {\sf A} and {\sf mask}, respectively, as specified by
descriptor {\sf desc}.  If either $\matrix{A}$ or $\vector{mask}$
cannot be computed from the input parameters, the method returns {\sf
GrB\_DOMAIN\_MISMATCH}.

A consistency check is performed to verify that all indices in array
{\sf rows} and index {\sf col} are valid. That is, they must fall within the range of allowed
indices for matrix $\matrix{A}$ ($0 \leq {\sf rows}[i] < \bold{m}(\matrix{A})
\forall i = 0,\ldots,{\sf m}-1$ and
$0 \leq {\sf col} < \bold{n}(\matrix{A})$).  Otherwise, the method returns {\sf
GrB\_INDEX\_OUTOFBOUNDS}.

A new vector $\vector{v} = \langle \bold{D}({\sf v}),{\sf m},
\bold{L}(\vector{v}) = \{ (i,v_{i}), i = 0,\ldots,{\sf m}-1 : {\sf rows}[i]
\in \bold{i}(\matrix{A}) \wedge {\sf col} \in \bold{j}(\matrix{A}) \wedge \vector{mask}[i] = \true \} \rangle$
is created.  The value $v_{i}$ is set to $\matrix{A}[{\sf rows}[i],{\sf col}]$. If
casting from $\bold{D}(\matrix{A})$ to $\bold{D}(\vector{v})$ is not
allowed, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

Finally, output parameter {\sf v} is computed from vector $\vector{v}$ as
specified by descriptor {\sf desc} and accumulation function {\sf accum}.

%-----------------------------------------------------------------------------
\subsubsection{Single element variants}
\label{Sec:extract_single_element}

Extract one element of a vector/matrix into a scalar. 

\paragraph{C99 Syntax (vector variant)}

\begin{verbatim}
        GrB_info GrB_extract(<type>                    *dst,
                             const GrB_BinaryFunction   accum,
                             const GrB_Vector           u,
                             GrB_Index                  index
                          [, const GrB_Descriptor       desc]); 
\end{verbatim}

\paragraph{C99 Syntax (matrix variant)}

\begin{verbatim}
        GrB_info GrB_extract(<type>                    *dst,
                             const GrB_BinaryFunction   accum,
                             const GrB_Matrix           A,
                             GrB_Index                  row,
                             GrB_Index                  col
                          [, const GrB_Descriptor       desc]); 

\end{verbatim}

\paragraph{Parameters (vector variant)}

\begin{itemize}[leftmargin=1in]
    \item[{\sf dst}]   ({\sf OUTP}) The scalar into which to assign the extracted value.  The specific type should be in domain $\bold{D}({\sf u})$ if {\sf NOCAST} is specified in {\sf desc}.
    \item[{\sf accum}] Function used for accumulation into dst. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.
    \item[{\sf u}]   ({\sf ARG0}) The vector from which to extract the scalar.
    \item[{\sf index}]     ({\sf ARG1}) The index of location to extract

    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf u})$ to type of ${\sf dst}$ \\
    \end{tabular}

\end{itemize}

\paragraph{Parameters (matrix variant)}

\begin{itemize}[leftmargin=1in]
    \item[{\sf dst}]   ({\sf OUTP}) The scalar into which to assign the extracted value.  The specific type should be in domain $\bold{D}({\sf A})$ if {\sf NOCAST} is specified in {\sf desc}.
    \item[{\sf accum}] Function used for accumulation into dst. If no accumulation is desired,
                        {\sf GrB\_NULL} should be specified.
    \item[{\sf A}]   ({\sf ARG0}) The matrix from which to extract the scalar.
    \item[{\sf row}]     ({\sf ARG1}) The row index of location to extract.
    \item[{\sf col}]     ({\sf ARG2}) The column index of location to extract.

    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf A})$ to type of ${\sf dst}$ \\
    {\sf ARG0} & {\sf GrB\_TRAN} &  Transpose {\sf A} before extracting element \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values (vector variant)}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]          Operation completed successfully.
\item[{\sf GrB\_PANIC}]            Unknown internal error.
\item[{\sf GrB\_NO\_VALUE}]        No stored value at specified location.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  Index {\sf index} is out of 
                                      bounds of the vector. 
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between $\bold{D}(\sf u)$ and type of {\sf dst},
                                      and/or the domains of the 
                                      {\sf accum} operation (if used) when {\sf NOCAST} has
                                      been specified.
\end{itemize}

\paragraph{Return Values (matrix variant)}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]          Operation completed successfully.
\item[{\sf GrB\_PANIC}]            Unknown internal error.
\item[{\sf GrB\_NO\_VALUE}]        No stored value at specified location.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  Either the row or the column index,
                                      {\sf row} or {\sf col} is out of matrix bounds.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between the type of $(\sf dst)$, 
                                      $\bold{D}({\sf A})$, and/or the domains of the 
                                      {\sf accum} operation (if used) when {\sf NOCAST} has
                                      been specified.
\end{itemize}

\paragraph{Description (vector variant)}

If $({\sf index},u_{\sf index}) \notin \bold{L}({\sf u})$, the method returns {\sf GrB\_NO\_VALUE}.
Otherwise, if ${\sf accum} = {\sf GrB\_NULL}$, then ${\sf dst} \leftarrow {\sf u}[{\sf index}]$.
If an accumulation function is provided, then ${\sf dst} \leftarrow {\sf accum}({\sf dst},{\sf u}[{\sf index}])$.
If computing the new value of {\sf dst} requires casting and that is not allowed by the descriptor,
the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

\paragraph{Description (matrix variant)}

A matrix $\matrix{A}$ is computed from input parameter {\sf A} as specified by descriptor {\sf desc}.
If $\matrix{A}$ cannot be computed, the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

If $({\sf row},{\sf col}, A_{{\sf row},{\sf col}}) \notin \bold{L}(\matrix{A})$, the method returns {\sf GrB\_NO\_VALUE}.
Otherwise, if ${\sf accum} = {\sf GrB\_NULL}$, then ${\sf dst} \leftarrow \matrix{A}[{\sf row},{\sf col}]$.
If an accumulation function is provided, then ${\sf dst} \leftarrow {\sf accum}({\sf dst},\matrix{A}[{\sf row},{\sf col}])$.
If computing the new value of {\sf dst} requires casting and that is not allowed by the descriptor,
the method returns {\sf GrB\_DOMAIN\_MISMATCH}.

%-----------------------------------------------------------------------------
\subsection{{\sf assign}: Modifying Sub-Graphs}

Assign a matrix to a set of indices (sub-matrix) of a larger matrix

\scott{We are missing use of GrB\_ALL for index arrays in most variants.}

%-----------------------------------------------------------------------------
\subsubsection{Standard Matrix and Vector Versions}

In the standard version of {\sf assign}, GraphBLAS index arrays specify
the locations in the destination vector/matrix that should be assigned
from the source.  For vectors, only one index array is used to specify
locations, and for matrices two index arrays (for row and column indices)
are needed.  The size of the source vector is the same size as the one
index array provided.  For matrices, the source matrix has the same
number of rows as the size of the row index array and the same number
of columns as the size of the column index array.

If an accumulation function is specified, then that function is used
to combine current elements in the destination with those elements
from the source.  If no accumulation function is specified, then the
destination is overwritten with the source.

\jose{We need to discuss if the additional parameters (m,n) that specify the length of index vectors
should be included. They are not strictly necessary, but they make for a self contained description.}

\paragraph{C99 Syntax (vector variant)}

\begin{verbatim}
        GrB_info GrB_assign(GrB_Vector                *v,
                            const GrB_Vector           mask,
                            const GrB_BinaryFunction   accum,
                            const GrB_Vector           u,
                            const GrB_Index           *indices,
                            const GrB_Index            n,
                         [, const GrB_Descriptor       desc])
\end{verbatim}

\paragraph{C99 Syntax (matrix variant)}

\begin{verbatim}
        GrB_info GrB_assign(GrB_Matrix                *B,
                            const GrB_Matrix           Mask,
                            const GrB_BinaryFunction   accum,
                            const GrB_Matrix           A,
                            const GrB_Index           *rows,
                            const GrB_Index            m,
                            const GrB_Index           *cols,
                            const GrB_Index            n,
                         [, const GrB_Descriptor       desc
\end{verbatim}

\paragraph{Parameters (vector variant)}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf v}]   ({\sf OUTP}) The vector into which to assign the subgraph.
    \item[{\sf mask}] ({\sf MASK}) Output mask. The mask specifies which elements
    of {\sf v} can be modified. If no mask is necessary (i.e., compute all
    elements of destination vector), {\sf GrB\_NULL} should be specified.
    \item[{\sf accum}] Function used for accumulation into existing {\sf v} entries.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.
    \item[{\sf u}]   ({\sf ARG0}) The vector containing the subgraph.
    \item[{\sf indices}]     ({\sf ARG1}) An array of indices specifying locations in {\sf v} that
                       are assigned from {\sf u}.
    \item[{\sf n}]    ({\sf ARGS2}) The number of indices in array {\sf indices}.
    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf mask})$ to {\sf bool} domain. \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf u})$ to $\bold{D}({\sf v})$ \\
    \end{tabular}
\end{itemize}

\paragraph{Parameters (matrix variant)}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf B}]   ({\sf OUTP}) The matrix into which to assign the subgraph.
    \item[{\sf Mask}] ({\sf MASK}) Output mask. The mask specifies which elements
    of {\sf B} can be modified. If no mask is necessary (i.e., compute all
    elements of destination matrix), {\sf GrB\_NULL} should be specified.
    \item[{\sf accum}] Function used for accumulation into existing {\sf B} entries.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.
    \item[{\sf A}]   ({\sf ARG0}) The matrix containing the subgraph.
    \item[{\sf rows}]     ({\sf ARG1}) An array of row indices specifying locations in {\sf B} that
                       are assigned from {\sf A}. 
    \item[{\sf m}]     ({\sf ARG2}) The number of indices in array {\sf rows}.
    \item[{\sf cols}]     ({\sf ARG3}) An array of column indices 
                       specifying locations in {\sf B} that are assigned from {\sf A}.
    \item[{\sf n}]	({\sf ARG4}) The number of indices in array {\sf cols}.
    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf mask})$ to {\sf bool} domain. \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf A})$ to $\bold{D}({\sf B})$ \\
    {\sf ARG0} & {\sf GrB\_TRAN} & Apply transpose to {\sf A} before assign. \\
    \end{tabular}
\end{itemize}

\paragraph{Return Value (vector variant)}

\scott{Are invalid/unused descriptors an error?}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]      operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]     not enough memory available for operation.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]
        A value in {\sf indices} references an invalid element of {\sf v} (negative or larger than or equal the size of {\sf v}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf indices} is greater than the number of elements in {\sf u}, or
        the dimensions of the mask (if specified) do not match {\sf v}.
\item[\sf GrB\_DOMAIN\_MISMATCH]  
       domain mismatch between vectors or between vector and the accumulation function when casting is disabled.
\end{itemize}

\paragraph{Return Value (matrix variant)}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]      operation completed successfully.
\item[{\sf GrB\_PANIC}]        unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]     not enough memory available for operation.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]
        A value in {\sf rows} references an invalid row of {\sf B} (negative or larger than or equal the number of rows of {\sf B}),
        or a value in {\sf cols} references an invalid column of {\sf A} (negative or larger than or equal the number of columns of {\sf B}).
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf rows} is greater than the number of rows in {\sf A}, or
        the size of {\sf cols} is greater than the number of columns in {\sf A}, or
        the dimensions of the mask (if specified) do not match {\sf B}.
\item[\sf GrB\_DOMAIN\_MISMATCH]  
       Domain mismatch between matrices or between matrix and the accumulation function when casting is disabled.
\end{itemize}

\paragraph{Description (vector variant)}

Vectors $\vector{u}$ and $\vector{mask}$ are computed from input parameters {\sf u} and {\sf mask}, respectively, as specified by descriptor {\sf desc}. If
the size of $\vector{u}$ does not match argument {\sf n}, return {\sf GrB\_DIMENSION\_MISTMATCH}.

For each $i \in \{0, 1, \ldots, {\sf n}-1 \} : \vector{mask}[i] = \true$, do the following:
\begin{itemize}
	\item[] If $(i, u_i) \notin \bold{L}(\vector{u})$ skip to the next $i$.
	\item[] If $({\sf indices}[i], {\sf v}[{\sf indices}[i]]) \notin \bold{L}({\sf v})$ then
	      $\bold{L}({\sf v}) \leftarrow \bold{L}({\sf v}) \cup ({\sf indices}[i],u_i)$.
	\item[] Else, update ${\sf v}[{\sf indices}[i]] \leftarrow {\sf accum}({\sf v}[{\sf indices}[i]],u_i)$.
\end{itemize}

\paragraph{Description (matrix variant)}

Matrices $\matrix{A}$ and $\matrix{Mask}$ are computed from input parameters {\sf A} and {\sf Mask}, respectively,
as specified by descriptor {\sf desc}. If the shape of $\matrix{A}$ does not match arguments {\sf m} and {\sf n},
return {\sf GrB\_DIMENSION\_MISMATCH}.

For each $\langle i,j \rangle \in \{0, 1, \ldots, {\sf m}-1 \} \times \{0, 1, \ldots, {\sf n}-1 \} : \matrix{Mask}[i,j] = \true$, do the following:
\begin{itemize}
	\item[] If $(i,j,A_{ij}) \notin \bold{L}(\matrix{A})$ skip to next $\langle i,j \rangle$.
	\item[] If $({\sf rows}[i], {\sf cols}[j], {\sf B}[{\sf rows}[i],{\sf cols}[j]]) \notin \bold{L}({\sf B})$ then
	      $\bold{L}({\sf B}) \leftarrow \bold{L}({\sf B}) \cup ({\sf rows}[i],{\sf cols}[j],A_{ij})$.
	\item[]  Else, update ${\sf B}[{\sf rows}[i],{\sf cols}[j]] \leftarrow {\sf accum}({\sf B}[{\sf rows}[i]],{\sf cols}[j],A_{ij})$.
\end{itemize}

%-----------------------------------------------------------------------------
\subsubsection{Column and row variant}

Assign to one column or row of a matrix from a vector.  \scott{Note we cannot use transpose on dst to assign a row, so in this case we have two functions.  Should I add the second function back into extract variant and ditch the transpose descriptor?}

\paragraph{C99 Syntax (column variant)}

\begin{verbatim}
        GrB_info GrB_assign(GrB_Matrix                *B,
                            const GrB_Vector           mask,
                            const GrB_BinaryFunction   accum,
                            const GrB_Vector           u,
                            const GrB_Index           *rows,
                            const GrB_Index            m,
                            GrB_Index                  col
                         [, const GrB_Descriptor       desc]); 
\end{verbatim}

\paragraph{C99 Syntax (row variant)}

\begin{verbatim}
        GrB_info GrB_assign(GrB_Matrix                *B,
                            const GrB_Vector           mask,
                            const GrB_BinaryFunction   accum,
                            const GrB_Vector           u,
                            GrB_Index                  row,
                            const GrB_Index           *cols
                            const GrB_Index            n,
                         [, const GrB_Descriptor       desc]); 
\end{verbatim}

\paragraph{Parameters (column variant)}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf B}]   ({\sf OUTP}) The matrix in which to assign column of values.

    \item[{\sf mask}] ({\sf MASK}) Output mask. The mask specifies which elements
    of {\sf B} can be modified. If no mask is necessary (i.e., compute all
    elements of a column of {\sf B}), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] Function used for accumulation into {\sf dst}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf u}]   ({\sf ARG0}) The vector of values to assign in a column of {\sf B}.

    \item[{\sf rows}]     ({\sf ARG1}) An array of row indices to assign. Can
                              be set to a special array, {\sf GrB\_ALL}, if all elements
                              are to be assigned to the column.
    \item[{\sf cols}]    ({\sf ARG2}) The size of {\sf rows}.
    \item[{\sf col}]     ({\sf ARG3}) The index of the column to assign.

    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf mask})$ to {\sf bool} domain. \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf u})$ to $\bold{D}({\sf B})$ \\
    \end{tabular}

\end{itemize}

\paragraph{Parameters (row variant)}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf B}]   ({\sf OUTP}) The matrix in which to assign column of values.

    \item[{\sf mask}] ({\sf MASK}) Output mask. The mask specifies which elements
    of {\sf B} can be modified. If no mask is necessary (i.e., compute all
    elements of a column of {\sf B}), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] Function used for accumulation into {\sf dst}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf u}]   ({\sf ARG0}) The vector of values to assign in a column of {\sf B}.

    \item[{\sf row}]     ({\sf ARG1}) The index of the row to assign.
    \item[{\sf cols}]     ({\sf ARG2}) An array of column indices to assign. Can
                              be set to a special array, {\sf GrB\_ALL}, if all elements
                              are to be assigned to the row.
    \item[{\sf n}]    ({\sf ARG3}) The size of {\sf cols}.

    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf mask})$ to {\sf bool} domain. \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf u})$ to $\bold{D}({\sf B})$ \\
    \end{tabular}

\end{itemize}

\paragraph{Return Values (column variant)}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]            Not enough memory available for operation.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  The indices specify a position that outside the dimensions of {\sf B}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf rows}, as specified in parameter {\sf m}, is greater than the size of {\sf u}, or
        the dimensions of the mask (if specified) do not match {\sf B}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between vector/matrix domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}

\paragraph{Return Values (row variant)}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_OUTOFMEM}]            Not enough memory available for operation.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  The indices specify a position that outside the dimensions of {\sf B}.
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        The size of {\sf cols}, as specified in parameter {\sf n}, is greater than the size of {\sf u}, or
        the dimensions of the mask (if specified) do not match {\sf B}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between vector/matrix domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}

\paragraph{Description (column variant)}

Vectors $\vector{u}$ and $\vector{mask}$ are computed from input parameters {\sf u} and {\sf mask}, respectively,
as specified by descriptor {\sf desc}. If the shape of $\vector{u}$ does not match argument {\sf m},
return {\sf GrB\_DIMENSION\_MISMATCH}.

For each $i \in \{0, 1, \ldots, {\sf m}-1 \} : \vector{mask}[i] = \true$, do the following:
\begin{itemize}
	\item[] If $(i,u_{i}) \notin \bold{L}(\matrix{u})$ skip to next $i$.
	\item[] If $({\sf rows}[i], {\sf col}, {\sf B}[{\sf rows}[i],{\sf col}]) \notin \bold{L}({\sf B})$ then
	      $\bold{L}({\sf B}) \leftarrow \bold{L}({\sf B}) \cup ({\sf rows}[i],{\sf col},u_{i})$.
	\item[]  Else, update ${\sf B}[{\sf rows}[i],{\sf col}] \leftarrow {\sf accum}({\sf B}[{\sf rows}[i],{\sf col}],u_{i})$.
\end{itemize}

\paragraph{Description (row variant)}

Vectors $\vector{u}$ and $\vector{mask}$ are computed from input parameters {\sf u} and {\sf mask}, respectively,
as specified by descriptor {\sf desc}. If the shape of $\vector{u}$ does not match argument {\sf m},
return {\sf GrB\_DIMENSION\_MISMATCH}.

For each $j \in \{0, 1, \ldots, {\sf n}-1 \} : \vector{mask}[j] = \true$, do the following:
\begin{itemize}
	\item[] If $(j,u_{j}) \notin \bold{L}(\matrix{u})$ skip to next $j$.
	\item[] If $({\sf row}, {\sf cols}[j], {\sf B}[{\sf row},{\sf cols}[j]]) \notin \bold{L}({\sf B})$ then
	      $\bold{L}({\sf B}) \leftarrow \bold{L}({\sf B}) \cup ({\sf row},{\sf cols}[j],u_{j})$.
	\item[]  Else, update ${\sf B}[{\sf row},{\sf cols}[j]] \leftarrow {\sf accum}({\sf B}[{\sf row},{\sf cols}[j]],u_{j})$.
\end{itemize}

%-----------------------------------------------------------------------------
\paragraph{{\sf assign}: Single-Value Variant (was Indexed Variant)}

Set one element of a vector/matrix to a given value.
\scott{I have tried to make this more consistent with the standard version by
adding things like accum. If the destination location is a structural zero, is
a stored value created?.
This could be construed as inconsistent behaviour with standard version.}

\subparagraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_assign(GrB_Vector               *dst,
                            const GrB_BinaryFunction  accum,
                            <type>                    src,
                            GrB_Index                 i
                         [, const GrB_Descriptor      desc]); 

        GrB_info GrB_assign(GrB_Matrix               *dst,
                            const GrB_BinaryFunction  accum,
                            <type>                    src,
                            GrB_Index                 i,
                            GrB_Index                 j
                         [, const GrB_Descriptor      desc]); 
\end{verbatim}

\subparagraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf dst}]   ({\sf OUTP}) Vector/matrix for which an element is to be assigned.

    \item[{\sf accum}] Function used for accumulation into {\sf dst}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf src}]   ({\sf ARG0}) Scalar value to assign to the element.  The type must
                              be consistent with the domain of dst (or castable, if allowed).
    \item[{\sf i}]     ({\sf ARG1}) Row index of element to be assigned
    \item[{\sf j}]     ({\sf ARG2}) Column index of element to be assigned (matrix version)

    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf src})$ to $\bold{D}({\sf dst})$ \\
    \end{tabular}

\end{itemize}

\subparagraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_NOVECTOR}]            Vector does not exist (vector version)
\item[{\sf GrB\_NOMATRIX}]            Matrix does not exist (matrix version)
\item[{\sf GrB\_OUTOFMEM}]            Not enough memory available for operation.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]  The i (or j) indexes specify a position that outside the dimensions of dst
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between vector/matrix domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}

\subparagraph{Description}
\scott{TODO}

%-----------------------------------------------------------------------------
\paragraph{{\sf assign}: Constant variant}

Assign the same value to a specified subgraph.  With use of {\sf GrB\_ALL} the entire
destination vector or matrix can be filled with the constant.

\scott{We should seriously consider a fill method for Vector and Matrix instead.}
\scott{We are missing counts for *i and *j to be consistent with other variants}

\subparagraph{C99 Syntax}

\begin{verbatim}
        GrB_info GrB_assign(GrB_Vector                *dst,
                            const GrB_Vector           mask,
                            const GrB_BinaryFunction   accum,
                            <type>                     src,
                            const GrB_Index           *i
                         [, const GrB_Descriptor       desc]);

        GrB_info GrB_assign(GrB_Matrix                *dst,
                            const GrB_Matrix           Mask,
                            const GrB_BinaryFunction   accum,
                            <type>                     src,
                            const GrB_Index           *i,
                            const GrB_Index           *j
                         [, const GrB_Descriptor       desc]);
\end{verbatim}

\subparagraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf dst}]   ({\sf OUTP}) Vector/Matrix to be assigned.

    \item[{\sf mask}] ({\sf MASK}) Output mask. The mask specifies which elements
    of {\sf dst} can be modified. If no mask is necessary (i.e., compute all
    elements of {\sf dst}), {\sf GrB\_NULL} should be specified.

    \item[{\sf accum}] Function used for accumulation into {\sf dst}.  If no accumulation
                        is desired, {\sf GrB\_NULL} should be specified.

    \item[{\sf src}]   ({\sf ARG0}) Scalar value to assign to all elements.
    \item[{\sf i}]     ({\sf ARG1}) An array of row indices specifying locations in dst that
                       are assigned from src.
    \item[{\sf j}]     ({\sf ARG2}) (Matrix version only) An array of column indices 
                       specifying locations in dst that are assigned from src.


    \item[{\sf desc}]   Operation descriptor (optional). If a
    \emph{default} descriptor is desired, {\sf GrB\_NULL} can be
    used or the descriptor can be omitted.  Valid fields and values are as follows: \\
    \begin{tabular}{lll}
    Field  & Value & Description \\
    \hline
    {\sf MASK} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf mask})$ to {\sf bool} domain. \\
    {\sf MASK} & {\sf GrB\_SCMP} & Use the structural complement of {\sf mask}. \\
    {\sf ARG0} & {\sf GrB\_NOCAST} & Prohibit casting from $\bold{D}({\sf src})$ to $\bold{D}({\sf dst})$ \\
    \end{tabular}

\end{itemize}

\subparagraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]             Operation completed successfully.
\item[{\sf GrB\_PANIC}]               Unknown internal error.
\item[{\sf GrB\_NOVECTOR}]            Vector does not exist (vector version)
\item[{\sf GrB\_NOMATRIX}]            Matrix does not exist (matrix version)
\item[{\sf GrB\_OUTOFMEM}]            Not enough memory available for operation.
\item[{\sf GrB\_INDEX\_OUTOFBOUNDS}]
        A value in i references a nonexistent row in dst, or
        the value in j references a nonexistent column in dst (matrix version).
\item[{\sf GrB\_DIMENSION\_MISMATCH}] 
        the dimensions of the mask (if specified) do not match dst.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]    Mismatch between vector/matrix domain and scalar type,
                                      or a mismatch with {\sf accum}, if specified.
\end{itemize}


\subparagraph{Description}
\scott{TODO}
