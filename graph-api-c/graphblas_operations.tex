\section{GraphBLAS Operations}
\label{Sec:Operations}

\begin{table*}[h]
\hrule
\begin{center}
\caption{A Mathematical overview of the fundamental GraphBLAS operations supported.}
\label{Tab:GraphBLASOps}
\begin{tabular}{l|rrl}
{\sf Operation Name} & \multicolumn{3}{c}{Mathematical Description}  \\
\hline
{\sf mxm}          & $\matrix{C}(\neg\matrix{M})$ & $\oplus=$ & $\matrix{A}^T \oplus.\otimes \matrix{B}^T$  \\
{\sf mxv}          & $\vector{c}(\neg\vector{m})$ & $\oplus=$ & $\matrix{A}^T \oplus.\otimes \vector{b}$  \\
{\sf vxm}          & $\vector{c}(\neg\vector{m})$ & $\oplus=$ & $\vector{b} \oplus.\otimes \matrix{A}^T$  \\
{\sf eWiseMult}    & $\matrix{C}(\neg\matrix{M})$ & $\oplus=$ & $\matrix{A}^T \otimes \matrix{B}^T$  \\
{\sf eWiseAdd}     & $\matrix{C}(\neg\matrix{M})$ & $\oplus=$ & $\matrix{A}^T \oplus  \matrix{B}^T$  \\
{\sf reduce} (row) & $\vector{c}(\neg\vector{m})$ & $\oplus=$ & $\oplus_j\matrix{A}^T(:,j)$  \\
{\sf apply}        & $\matrix{C}(\neg\matrix{M})$ & $\oplus=$ & $f(\matrix{A}^T)$ \\
{\sf transpose}    & $\matrix{C}(\neg\matrix{M})$ & $\oplus=$ & $\matrix{A}^T$ \\
{\sf extract}      & $\matrix{C}(\neg\matrix{M})$ & $\oplus=$ & $\matrix{A}^T(\vector{i},\vector{j})$ \\
{\sf assign}       & $\matrix{C}(\neg\matrix{M})(\vector{i},\vector{j})$ & $\oplus=$ & $\matrix{A}^T$ \\
{\sf buildMatrix}  & $\matrix{C}(\neg\matrix{M})$ & $\oplus=$ & $\mathbb{S}^{m\times n}(\vector{i},\vector{j},\vector{v},\oplus_{dup})$ \\
{\sf extractTuples}& $(\vector{i},\vector{j},\vector{v})$ & $=$ & $\matrix{A}(\neg\matrix{M})$ \\
\end{tabular}
\end{center}
\hrule
\end{table*}


A mathematical overview of the the fundamental GraphBLAS operations that are
discussed in this section are shown in Table~\ref{Tab:GraphBLASOps}.  This
section also specifies variants to some of these operations where they have
been found especially useful in algorithm development.

When a GraphBLAS operation supports the use of an optional mask, that mask is
specified through a GraphBLAS vector (for one-dimensional masks) or
a GraphBLAS matrix (for two-dimensional masks).

Given a GraphBLAS vector $\vector{v} = \langle D,N, \{ (i,v_i) \} \rangle$, a
one-dimensional mask $m = \langle N, \{ i : \mbox{\tt <bool>}v_i = \true \} \rangle$
is derived for use in the operation, where $\mbox{\tt <bool>}v_i$ denotes
casting the value $v_i$ to a Boolean value (\true\ or \false).
We note that, if cast is disallowed for the mask by the operation descriptor, then
$\bold{D}(\vector{v})$ must be {\sf GrB\_BOOL}.

Given a GraphBLAS matrix $\matrix{A} = \langle D, M, N, \{ (i,j,A_{ij}) \} \rangle$,
a two-dimensional mask $\matrix{M} = \langle M,N, \{ (i,j) : \mbox{\tt <bool>}A_{ij} = \true \} \rangle$
is derived for use in the operation, where $\mbox{\tt <bool>}v_i$ denotes
casting the value $A_{ij}$ to a Boolean value (\true\ or \false).
We note that, if cast is disallowed for the mask by the operation descriptor, then
$\bold{D}(\matrix{A})$ must be {\sf GrB\_BOOL}.

In both the one- and two-dimensional cases, the mask may go through a structural
complement operation ($\S$~\ref{Sec:Masks}) as specified in the descriptor, before a final
mask is generated for use in the operation.

\subsection{Note on execution model}

The purpose of most GraphBLAS operations is to manipulate GraphBLAS vectors and matrices
(the input arguments) and produce new content for another GraphBLAS vector or matrix (the output argument).
Each GraphBLAS operation uniquely and unambigiously defines the contents of its output argument.
Any later call to a GraphBLAS method that uses this matrix or vector will use its defined content, until
that content is redefined by another method.

GraphBLAS matrices and vectors are \emph{opaque} objects. That is, they can only be manipulated
by GraphBLAS methods. This opens a wide spectrum of optimizations that can be exploited by GraphBLAS implementations.
Deferred execution, lazy evaluation, chaining and fusion of operations, are all examples of optimizations
that can be used by a GraphBLAS implementation in a manner that is oblivious to the application program.

However, there are situations when this flexibility of the implementation to decide when (and if) an
operation is executed needs to be controlled. First, there are a few methods that use or produce transparent
(nonopaque) data structures. (See \S~\ref{Sec:buildMatrix}, \S~\ref{Sec:extractTuples}, \S~\ref{Sec:extract_single_element}.) 
The application program needs to know that it is safe to modify or inspect
these data structures. (In other words, that the GraphBLAS run-time is done with them.)
Second, there are situations when one wants to make performance measurements of specific
GraphBLAS operations. Making measurements when the actual computation can be postponed or even 
eliminated can lead to unreliable and even misleading observations.

To address these situations, GraphBLAS includes a set of {\sf wait} methods. (See \S~\ref{Sec:wait}.)
When a call to {\sf wait} returns successfully, the calling program is guaranteed that all associated
pending operations have indeed completed. The set of pending operations addressed depends on the
particular variant of {\sf wait} method and is described in the appropriate section.

\subsection{{\sf wait}: Force completion of pending operations}
\label{Sec:wait}

Guarantees that pending GraphBLAS operations are fully executed.

\subsubsection{Broad variant}

\paragraph{C99 syntax}

\begin{verbatim}
        GrB_info GrB_wait()
\end{verbatim}

\paragraph{Parameters}

\paragraph{Return values}
\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]	operation completed successfully
\item[{\sf GrB\_PANIC}]		unknown internal error
\end{itemize}

\paragraph{Description}

Upon return, all previously called GraphBLAS methods have fully completed their execution.
Any (transparent or opaque) data structures produced or manipulated by those methods can be safely touched.

\subsubsection{Matrix variant}

\paragraph{C99 syntax}

\begin{verbatim}
        GrB_info GrB_wait(GrB_Matrix A)
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
	\item[{\sf A}]	({\sf ARG0}) A GraphBLAS matrix.
\end{itemize}

\paragraph{Return values}
\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]	operation completed successfully
\item[{\sf GrB\_PANIC}]		unknown internal error
\end{itemize}

\paragraph{Description}

Upon return, all previously called GraphBLAS methods that used {\sf A} either as input or output have fully completed their execution.
Any (transparent or opaque) data structures produced or manipulated by those methods can be safely touched.

\subsubsection{Vector variant}

\paragraph{C99 syntax}

\begin{verbatim}
        GrB_info GrB_wait(GrB_Vector v)
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
	\item[{\sf v}]	({\sf ARG0}) A GraphBLAS vector.
\end{itemize}

\paragraph{Return values}
\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]	operation completed successfully
\item[{\sf GrB\_PANIC}]		unknown internal error
\end{itemize}

\paragraph{Description}

Upon return, all previously called GraphBLAS methods that used {\sf v} either as input or output have fully completed their execution.
Any (transparent or opaque) data structures produced or manipulated by those methods can be safely touched.
