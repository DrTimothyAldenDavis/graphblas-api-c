\chapter{Possible Extensions}
\label{Chp:Extensions}

This chapter covers material that is currently under discussion for inclusion in 
future revisions (post-1.0) of the GraphBLAS. The material falls into the
following major categories:

\begin{itemize}
\item Standard definitions.
\item Explicitly split execution.
\item Waiting on specific objects.
\item Generalized user-defined types.
\end{itemize}

\section{Standard Definitions}

The current GraphBLAS specification could be augmented with a list of 
pre-defined objects, such as descriptors, semirings and monoids, that are commonly used
in building graph algorithms. These standard pre-defined objects would
simplify coding and ensure more consistency across algorithms. 
We emphasize
that individual application writers are always free to create their own set of
pre-defined objects.

Additionally, GraphBLAS could include pre-defined macros that support
shorter calling syntax for methods, by hiding default arguments. 
Again, individual application writers are always free to create their
own set of pre-defined objects.

We propose that such pre-defined objects and macros would
be included in a compilation unit through a construct like:

\begin{verbatim}
#include "GrB_stddef.h"
\end{verbatim}

\section{Explicitly Split Execution}

In its non-blocking mode of execution, GraphBLAS allows specific implementations to support
various execution approaches. In particular, it allows for non-terminating methods to be 
executed is several stages, possibly interleaved with stages from other methods. This is called \emph{split execution}. In a particular split execution,
a method can go through and \emph{analyze} stage followed by a \emph{perform} stage.
The analyze stage computes various characteristics of the object being produced, whereas the
perform stage does the actual calculations.

It may be desirable to augment GraphBLAS with additional constructs to control this particular
analyze/perform split explicitly. In particular, having the application communicate properties of
an object that do not change between multiple perform stages, and therefore greatly simplifies
or eliminates the need for analyze stages, could be valuable.

As a concrete example, the current GraphBLAS specification exposes {\sf mxm} as a single operation to the user. Under the hood, it is understood that {\sf mxm} is typically implemented in two phases: analyze and compute. The analyze phase consists of allocating memory to the output matrix. The compute phase computes the value at each nonzero of the output matrix. The implementer has the option of deciding whether to set the nonzero structure of the output matrix in the analyze phase or the compute phase.

It may be desirable in some circumstances to expose these two phases of {\sf mxm} to the user as {\sf mxm\_analyze} and {\sf mxm\_compute}. 

For typical use cases, both the size and nonzero structure of the output matrix \textbf{C} is not known \emph{a priori} before the {\sf mxm} operation is run. However, there may exist situations where the user is computing a sequence of output matrices \textbf{C} for which the output nonzeroes share the same \emph{structural zeroes} and therefore, memory allocation. In this case, it may be advantageous for the user to call {\sf mxm\_analyze} and {\sf mxm\_compute} for the first matrix-multiplication in the sequence, and {\sf mxm\_compute} for the rest.

We decided to defer such facilities from version 1.0 of the GraphBLAS specification. We believe
that additional experience with implementation and use of GraphBLAS is necessary before
we can define the proper interfaces for explicit split execution.

\section{Dependency DAGs and {\sf wait} on Specific Objects}

In the current specification of GraphBLAS operating in \emph{nonblocking mode}, the operation {\sf wait} will ensure that the sequence of \emph{GraphBLAS operations} has either completed, or encountered some error. Further, a sequence in nonblocking mode where every GraphBLAS operation is followed by an {\sf wait} call is equivalent to the same sequence in blocking mode
with {\sf wait} calls removed.

It may be desirable that rather than an explicit {\sf wait}, pulling an object out of the computation DAG (directed acyclic graph) will trigger computation to finish up to that point. The advantage of this approach is that the user can specify one particular path along the DAG will be computed rather than all computations in the DAG.

A second alternative would be to modify the {\sf wait} interface such that it takes a specific \emph{GraphBLAS object} as parameter, and makes all computations needed to compute that particular object.

We decided to defer such an interface from version 1.0 of the GraphBLAS specification. We believe that additional experience with implementing \emph{nonblocking mode} and use of GraphBLAS may be necessary before we can determine what is the best approach.

\scott{NEED TO FILL}
\carl{ I added some text, but "pulling an object out of the computation DAG" may be confusing. Maybe someone can check the accuracy of what I wrote.}

\section{Generalized user-defined types}

Currently, GraphBLAS only supports a limited form of user-defined types, as discussed in \S~\ref{Sec:TypeNew}. In particular, ojects of the
data type must have a flat memory representation, so that two objects can be copied with a simple {\tt memcpy} operation. 
It is desirable to lift this restriction. One possiblitiy would be to add a version of {\sf GrB\_Type\_new} that supports
arbitrary user-defined types as follows.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Type_new(GrB_Type   *utype,
                              void       *create,
                              void       *destroy,
                              void       *copy);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
\item[{\sf utype}] ({\sf INOUT}) On successful return, contains a handle to the newly created user-defined GraphBLAS type object.
\item[{\sf create}] ({\sf IN})    A pointer to a function that creates and initializes (to a default state) an object of the user-defined type. Such function must return a {\tt void*} pointer to the new object.
\item[{\sf destroy}] ({\sf IN}) A pointer to a function that destroys an object of the user-defined type, releasing any resources the object uses.
\item[{\sf copy}] ({\sf IN}) A pointer to a function that copies the contents from a source object of the user-defined type to a destination oject of the same user-defined type.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]           operation completed successfully.
\item[{\sf GrB\_PANIC}]             unknown internal error.
\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_NULL\_POINTER}]    at least one of {\sf utype}, {\sf create}, {\sf destroy}, {\sf copy} pointers is {\sf NULL}.
\end{itemize}

\paragraph{Description}
