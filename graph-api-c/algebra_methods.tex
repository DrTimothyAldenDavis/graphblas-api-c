\subsection{Algebra Methods}
\label{Sec:AlgebraMethods}

%-----------------------------------------------------------------------------

\subsubsection{{\sf Type\_new}: Create a new GraphBLAS (user-defined) type}
\label{Sec:TypeNew}

Creates a new user-defined GraphBLAS type. This type can then be used to create new
operators, monoids, semirings, vectors and matrices.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Type_new(GrB_Type	 *utype,
                              <type>	  ctype);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf utype}] ({\sf INOUT}) On successful return, contains a handle 
                                     to the newly created user-defined GraphBLAS 
                                     type object.
	\item[{\sf ctype}] ({\sf IN})    A C type that defines the new GraphBLAS 
                                     user-defined type ({\sf in\_type}).
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]           operation completed successfully.
\item[{\sf GrB\_PANIC}]             unknown internal error.
\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf utype} pointer is {\sf NULL}.
\end{itemize}

\paragraph{Description}

Given a C type, {\sf ctype}, this method returns in {\sf utype} a handle to
a new GraphBLAS type equivalent to that C type.  Variables of this {\sf ctype} 
must be a struct, union, or fixed-size array. In particular, given two variables, 
{\tt src} and {\tt dst}, of type {\sf ctype}, the following operation must be a 
valid way to copy the contents of {\tt src} to {\tt dst}:

\begin{center}
{\tt memcpy(\&dst, \&src, sizeof({\sf ctype}))}
\end{center}

A new user-defined type {\sf utype} should be destroyed with a call to 
{\sf GrB\_free(utype)} when no longer needed.

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created objects will be overwritten. 

%-----------------------------------------------------------------------------
\subsubsection{{\sf UnaryOp\_new}: Create a new GraphBLAS unary operator}

Initializes a new GraphBLAS unary operator with a specified user-defined 
function and its types (domains).

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_UnaryOp_new(GrB_UnaryOp *unary_op,
                                 GrB_Type     d1,
                                 GrB_Type     d2,
                                 void        *unary_func);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf unary\_op}] ({\sf INOUT}) On successful return, contains a
                           handle to the newly created GraphBLAS UnaryOp object.
    \item[{\sf d1}] ({\sf IN})  The {\sf GrB\_Type} of the input 
                           argument of the unary operator being created.  Should be 
                           one of the predefined GraphBLAS types in 
                           Table~\ref{Tab:PredefinedTypes}, or a user-defined GraphBLAS type.
    \item[{\sf d2}] ({\sf IN})  The {\sf GrB\_Type} of the return value of the unary 
                           operator being created.  Should be one of the predefined 
                           GraphBLAS types in Table~\ref{Tab:PredefinedTypes}, or a 
                           user-defined GraphBLAS type.
    \item[{\sf unary\_func}] ({\sf IN})  a pointer to a user-defined function that takes 
                           one input parameter of a \emph{domain compatible} with {\sf d1}'s type
                           and returns a value of \emph{domain compatible} with {\sf d2}'s type. 
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]           operation completed successfully.
\item[{\sf GrB\_PANIC}]             unknown internal error.
\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          any {\sf GrB\_Type} parameter (for
                                    user-defined types) has not been
                                    initialized by a call to {\sf new}.
\item[{\sf GrB\_NULL\_POINTER}]    {\sf unary\_op} or {\sf unary\_func}
                                    pointers are {\sf NULL}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  the types in the function pointer signature
                                    are not compatible with the {\sf GrB\_Type}
                                    parameters specified when user-defined types
                                    are specified.
\end{itemize}

\paragraph{Description}

Creates a new GraphBLAS unary operator $f_u = \langle \bold{D}({\sf d1}), 
\bold{D}({\sf d2}), {\sf unary\_func} \rangle$ and returns a handle to it 
in {\sf unary\_op}.

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created objects will be overwritten. 

%-----------------------------------------------------------------------------

\subsubsection{{\sf BinaryOp\_new}: Create a new GraphBLAS binary operator}

Initializes a new GraphBLAS binary operator with a specified user-defined 
function and its types (domains).

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_BinaryOp_new(GrB_BinaryOp *binary_op,
                                  GrB_Type      d1,
                                  GrB_Type      d2,
                                  GrB_Type      d3,
                                  void         *binary_func);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf binary\_op}] ({\sf INOUT}) On successful return, contains a 
          handle to the newly created GraphBLAS BinaryOp object.
    \item[{\sf d1}]  ({\sf IN}) The {\sf GrB\_Type} of the left hand 
          argument of the binary operator being created. Should be one of the
          predefined GraphBLAS types in Table~\ref{Tab:PredefinedTypes}, or a
          user-defined GraphBLAS type.
    \item[{\sf d2}]  ({\sf IN}) The {\sf GrB\_Type} of the right hand 
          argument of the binary operator being created. Should be one of the
          predefined GraphBLAS types in Table~\ref{Tab:PredefinedTypes}, or a 
          user-defined GraphBLAS type.
    \item[{\sf d3}]  ({\sf IN}) The {\sf GrB\_Type} of the return
          value of the binary operator being created. Should be one of the
          predefined GraphBLAS types in Table~\ref{Tab:PredefinedTypes}, or a 
          user-defined GraphBLAS type.
    \item[{\sf binary\_func}] ({\sf IN}) A pointer to a user-defined function that 
          takes two input parameters of types that are \emph{domain compatible} with {\sf d1} and {\sf d2} and returns a value with the \emph{domain compatible} with {\sf d3}.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]           operation completed successfully.
\item[{\sf GrB\_PANIC}]             unknown internal error.
\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          the {\sf GrB\_Type} (for user-defined types)
                                    has not been initialized by a call to {\sf new}
\item[{\sf GrB\_NULL\_POINTER}]    {\sf binary\_op} or {\sf binary\_func} pointer is {\sf NULL}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  the types in the function pointer signature are not   
                                    compatible with the {\sf GrB\_Type} parameters specified.
\end{itemize}

\paragraph{Description}

Creates a new GraphBLAS binary operator $f_b = \langle \bold{D}({\sf d1}), 
\bold{D}({\sf d2}), \bold{D}({\sf d3}), {\sf binary\_func} \rangle$ and returns
a handle to it in {\sf binary\_op}.

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created objects will be overwritten. 

%-----------------------------------------------------------------------------

\subsubsection{{\sf Monoid\_new}: Create new GraphBLAS monoid}

Creates a new monoid with specified type, binary operator, and identity value.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Monoid_new(GrB_Monoid    *monoid,
                                GrB_Type       d1,
                                GrB_BinaryOp   binary_op,
                                <type>         identity);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf monoid}] ({\sf INOUT}) On successful return, contains a
    handle to the newly created GraphBLAS monoid object.
    \item[{\sf d1}] ({\sf IN}) The {\sf GrB\_Type} the inputs and output of the 
    monoid being created. It should be one of the predefined GraphBLAS types in
    Table~\ref{Tab:PredefinedTypes}, or a user-defined GraphBLAS type.
    \item[{\sf binary\_op}] ({\sf IN}) An existing GraphBLAS associative binary operator with all three domains equal to the domain of type {\sf d1}.
    \item[{\sf identity}]  ({\sf IN}) The value of the identity element of the 
    monoid. Must be the same type as the type corresponding to {\sf d1} according to
    Table~\ref{Tab:PredefinedTypes} or user-defined GraphBLAS types.
\end{itemize}

\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]           operation completed successfully.
\item[{\sf GrB\_PANIC}]             unknown internal error.
\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for operation.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          the {\sf GrB\_Type} (for user-defined types)
                                    or {\sf GrB\_BinaryOp} has not been
                                    initialized by a call to {\sf new}
\item[{\sf GrB\_NULL\_POINTER}]    {\sf monoid} pointer is {\sf NULL}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  the domains of the binary operator are not   
                                    equal to the domain of {\sf GrB\_Type} parameter specified.
\end{itemize}

\paragraph{Description}

Creates a new monoid $M = \langle \bold{D}({\sf d1}), {\sf binary\_op}, 
{\sf identity} \rangle$ and returns a handle to it in {\sf monoid}.

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created objects will be overwritten. 

%-----------------------------------------------------------------------------
\subsubsection{{\sf Semiring\_new}: Create new GraphBLAS semiring}

Creates a new semiring with specified domain, operators, and elements.

\paragraph{\syntax}

\begin{verbatim}
        GrB_Info GrB_Semiring_new(GrB_Semiring  *semiring,
                                  GrB_Monoid     add_op,
                                  GrB_BinaryOp   mul_op);
\end{verbatim}

\paragraph{Parameters}

\begin{itemize}[leftmargin=1.1in]
    \item[{\sf semiring}] ({\sf INOUT}) On successful return, contains a 
    handle to the newly created GraphBLAS semiring.
    \item[{\sf add\_op}]  ({\sf IN}) An existing GraphBLAS commutative monoid that specifies 
    the addition operator and its identity.
    \item[{\sf mul\_op}]  ({\sf IN}) An existing GraphBLAS binary operator that 
    specifies the semiring's multiplication operator. In addition, {\sf mul\_op}'s output domain {\sf d3} must be the same as the {\sf add\_op}'s input domain {\sf d1}.
\end{itemize}


\paragraph{Return Values}

\begin{itemize}[leftmargin=2.1in]
\item[{\sf GrB\_SUCCESS}]           operation completed successfully.
\item[{\sf GrB\_PANIC}]             unknown internal error.
\item[{\sf GrB\_OUT\_OF\_MEMORY}]          not enough memory available for this method to complete.
\item[{\sf GrB\_UNINITIALIZED\_OBJECT}]          the {\sf add\_op} or {\sf mul\_op} object has
                                    not been initialized by a call to {\sf new}
\item[{\sf GrB\_NULL\_POINTER}]    {\sf semiring} pointer is {\sf NULL}.
\item[{\sf GrB\_DOMAIN\_MISMATCH}]  the output domain of {\sf mul\_op} does not
                                    match the domain of the {\sf add\_op}.
\end{itemize}

\paragraph{Description}

Creates a new semiring $S = \langle \bold{D_1}({\sf mul\_op}), 
\bold{D_2}({\sf mul\_op}), \bold{D}({\sf add\_op}), {\sf add\_op}, 
{\sf mul\_op}, \bold{0}({\sf add\_op})\rangle$ and returns a handle to it in 
{\sf semiring}.  Note that $\bold{D_3}({\sf mul\_op})$ must be the same as 
$\bold{D}({\sf add\_op})$.

It is not an error to call this method more than once on the same variable;  
however, the handle to the previously created objects will be overwritten. 
