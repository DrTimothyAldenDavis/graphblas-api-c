\subsubsection{{\sf buildMatrix}: Store elements from tuples into a matrix}

\paragraph{C99 Syntax}

\begin{verbatim}
#include "GraphBLAS.h"
GrB_info GrB_buildMatrix(GrB_Matrix * A,
                         const GrB_IndexArray rowids, const GrB_IndexArray colids, 
                         const GrB_Vector values[, GrB_BinaryFunction accum]);
\end{verbatim}

\scott{Do we need a separate binary function to specify what happens when duplicate locations are specified in the arrays.  Also I agree that we should not be using an opaque type like GrB\_Vector to interface with the outside world.  In C, should this be a void* i.e. an array of arbitrary type with some sort of GrB\_type parameter.}

\paragraph{Input Parameters}

\begin{itemize}
	\item[{\sf rowids}] ({\sf ARG0}) Index array holding row indices. 
	multiply.

	\item[{\sf colids}] ({\sf ARG1}) Index array holding column indices. 

	\item[{\sf values}] ({\sf ARG2}) Vector holding values.  

	\item[{\sf accum}] ({\sf ARG3}) Function used for accumulating entries into \matrix{A}. (optional). 
\end{itemize}

\paragraph{Description}
Each tuple $\{ {\sf rowids(i)}, {\sf colids(i)}, {\sf values(i)}\}$ is a contribution to the output in the form of 

$$\matrix{A}({\sf rowids(i)}, {\sf colids(i)}) = {\sf accum}({\sf values(i)}, \matrix{A}({\sf rowids(i)}, {\sf colids(i)}).$$ 

If {\sf accum} parameter is not provided, then the contribution is of the form 

$$\matrix{A}({\sf rowids(i)}, {\sf colids(i)}) \mathrel{+}= {\sf values(i)}.$$
 
{\sf rowids}, {\sf colids}, and {\sf values} should be of the same length. 

%============================================================================

\subsubsection{{\sf extractTuples}: Extract tuples from a matrix}

Placeholder

\aydin{Aydin to fill}

\paragraph{C99 Syntax}

\begin{verbatim}
#include "GraphBLAS.h"
GrB_info GrB_buildMatrix(GrB_IndexArray rowids, GrB_IndexArray colids,
                         void *values, 
                         const GrB_Matrix A);
\end{verbatim}
