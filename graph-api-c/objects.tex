\chapter{Objects}
\label{Chp:Objects}

The GraphBLAS \emph{algebraic objects} operators, monoids, and semirings
are presented below.
These objects can be used as input arguments to various GraphBLAS
operations, as shown in Table~\ref{Tab:OperatorInputType}.
The specific rules for each algebraic object
are explained in the respective sections of those objects.  A summary
of the properties and recipes for building these GraphBLAS algebraic
objects is presented in Table~\ref{Tab:AlgebraicObjects}.

\begin{table}
    \hrule
    \begin{center}
        \caption{Operator input for relevant GraphBLAS operations. 
        The semiring add and times are shown if applicable.}
        \label{Tab:OperatorInputType}
        \begin{tabular}{l|l}
        Operation           			& Operator input  	\\ \hline
        {\sf mxm, mxv, vxm} 			& semiring 		\\ \hline
        {\sf eWiseAdd}      			& binary operator   	\\
                            			& monoid           	\\
                            			& semiring          	\\ \hline
        {\sf eWiseMult}     			& binary operator   	\\
                            			& monoid          	\\
                            			& semiring         	\\ \hline
       {\sf reduce} (to vector)  		& binary operator	\\ 
                            			& monoid           	\\ \hline
       {\sf reduce} (to scalar)  		& monoid           	\\ \hline
       {\sf apply}         			    & unary operator   	\\ \hline
       {\sf dup} argument (build methods)  	& binary operator   	\\ \hline
       {\sf accum} argument (various methods) 	& binary operator  	\\
       \end{tabular}
    \end{center}
    \hrule
\end{table}

\begin{table}
	\hrule
	\begin{center}
		\caption{Properties and recipes for building GraphBLAS algebraic objects: unary operator, binary operator, monoid and semiring (composed of operations \emph{add} and \emph{times}).\newline
		\hspace{\textwidth}Note 1: the output domain of the semiring times must be same as the domain of the semiring add. This ensures three domains for a semiring rather than four.}
		\label{Tab:AlgebraicObjects}
		
		\vspace{1\baselineskip}
		(a) Properties of algebraic objects.
		\vspace{1\baselineskip}
		
		\begin{tabular}{l|l|l|l|l}
			Object 		& Must be  	& Must be  	& Identity 	& Number \\
			       		& commutative 	& associative 	& must exist 	& of domains  \\
            \hline
			Unary operator 	& no		& no		& no 		& 2 \\
			Binary operator & no		& no 		& no 		& 3  \\
			Monoid          & no		& yes 		& yes 		& 1  \\
			Semiring add 	& yes		& yes 		& yes  		& 1  \\
			Semiring times 	& no		& no 		& no 		& 3  (see Note 1) \\
		\end{tabular}
		
		\vspace{1\baselineskip}
		(b) Recipes for algebraic objects.
		\vspace{1\baselineskip}
		
		\begin{tabular}{l|l|l}
			Object          & Recipe                			            & Number of domains  \\ 
                        \hline
			Unary operator  & Function pointer      			            & 2 \\				
			Binary operator & Function pointer      			            & 3  \\	
			Monoid          & Associative binary operator with identity 	& 1  \\
			Semiring        & Commutative monoid $+$ binary operator 	    & 3 \\
		\end{tabular}
		
	\end{center}
	\hrule
\end{table}

Once algebraic objects (operators, monoids and semirings) are described,
we introduce \emph{collections} (vectors, matrices and masks) that
algebraic objects operate on. Finally, we introduce \emph{descriptors},
which are a simple way to modify how algebraic objects operate on
collections. More concretely, descriptors can be used (among other
things) to perform multiplication with transpose of matrix without the
user having to manually transpose the collection. A complete list of
what descriptors are capable of can be found in the section.

\section{Operators}

A GraphBLAS \emph{binary operator} $F_b = \langle D_1, D_2, D_3, \odot \rangle$
is defined by three domains, $D_1$, $D_2$, $D_3$, and an operation
$\odot: D_1 \times D_2 \rightarrow D_3$.  For a given GraphBLAS operator
$F_b=\langle D_1, D_2, D_3,\odot \rangle$, we define $\bold{D}_1(F_b) = D_1$,
$\bold{D}_2(F_b) = D_2$, $\bold{D}_3(F_b) = D_3$, and $\bold{\bigodot}(F_b)
= \odot$.  Note that $\odot$ could be used in place of either $\oplus$ or $\otimes$.

A GraphBLAS \emph{unary operator} $F_u = \langle D_1, D_2, f\rangle$
is defined by two domains, $D_1$, $D_2$, and an operation
$f: D_1 \rightarrow D_2$.  For a given GraphBLAS operator
$F_u=\langle D_1, D_2, f \rangle$, we define $\bold{D}_1(F_u) = D_1$,
$\bold{D}_2(F_u) = D_2$, and $\bold{f}(F_u) = f$.

\section{Monoids}

A GraphBLAS \emph{monoid} (or \emph{monoid} for short) $M =
\langle D_1,\odot,0 \rangle$ is defined by a single domain $D_1$, an 
\emph{associative}
\footnote{\label{Foot:associative}It is expected 
that implementations of the GraphBLAS will utilize floating point arithmetic 
such as that defined in the IEEE-754 standard even though
floating point arithmetic is not strictly associative.} 
operation $\odot: D_1 \times D_1 \rightarrow D_1$,
and an identity element $0 \in D_1$.  For a given GraphBLAS monoid $M=\langle
D_1,\odot,0 \rangle$ we define $\bold{D}_1(M) = D_1$, $\bold{\bigodot}(M) =
\odot$ and $\bold{0}(M) = 0$.  A GraphBLAS monoid is equivalent to 
the conventional \emph{monoid} algebraic structure.

Let $F = \langle D_1,D_1,D_1,\odot \rangle$ be an associative GraphBLAS binary operator
with identity element $0 \in D_1$.  Then $M = \langle F,0 \rangle = \langle
D_1,\odot,0 \rangle$ is a GraphBLAS monoid. If $\odot$ is commutative,
then $M$ is said to be a \emph{commutative monoid}.
If a monoid $M$ is created using an operator $\odot$ that is
not associative, the outcome of GraphBLAS operations using such a monoid is undefined.

\section{Semirings}

A GraphBLAS \emph{semiring} (or \emph{semiring} for short)
$S=\langle D_1,D_2,D_3,\oplus,\otimes,0 \rangle$ is defined by
three domains $D_1$, $D_2$ and $D_3$, an \emph{associative}
\footnote{\label{Foot:associative}It is expected 
that implementations of the GraphBLAS will utilize floating point arithmetic 
such as that defined in the IEEE-754 standard even though
floating point arithmetic is not strictly associative.} 
and commutative
additive operation $\oplus : D_3 \times D_3 \rightarrow D_3$, 
a multiplicative operation $\otimes : D_1 \times D_2 \rightarrow
D_3$, and an identity element $0 \in D_3$.
For a given GraphBLAS semiring $S=\langle D_1,
D_2, D_3,\oplus,\otimes,0 \rangle$ we define $\bold{D}_1(S) = D_1$,
$\bold{D}_2(S) = D_2$, $\bold{D}_3(S) = D_3$, $\bold{\bigoplus}(S) =
\oplus$, $\bold{\bigotimes}(S) = \otimes$, and $\zero(S) = 0$. 

Let $F = \langle D_1,D_2,D_3,\otimes \rangle$ be an operator
and let $A = \langle D_3,\oplus,0 \rangle$ be a commutative monoid,
then $S= \langle A,F \rangle = \langle D_1,D_2,D_3,\oplus,\otimes,0 \rangle$
is a semiring.

Note: There must be one GraphBLAS monoid in every semiring which 
serves as the semiring's additive operator and  
specifies the same domain for its inputs and output parameters. 
If such monoid is not a commutative monoid, the outcome of GraphBLAS
operations using the semiring is undefined.

A UML diagram of the conceptual hierarchy of object classes in GraphBLAS
algebra (binary operators, monoids and semirings) is shown in 
Figure~\ref{Fig:AlgebraHierarchy}.

\begin{figure}[htb]
    \hrule
    \begin{center}
        \includegraphics[width=1.0\linewidth,trim=3in 2in 0.5in 2in]{Algebra_Hierarchy_v2.pdf}
    \end{center}
    \caption{Hierarchy of algebraic object classes in GraphBLAS. GraphBLAS semirings consist of a conventional monoid with one domain for the 'add' function, and a binary operator with three domains for the 'multiply' function.}
    \label{Fig:AlgebraHierarchy}
    \hrule
\end{figure}

\section{Vectors}
\label{Sec:Vectors}

A vector $\vector{v} = \langle D, N, \{ (i,v_i) \} \rangle$ is defined by
a domain $D$, a size $N>0$ and a set of tuples $(i,v_i)$ where $0 \leq
i < N$ and $v_i \in D$. A particular value of $i$ can only appear at
most once in $\vector{v}$. We define $\bold{size}(\vector{v}) = N$ and
$\bold{L}(\vector{v}) = \{ (i,v_i) \}$. The set $\bold{L}(\vector{v})$ is
called the \emph{content} of vector $\vector{v}$. We also define the set
$\vector{ind(\vector{v})} = \{ i : (i,v_i) \in \bold{L}(\vector{v}) \}$
(called the \emph{structure} of $\vector{v}$), and $\bold{D}(\vector{v})
= D$. For a vector $\vector{v}$, $\vector{v}(i)$ is a reference to $v_i$
if $(i,v_i) \in \bold{L}(\vector{v})$ and is undefined otherwise.

\section{Matrices}
\label{Sec:Matrices}

A matrix $\matrix{A} = \langle D, M, N, \{ (i,j,A_{ij}) \} \rangle$ is
defined by a domain $D$, its number of rows $M>0$, its number of columns
$N>0$ and a set of tuples $(i,j,A_{ij})$ where $0 \leq i < M$, $0 \leq
j < N$, and $A_{ij} \in D$. A particular pair of values $i,j$ can only
appear at most once in $\matrix{A}$. We define $\bold{ncols}(\matrix{A})
= N$,  $\bold{nrows}(\matrix{A}) = M$ and $\bold{L}(\matrix{A}) =
\{ (i,j,A_{ij}) \}$.  The set $\bold{L}(\matrix{A})$ is called the
\emph{content} of matrix $\matrix{A}$.  We also define the sets
$\vector{indrow(\matrix{A})} = \{ i : \exists (i,j,A_{ij}) \in
\matrix{A} \}$ and $\vector{indcol(\matrix{A})} = \{ j : \exists
(i,j,A_{ij}) \in \matrix{A} \}$.  (These are the sets of nonempty
rows and columns of $\matrix{A}$, respectively.)  The \emph{structure}
of matrix $\matrix{A}$ is the set $\bold{ind}(\matrix{A}) = \{ (i,j) :
(i,j,A_{ij}) \in \bold{L}(\matrix{A}) \}$, and $\bold{D}(\matrix{A}) = D$.
For a matrix $\matrix{A}$, $\matrix{A}(i,j)$ is a reference to $A_{ij}$
if $(i,j,A_{ij}) \in \bold{L}(\matrix{A})$ and is undefined otherwise.

If $\matrix{A}$ is a matrix and $0 \leq j < N$, then $\matrix{A}(:,j)
= \langle D, M, \{(i,A_{ij}) : (i,j,A_{ij}) \in \bold{L}(\matrix{A})
\} \rangle$ is a vector called the $j$-th \emph{column}
of $\matrix{A}$. Correspondingly, if $\matrix{A}$ is a matrix and
$0 \leq i < M$, then $\matrix{A}(i,:) = \langle D, N, \{(j,A_{ij}) :
(i,j,A_{ij}) \in \bold{L}(\matrix{A}) \} \rangle$ is a vector called
the $i$-th \emph{row} of $\matrix{A}$.

Given a matrix $\matrix{A} = \langle D, M, N, \{ (i,j,A_{ij}) \} \rangle$,
its \emph{transpose} is another matrix $\matrix{A}^T = \langle D, N, M, \{
(j,i,A_{ij}) : (i,j,A_{ij}) \in \bold{L}(\matrix{A}) \} \rangle$.

\section{Masks}
\label{Sec:Masks}

The GraphBLAS C API defines an opaque object called a \emph{mask}.  The mask
is used to control how computed values are stored in the output from a method. 
The mask is an \emph{internal} opaque object, i.e. it is never exposed as a variable
within an application. 

The mask is formed from objects input to the method that uses 
the mask.  For example, a GraphBLAS method may be called with a matrix as the mask
parameter.   The internal mask object is constructed from the input matrix with an element of the 
mask for each tuple that exists in the matrix for which the value of the tuple 
cast to Boolean is $true$.

The internal mask object can be either a one- or a two-dimensional construct.  One- and
two-dimensional masks, described more formally below, are similar to
vectors and matrices, respectively, except that they have structure
(indices) but no values.  When needed, a value is implied for the elements of a 
mask with an implied value of {\tt true} for elements that exist 
and an implied value of {\tt false} for elements that do not exist (i.e.
the structural zeros of the mast imply a value of {\tt false}).
Hence, even though a mask does not contain any values, it can be 
considered to imply values from a Boolean domain

A one-dimensional mask $\vector{m} = \langle N, \{ i \} \rangle$ is
defined by its number of elements $N>0$ and a set $\bold{ind}(\vector{m})$
of indices $\{ i \}$ where $0 \leq i < N$.  A particular value of $i$ can
only appear at most once in $\vector{m}$. We define $\bold{size}(\vector{m})
= N$. The set $\bold{ind}(\vector{m})$ is called the \emph{structure} of mask $\vector{m}$.

A two-dimensional mask $\matrix{M} = \langle M, N, \{ (i,j) \}
\rangle$, is defined by its number of rows $M>0$, its number of
columns $N>0$ and a set $\bold{ind}(\matrix{M})$ of tuples $(i,j)$
where $0 \leq i < M$, $0 \leq j < N$.   A particular pair of values
$i,j$ can only appear at most once in $\matrix{M}$.  We define
$\bold{ncols}(\matrix{M}) = N$, and $\bold{nrows}(\matrix{M}) = M$.
We also define the sets $\vector{indrow(\matrix{M})} = \{ i : \exists
(i,j) \in \bold{ind}(\matrix{M}) \}$ and $\vector{indcol(\matrix{M})}
= \{ j : \exists (i,j) \in \bold{ind}(\matrix{M}) \}$.  These are
the sets of nonempty rows and columns of $\matrix{M}$, respectively.
The set $\bold{ind}(\matrix{M})$ is called the \emph{structure} of mask $\matrix{M}$.

One common operation on masks is the \emph{structural complement}.
For a one-dimensional mask $\vector{m}$ this is denoted as
$\neg\vector{m}$. For a two-dimensional masks this is denoted as
$\neg\matrix{M}$.  The structure of the complement of an one-dimensional
mask $\vector{m}$ is defined as $\bold{ind}(\neg\vector{m}) = \{i : 0
\leq i < N, i \notin \bold{ind}(\vector{m}) \}$.  It is the set of all
possible indices that do not appear in $\vector{m}$.  The structure
of the complement of a two-dimensional mask $\matrix{M}$ is defined as the set
$\bold{ind}(\neg\matrix{M}) = \{(i,j)$ : $0 \leq i < M$, $0 \leq j < N$,
$(i,j) \notin \bold{ind}(\matrix{M}) \}$.  It is the set of all possible
indices that do not appear in $\matrix{M}$.

\section{Descriptors}

Descriptors are used to modify the behavior of a GraphBLAS method.
When present in the signature of a method, they appear as the last argument in the method.
Descriptors specify how the other input arguments
corresponding to GraphBLAS collections -- vectors, matrices and masks -- should
be processed (modified) before the main operation of a method is performed.

The descriptor is a lightweight object.  It is composed
of (field, value) pairs where the \emph{field} selects one of the GraphBLAS objects
from the argument list of a method and the \emph{value} defines the indicated modification
associated with that object.  For example, a descriptor may specify that a particular 
input matrix needs to be transposed or that a mask needs to be structurally 
complemented (defined in Section~\ref{Sec:Masks}) before using it in the operation.

For the purpose of constructing descriptors, the arguments of a method
that can be modified are identified by specific field names. The output parameter (typically
the first parameter in a GraphBLAS method) is indicated by the field name, 
{\sf GrB\_OUTP}.  The mask is indicated by the {\sf GrB\_MASK} field name. The input parameters
corresponding to the input vectors and matrices are indicated by {\sf GrB\_INP0} and
{\sf GrB\_INP1} in the order they appear in the signature of the GraphBLAS method. 
The descriptor is an opaque object and hence we do not define how objects of this type should
be implemented.   When referring to (field, value) pairs for a descriptor, however, we often use the informal
notation {\sf desc[GrB\_Desc\_Field].GrB\_Desc\_Value} (without implying that a descriptor is to be implemented as an
array of structures).    We summarize all types, field names, and values used 
with descriptors in Table~\ref{Tab:DescTypeLiterals}. 



\begin{table}
\hrule
\begin{center}
\caption{Descriptors are GraphBLAS objects passed as arguments to Graph\_BLAS 
operations to modify other GraphBLAS objects in the operation's argument list.
A descriptor, {\sf desc}, has one or more (field, value) pairs indicated 
as  {\sf desc[GrB\_Desc\_Field].GrB\_Desc\_Value}. In this table, we define all types and literals used
with Descriptors.}
\label{Tab:DescTypeLiterals}

\vspace{1\baselineskip}
(a) Types used with GraphBLAS Descriptors.
\vspace{1\baselineskip}

\begin{tabular}{l|l}
Type			& Description \\ \hline
{\sf GrB\_Descriptor}     &  Type of a GraphBLAS descriptor object. \\
{\sf GrB\_Desc\_Field}              &  Type of a descriptor field. \\
{\sf GrB\_Desc\_Value}             &  Type of a descriptor field's value. \\
\end{tabular}

\vspace{1\baselineskip}
(b) Descriptor field names of type {\sf GrB\_Desc\_Field}.
\vspace{1\baselineskip}

\begin{tabular}{l|l}
Field name          & Description \\ \hline
{\sf GrB\_OUTP} &  Field name for the output GraphBLAS object. \\
{\sf GrB\_INP0}   &  Field name for the first input GraphBLAS object. \\
{\sf GrB\_INP1}   &  Field name for the second input  GraphBLAS object. \\
{\sf GrB\_MASK} &  Field name for the mask GraphBLAS object. \\\
\end{tabular}

\vspace{1\baselineskip}
(c) Descriptor field values of type {\sf GrB\_Desc\_Value}.
\vspace{1\baselineskip}

\begin{tabular}{l|l}
Field Value                & Description \\ \hline
{\sf GrB\_SCMP}       &  Use the structural complement of the associated object.\\
{\sf GrB\_TRAN}        &  Use the transpose of the associated object.\\
{\sf GrB\_REPLACE} &  Clear the output object before assigning computed values.\\
\end{tabular}
\end{center}
\hrule
\end{table}

In the definitions of the GraphBLAS methods, we often refer to the \emph{default behavior} of a method with 
respect to the action of a descriptor.   If a descriptor is not provided or if the value associated with a particular field in a descriptor 
is not set, the default behavior of a GraphBLAS method is defined as follows.
\begin{itemize}
\item Input matrices are not transposed.
\item The structural complement of the mask is not used.
\item Values of the output object that are not directly modified by the operation are preserved.
\end{itemize}

