\chapter{Objects}

The following objects (functions, monoids, and semirings) are presented in increasing generality.
The ``algebra generality rule'' of GraphBLAS states that a more general object can always be passed to
any function which requires a less general object. The restriction rules are explained in the respective sections of those objects.

\section{Functions}

A GraphBLAS \emph{binary function} $F_b = \langle D_1, D_2, D_3, \odot \rangle$
is defined by three domains, $D_1$, $D_2$, $D_3$, and an operation
$\odot: D_1 \times D_2 \rightarrow D_3$.  For a given GraphBLAS function
$F_b=\langle D_1, D_2, D_3,\odot \rangle$ we define $\bold{D}_1(F_b) = D_1$,
$\bold{D}_2(F_b) = D_2$, $\bold{D}_3(F_b) = D_3$, and $\bold{\bigodot}(F_b)
= \odot$.  Note that $\odot$ could be used in place of either $\oplus$ or $\otimes$.

A GraphBLAS \emph{unary function} $F_u = \langle D_1, D_2, f\rangle$
is defined by two domains, $D_1$, $D_2$, and an operation
$f: D_1 \rightarrow D_2$.  For a given GraphBLAS function
$F_u=\langle D_1, D_2, f \rangle$ we define $\bold{D}_1(F_u) = D_1$,
$\bold{D}_2(F_u) = D_2$, and $\bold{f}(F)
= f$.

\section{Monoids}

A GraphBLAS \emph{generalized monoid} (or \emph{monoid} for short) $M =
\langle D_1,\odot,0 \rangle$ is defined by a single domain $D_1$, an 
\emph{associative} operation $\odot: D_1 \times D_1 \rightarrow D_1$,
and an identity element $0 \in D_1$.  For a given GraphBLAS monoid $M=\langle
D_1,\odot,0 \rangle$ we define $\bold{D}_1(M) = D_1$, $\bold{\bigodot}(M) =
\odot$ and $\bold{0}(M) = 0$.  A GraphBLAS monoid is equivalent to 
the conventional \emph{monoid} algebraic structure.

Let $F = \langle D_1,D_1,D_1,\odot \rangle$ be a GraphBLAS function
with element $0 \in D_1$.  Then $M = \langle F,0 \rangle = \langle
D_1,\odot,0 \rangle$ is a GraphBLAS monoid.

Note: It is understood that \emph{associativity} is not guaranteed in IEEE 754 floating-point arithmetic. \carl{Placeholder for precise wording that Tim wants to add} 

\section{Semirings}

A GraphBLAS \emph{generalized semiring} (or \emph{semiring} for short)
$S=\langle D_1,D_2,D_3,\oplus,\otimes,0 [,1] \rangle$ is defined by
three domains $D_1$, $D_2$ and $D_3$, an \emph{associative} additive operation $\oplus :
D_3 \times D_3 \rightarrow D_3$, 
a multiplicative operation $\otimes : D_1 \times D_2 \rightarrow
D_3$, an element $0 \in D_3$ and an optional element $1 \in D_3$.
For a given GraphBLAS semiring $S=\langle D_1,
D_2, D_3,\oplus,\otimes,0,1 \rangle$ we define $\bold{D}_1(S) = D_1$,
$\bold{D}_2(S) = D_2$, $\bold{D}_3(S) = D_3$, $\bold{\bigoplus}(S) =
\oplus$, $\bold{\bigotimes}(S) = \otimes$, $\zero(S) = 0$ and $\one(S) =
1$. We note that, in the special case of $D_1 = D_2 = D_3$, $1$ defined 
and the identity of $\otimes$, and $0$ working as the $\oplus$ identity
and $\otimes$ annihilator (\ie, $0 \otimes x = x
\otimes 0 = 0, \forall x \in D_3$), a GraphBLAS semiring reduces to the
conventional \emph{semiring} algebraic structure.

Let $M = \langle D_3, \otimes,1 \rangle$ and $A = \langle D_3,\oplus,0 \rangle$ be monoids.
Then $S= \langle A,M \rangle = \langle D_3,D_3,D_3,\oplus,\otimes,0,1 \rangle$
is a semiring.

Let $F = \langle D_1,D_2,D_3,\otimes \rangle$ be a function
and let $A = \langle D_3,\oplus,0 \rangle$ be a monoid,
then $S= \langle A,F \rangle = \langle D_1,D_2,D_3,\oplus,\otimes,0 \rangle$
is a semiring.

Note: There must be at least one GraphBLAS monoid in every semiring. If there 
is only one monoid, it must serve as the semiring's additive operator which
specifies the same domain for its inputs and output parameters. This 
requirement is the minimum constraint in order to parallelize certain 
GraphBLAS operations.

A UML diagram of the conceptual hierarchy of object classes in GraphBLAS
algebra (binary functions, monoids and semirings) is shown in 
Figure~\ref{Fig:AlgebraHierarchy}.

\begin{figure}[htb]
    \hrule
    \begin{center}
        \includegraphics[width=1.0\linewidth,trim=1.5in 2in 1.5in 2in]{Algebra_Hierarchy.pdf}
    \end{center}
    \caption{Hierarchy of object classes in GraphBLAS algebra. Note there are 
    two ways to specify semirings: with and without specifying the
    multiplicative identity.  Also notice that the additive monoid for the
    semiring specify the same domain for input and output parameters.}
    \label{Fig:AlgebraHierarchy}
    \hrule
\end{figure}

\begin{table}
    \hrule
    \begin{center}
        \caption{Proposed operator input for relevant GraphBLAS operations. 
        The semiring add and times are shown if applicable.}
        \label{Tab:OperatorInputType}
        \begin{tabular}{l|l|l|l}
        Operation           & Operator Input  & Semiring Add & Semiring Times  \\ \hline
        {\sf mxm, mxv, vxm} & Semiring        & Monoid       & Binary Function \\
                            &                 & Monoid       & Monoid \\
        {\sf eWiseAdd}      & Binary Function & n/a          & n/a  \\
                            & Monoid          & n/a          & n/a  \\
                            & Semiring        & n/a          & n/a  \\
        {\sf eWiseMult}     & Binary Function & n/a          & n/a  \\
                            & Monoid          & n/a          & n/a  \\
                            & Semiring        & n/a          & n/a  \\
        {\sf reduce} (row)  & Binary Function & n/a          & n/a  \\
                            & Monoid          & n/a          & n/a  \\
        {\sf reduce} (col)  & Binary Function & n/a          & n/a  \\
                            & Monoid          & n/a          & n/a  \\
        {\sf reduce}        & Monoid          & n/a          & n/a  \\
        {\sf apply}         & Unary Function  & n/a          & n/a  \\
  {\sf buildMatrix} (dups)  & Binary Function & n/a          & n/a  \\
                            & Monoid          & n/a          & n/a  \\
{\sf accum} param, any op   & Binary Function & n/a          & n/a  \\
                            & Monoid          & n/a          & n/a  \\
        \end{tabular}
    \end{center}
    \hrule
\end{table}

\section{Vectors}
\label{Sec:Vectors}

A vector $\vector{v} = \langle D, N, \{ (i,v_i) \} \rangle$ is defined
by a domain $D$, a size $N>0$ and a set of tuples $(i,v_i)$ where
$0 \leq i < N$ and $v_i \in D$. A particular value of $i$ can only
appear at most once in $\vector{v}$. We define $\bold{n}(\vector{v}) =
N$ and $\bold{L}(\vector{v}) = \{ (i,v_i) \}$. We also define the set
$\vector{i(\vector{v})} = \{ i : (i,v_i) \in \bold{L}(\vector{v}) \}$,
and $\bold{D}(\vector{v}) = D$.

\section{Matrices}
\label{Sec:Matrices}

A matrix $\matrix{A} = \langle D, M, N, \{ (i,j,A_{ij}) \} \rangle$ is
defined by a domain $D$, its number of rows $M>0$, its number of columns
$N>0$ and a set of tuples $(i,j,A_{ij})$ where $0 \leq i < M$, $0 \leq
j < N$, and $A_{ij} \in D$. A particular pair of values $i,j$ can only
appear at most once in $\matrix{A}$. We define $\bold{n}(\matrix{A})
= N$,  $\bold{m}(\matrix{A}) = M$ and $\bold{L}(\matrix{A}) = \{
(i,j,A_{ij}) \}$.  We also define the sets $\vector{i(\matrix{A})} = \{
i : \exists (i,j,A_{ij}) \in \matrix{A} \}$ and $\vector{j(\matrix{A})}
= \{ j : \exists (i,j,A_{ij}) \in \matrix{A} \}$.  (These are the sets
of nonempty rows and columns of $\matrix{A}$, respectively.)  Finally,
$\bold{D}(\matrix{A}) = D$.

If $\matrix{A}$ is a matrix and $0 \leq j < N$, then $\matrix{A}(:,j)
= \langle D, M, \{(i,A_{ij}) : (i,j,A_{ij}) \in \bold{L}(\matrix{A})
\} \rangle$ is a vector called the $j$-th \emph{column}
of $\matrix{A}$. Correspondingly, if $\matrix{A}$ is a matrix and
$0 \leq i < M$, then $\matrix{A}(i,:) = \langle D, N, \{(j,A_{ij}) :
(i,j,A_{ij}) \in \bold{L}(\matrix{A}) \} \rangle$ is a vector called
the $i$-th \emph{row} of $\matrix{A}$.

\section{Masks}
\label{Sec:Masks}

A mask can be either a one- or a two-dimensional construct.
One- and two-dimensional masks, described more formally below, are
similar to vectors and matrices, respectively, except that they have
structure (indices) but no domain or values.
Masks are used to perform fine-grain control of GraphBLAS operations.

A one-dimensional mask $\vector{m} = \langle N, \{ i \} \rangle$
is defined by its number of elements $N>0$ and a set $\bold{L}(\vector{m})$ of indices $\{ i \}$ 
where $0 \leq i < N$.  A particular value of $i$ can only
appear at most once in $\vector{m}$. We define $\bold{n}(\vector{m}) = N$. 
We also define the set
$\vector{i(\vector{m})} = \{ i : i \in \bold{L}(\vector{m}) \}$.

A two-dimensional mask $\matrix{M} = \langle M, N, \{ (i,j) \} \rangle$,
is defined by its number of rows $M>0$, its number of columns
$N>0$ and a set $\bold{M}(\matrix{M})$ of tuples $(i,j)$ where $0 \leq i < M$, $0 \leq
j < N$.   A particular pair of values $i,j$ can only
appear at most once in $\matrix{M}$.  We define $\bold{n}(\matrix{M})
= N$, and $\bold{m}(\matrix{M}) = M$.  
We also define the sets $\vector{i(\matrix{M})} = \{
i : \exists (i,j) \in \bold{L}(\matrix{M}) \}$ and $\vector{j(\matrix{M})}
= \{ j : \exists (i,j) \in \bold{L}(\matrix{M}) \}$.  These are the sets
of nonempty rows and columns of $\matrix{M}$, respectively.

One common operation on masks is the \emph{structural complement}.  For a one-dimensional mask $\vector{m}$ this
is denoted as $\neg\vector{m}$. For a two-dimensional
masks this is denoted as $\neg\matrix{M}$.
The structure of the complement of an one-dimensional mask $\vector{m}$ is
defined as $\bold{L}(\neg\vector{m}) = \{i : 0 \leq i < N, i \notin \bold{L}(\vector{m}) \}$.
It is the set of all possible indices that do not appear in $\vector{m}$.
The structure of the complement of a two-dimensional mask $\matrix{M}$ is
defined as $\bold{L}(\neg\matrix{M}) = \{(i,j)$ : $0 \leq i < M$, $0 \leq
j < N$, $(i,j) \notin \bold{L}(\matrix{M}) \}$.  It is the set of all possible
indices that do not appear in $\matrix{M}$.

\section{Descriptors}

Descriptors are used as input parameters in various GraphBLAS methods to
provide more details of the operation to be performed by those methods.
In particular, descriptors specify how the other input parameters
should be processed before the main operation of a method is performed.
A Descriptor is a lightweight object with a collection of flags
for various modifiers for the other arguments.  Each type of argument
(vectors, matrices, masks, accum functions, etc) have a different set of
valid flags.

For example, a descriptor may specify that a particular input matrix
needs to be transposed or that a mask needs to be structurally complemented 
(defined in Section~\ref{Sec:Masks})
before using it in the operation.  Some methods may also allow additional
processing of the result before generating the final output parameter.

For the purpose of constructing descriptors, the parameters of a method
are identified by specific names. The output parameter (typically
the first parameter in a GraphBLAS method) is {\sf OUTP}.  The mask is 
almost always next and is named {\sf MASK}. The input parameters (but
not the operations) are named {\sf ARG0}, {\sf ARG1}, {\sf ARG2} and so 
on from the first input parameter to the last. Finally, the descriptor
(typically the last parameter in a method) is not named, since GraphBLAS
does not support modifications of descriptors themselves.
